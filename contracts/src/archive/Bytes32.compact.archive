// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Bytes32.compact)

pragma language_version >= 0.19.0;

/**
 * @title Bytes32 module (ARCHIVED)
 * @notice This module is currently archived and requires maintenance before use.
 *
 * @dev ARCHIVAL REASON:
 * This module depends on Field255 for comparison operations, which has fundamental limitations:
 * - Bytes<32> can represent values up to 2^256 - 1 (256 bits)
 * - JubJub scalar field max is ~2^255 (255 bits)
 * - Field-to-Uint conversion is limited by Compact's max Uint size
 *
 * COMPACT UINT LIMITATIONS:
 * - v0.26.0: Max Uint<254> — Field values >= 2^254 truncated
 * - v0.27.0: Max Uint<248> (31 bytes) — Field values >= 2^248 truncated
 *
 * Comparison operations (lt, lte, gt, gte) that rely on Field255 will produce incorrect
 * results for Bytes<32> values that exceed the representable range.
 *
 * @description Comprehensive utility functions for working with Bytes<32> types.
 * Includes conversion functions, equality checks, and comparison operations using field conversion.
 *
 * @remarks
 * This module provides a complete set of utilities for 32-byte manipulation and comparison.
 * Comparison operations convert bytes to field elements and then to unsigned integers for ordering.
 * All functions are designed to work specifically with 32-byte arrays.
 *
 * TODO: Implement secure U256 conversion circuits:
 * - toU256(): Convert Bytes<32> to U256 (more accurate than converting to Field)
 * - fromU256(): Convert U256 to Bytes<32>
 *   These conversions will be supported when casting Bytes<k> to Vector<k, Uint<8>> is released.
 *   See PR: https://github.com/midnightntwrk/compactc/pull/1090.
 *   Once this PR's feature is released, arithmetic operations such as add, sub, mul, div,
 *   and rem will also be supported for Bytes<32> via U256 conversion.
 *
 * Supported Mathematical Operations:
 * - Conversions:
 *   - toField(): Converts Bytes<32> to a Field using field conversion.
 *   - toBytes(): Converts a Field to Bytes<32> using upgrade_from_transient.
 * - Comparisons:
 *   - eq(): Checks if two Bytes<32> values are equal.
 *   - lt(): Checks if one Bytes<32> value is less than another.
 *   - lte(): Checks if one Bytes<32> value is less than or equal to another.
 *   - gt(): Checks if one Bytes<32> value is greater than another.
 *   - gte(): Checks if one Bytes<32> value is greater than or equal to another.
 * - Utility:
 *   - isZero(): Checks if a Bytes<32> value is zero.
 */
module Bytes32 {
  import CompactStandardLibrary;

  import Field255 prefix Field255_;

  /**
   * @title fromBytes circuit
   * @description Converts Bytes<32> to a Field using field conversion.
   *
   * @remarks
   * This function performs a type conversion from bytes to field elements.
   * The conversion uses the degrade_to_transient built-in function.
   * Special handling is included for zero bytes to avoid field size overflow.
   *
   * @param {Bytes<32>} a - The bytes value to convert to a field element.
   *
   * @returns {Field} - The field representation of the bytes.
   *
   * @throws {Error} "Bytes32: toField() - inputs exceed the field size" - When the input bytes represent a value that exceeds the field size after conversion.
   */
  export circuit fromBytes(a: Bytes<32>): Field {
    // Inline the isZero logic to avoid invalid context error
    if (isZero(a)) {
      return 0 as Field;
    }
    const aField = degradeToTransient(a);
    assert(aField != (0 as Field), "Bytes32: toField() - inputs exceed the field size");
    return aField;
  }

  /**
   * @title toBytes circuit
   * @description Converts a Field to Bytes<32> using upgrade_from_transient.
   *
   * @remarks
   * This function performs a type conversion from field elements to bytes.
   * The conversion uses the upgrade_from_transient built-in function.
   * The output is always 32 bytes regardless of the input field size.
   *
   * @param {Field} a - The field value to convert to bytes.
   *
   * @returns {Bytes<32>} - The bytes representation of the field (32 bytes).
   */
  export circuit toBytes(a: Field): Bytes<32> {
    return upgradeFromTransient(a);
  }
}

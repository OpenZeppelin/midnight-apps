// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/test/Field255.mock.compact)

pragma language_version >= 0.19.0;

import CompactStandardLibrary;

import { DivResultField } from "../../../Field255";
import "../../../Field255" prefix Field255_;
import { U256 } from "../../../types/TU256";

export { DivResultField, U256 };

// Helper for test suite: toggling this variable activates circuit metadata reporting.
// Only increases circuit size by 3 rows per exposed circuit.
ledger _exposeCircuitInfo: Boolean;

export circuit toBytes(value: Field): Bytes<32> {
  _exposeCircuitInfo = true;
  return disclose(Field255_toBytes(value));
}

export circuit toU256(value: Field): U256 {
  _exposeCircuitInfo = true;
  return disclose(Field255_toU256(value));
}

export circuit eq(a: Field, b: Field): Boolean {
  _exposeCircuitInfo = true;
  return Field255_eq(a, b);
}

export circuit lt(a: Field, b: Field): Boolean {
  _exposeCircuitInfo = true;
  return disclose(Field255_lt(a, b));
}

export circuit lte(a: Field, b: Field): Boolean {
  _exposeCircuitInfo = true;
  return disclose(Field255_lte(a, b));
}

export circuit gt(a: Field, b: Field): Boolean {
  _exposeCircuitInfo = true;
  return disclose(Field255_gt(a, b));
}

export circuit gte(a: Field, b: Field): Boolean {
  _exposeCircuitInfo = true;
  return disclose(Field255_gte(a, b));
}

export circuit isZero(a: Field): Boolean {
  _exposeCircuitInfo = true;
  return Field255_isZero(a);
}

export circuit add(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_add(a, b));
}

export circuit unsafeAdd(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_unsafeAdd(a, b));
}

export circuit sub(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_sub(a, b));
}

export circuit unsafeSub(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_unsafeSub(a, b));
}

export circuit mul(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_mul(a, b));
}

export circuit unsafeMul(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_unsafeMul(a, b));
}

export circuit div(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_div(a, b));
}

export circuit rem(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_rem(a, b));
}

export circuit divRem(a: Field, b: Field): DivResultField {
  _exposeCircuitInfo = true;
  return disclose(Field255_divRem(a, b));
}

export circuit sqrt(radicand: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_sqrt(radicand));
}

export circuit min(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_min(a, b));
}

export circuit max(a: Field, b: Field): Field {
  _exposeCircuitInfo = true;
  return disclose(Field255_max(a, b));
}


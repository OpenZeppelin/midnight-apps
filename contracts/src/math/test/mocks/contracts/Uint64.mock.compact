// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/test/Uint64.mock.compact)

pragma language_version >= 0.20.0;

import CompactStandardLibrary;

import { DivResultU64 } from "../../../Uint64";

import "../../../Uint64" prefix Uint64_;

export { DivResultU64 };

// Helper for test suite: hardcoded to true in every circuit to enable circuit metadata reporting;
// only increases circuit size by 3 rows per exposed circuit.
ledger toImpure: Boolean;

////////////////////////////////////////////////////////////////
// Constants
////////////////////////////////////////////////////////////////

export circuit MAX_UINT8(): Uint<8> {
  toImpure = true;
  return Uint64_MAX_UINT8();
}

export circuit MAX_UINT16(): Uint<16> {
  toImpure = true;
  return Uint64_MAX_UINT16();
}

export circuit MAX_UINT32(): Uint<32> {
  toImpure = true;
  return Uint64_MAX_UINT32();
}

export circuit MAX_UINT64(): Uint<64> {
  toImpure = true;
  return Uint64_MAX_UINT64();
}

////////////////////////////////////////////////////////////////
// Conversions
////////////////////////////////////////////////////////////////

export circuit toBytes(value: Uint<64>): Bytes<8> {
  toImpure = true;
  return disclose(Uint64_toBytes(value));
}

export circuit toUnpackedBytes(value: Uint<64>): Vector<8, Uint<8>> {
  toImpure = true;
  return disclose(Uint64_toUnpackedBytes(value));
}

////////////////////////////////////////////////////////////////
// Arithmetic
////////////////////////////////////////////////////////////////

export circuit add(a: Uint<64>, b: Uint<64>): Uint<128> {
  toImpure = true;
  return Uint64_add(a, b);
}

export circuit addChecked(a: Uint<64>, b: Uint<64>): Uint<64> {
  toImpure = true;
  return Uint64_addChecked(a, b);
}

export circuit sub(a: Uint<64>, b: Uint<64>): Uint<64> {
  toImpure = true;
  return Uint64_sub(a, b);
}

export circuit mul(a: Uint<64>, b: Uint<64>): Uint<128> {
  toImpure = true;
  return Uint64_mul(a, b);
}

export circuit mulChecked(a: Uint<64>, b: Uint<64>): Uint<64> {
  toImpure = true;
  return Uint64_mulChecked(a, b);
}

////////////////////////////////////////////////////////////////
// Division
////////////////////////////////////////////////////////////////

export circuit div(a: Uint<64>, b: Uint<64>): Uint<64> {
  toImpure = true;
  return disclose(Uint64_div(a, b));
}

export circuit rem(a: Uint<64>, b: Uint<64>): Uint<64> {
  toImpure = true;
  return disclose(Uint64_rem(a, b));
}

export circuit divRem(a: Uint<64>, b: Uint<64>): DivResultU64 {
  toImpure = true;
  return disclose(Uint64_divRem(a, b));
}

////////////////////////////////////////////////////////////////
// Square Root
////////////////////////////////////////////////////////////////

export circuit sqrt(radical: Uint<64>): Uint<32> {
  toImpure = true;
  return disclose(Uint64_sqrt(radical));
}

////////////////////////////////////////////////////////////////
// Utilities
////////////////////////////////////////////////////////////////

export circuit isMultiple(value: Uint<64>, b: Uint<64>): Boolean {
  toImpure = true;
  return disclose(Uint64_isMultiple(value, b));
}

export circuit min(a: Uint<64>, b: Uint<64>): Uint<64> {
  toImpure = true;
  return Uint64_min(a, b);
}

export circuit max(a: Uint<64>, b: Uint<64>): Uint<64> {
  toImpure = true;
  return Uint64_max(a, b);
}

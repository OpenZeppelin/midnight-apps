// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Vector32.compact)

pragma language_version >= 0.20.0;

/**
 * @title Vector32 module
 * @description A utility module providing conversions from Vector<32, Uint<8>> to U256
 * using little-endian (LE) byte ordering.
 *
 * @remarks
 * Byte ordering convention (little-endian):
 * - Element 0 is the least significant byte, element 31 is the most significant.
 * - This mirrors the pattern of Vector8 ↔ Uint<64> conversions.
 *
 * Supported circuits:
 * - toU256(vec): Converts Vector<32, Uint<8>> to U256
 * - toBytes(vec): Converts Vector<32, Uint<8>> to Bytes<32>
 *
 * For the reverse conversion (U256 to Vector), see Uint256.toVector.
 */
module Vector32 {
  import { U128 } from "./types/TU128";
  import { U256 } from "./types/TU256";
  import { toUint64 } from "./Bytes8" prefix Bytes8_;

  /**
   * @title limbToUint64 circuit
   * @description Converts an 8-byte limb of the vector to a Uint<64> using pure arithmetic.
   *
   * @remarks
   * This circuit converts an 8-byte limb to a 64-bit unsigned integer using pure arithmetic.
   *
   * @param {Vector<32, Uint<8>>} vec - The vector of 32 bytes.
   * @param {Uint<2>} limbIndex - The limb index (0-3).
   *
   * @returns {Uint<64>} - The 64-bit unsigned integer.
   */
  pure circuit limbToUint64(vec: Vector<32, Uint<8>>, limbIndex: Uint<2>): Uint<64> {
    const offset = limbIndex * 8;
    return Bytes8_toUint64(
      vec[offset], vec[offset + 1], vec[offset + 2], vec[offset + 3],
      vec[offset + 4], vec[offset + 5], vec[offset + 6], vec[offset + 7]
    );
  }

  /**
   * @title toU256 circuit
   * @description Converts a Vector<32, Uint<8>> to a U256 using pure arithmetic.
   *
   * @remarks
   * This circuit converts a 32-element vector of bytes to a 256-bit unsigned integer
   * using little-endian byte ordering. The vector is split into four 8-byte chunks,
   * each packed into a Uint<64> limb (same formula as `Vector8_toUint64`). The packing
   * is inlined so this module has no prefix imports and can be used as a single-module
   * dependency (e.g. from mock contracts).
   *
   * Limb packing order (little-endian):
   * - v0-v7   → low.low   (least significant)
   * - v8-v15  → low.high
   * - v16-v23 → high.low
   * - v24-v31 → high.high (most significant)
   *
   * @circuitInfo k=10, rows=739
   *
   * @param {Vector<32, Uint<8>>} vec - The vector of 32 bytes to convert.
   *
   * @returns {U256} - The 256-bit unsigned integer.
   */
  export pure circuit toU256(vec: Vector<32, Uint<8>>): U256 {
    return U256 {
      low: U128 {
        low: limbToUint64(vec, 0),
        high: limbToUint64(vec, 1)
      },
      high: U128 {
        low: limbToUint64(vec, 2),
        high: limbToUint64(vec, 3)
      }
    };
  }

  /**
   * @title toBytes circuit
   * @description Converts a Vector<32, Uint<8>> to a Bytes<32>.
   *
   * @remarks
   * This circuit converts a 32-element vector of bytes to a 32-byte array
   * by spreading the vector elements into a Bytes literal.
   *
   * @circuitInfo k=14, rows=10231
   *
   * @param {Vector<32, Uint<8>>} vec - The vector of 32 bytes to convert.
   *
   * @returns {Bytes<32>} - The 32-byte array.
   */
  export pure circuit toBytes(vec: Vector<32, Uint<8>>): Bytes<32> {
    return Bytes[...vec];
  }
}

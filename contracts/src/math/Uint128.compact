// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Uint128.compact)

pragma language_version >= 0.21.0;

/**
 * @title Uint128
 * @dev Mathematical operations for 128-bit unsigned integers using the U128 struct,
 * which represents numbers as high * 2⁶⁴ + low, where high and low are 64-bit unsigned
 * integers (Uint<64>) in [0, 2⁶⁴ - 1]. Operations are provided in dual forms: one for
 * Uint<128> inputs with conversions to/from U128, and another for direct U128 inputs.
 *
 * Supported Operations:
 * - Conversions: toU128(), toUint128()
 * - Comparisons: eq(), lt(), lte(), gt(), gte() (and U128 variants)
 * - Arithmetic: add(), sub(), mul(), addChecked(), mulChecked() (and U128 variants)
 * - Division: div(), rem(), divRem() (and U128 variants)
 * - Square Root: sqrt(), sqrtU128()
 * - Utility: min(), max(), isMultiple() (and U128 variants)
 */
module Uint128 {
  import { MAX_UINT8, MAX_UINT16, MAX_UINT32, MAX_UINT64 } from Uint64;

  // U128 and U256 types are imported from dedicated type modules to avoid
  // cyclic dependencies between Uint128 and Uint256. See TU128/TU256 documentation.
  import "./types/TU128";
  import "./types/TU256";

  /**
   * @description A struct representing the result of a division operation on U128 values.
   */
  export struct DivResultU128 {
    /**
     * @description The quotient result of the division operation
     */
    quotient: U128,
    /**
     * @description The remainder result of the division operation
     */
    remainder: U128
  }

  /**
   * @description Computes division of two U128 values locally (off-chain).
   *
   * @param a The number to divide.
   * @param b The number to divide by.
   * @returns DivResultU128 The quotient and remainder of the division as U128 values.
   */
  export witness wit_divU128(a: U128, b: U128): DivResultU128;

  /**
   * @description Computes division of two Uint<128> values locally (off-chain).
   *
   * @param a The number to divide.
   * @param b The number to divide by.
   * @returns DivResultU128 The quotient and remainder of the division as U128 values.
   */
  export witness wit_divUint128(a: Uint<128>, b: Uint<128>): DivResultU128;

  /**
   * @description Computes the square root of a U128 value locally (off-chain).
   *
   * @param radicand The U128 value to compute the square root of.
   * @returns Uint<64> The square root of radicand.
   */
  export witness wit_sqrtU128(radicand: U128): Uint<64>;

  /**
   * @title Modulus U128 circuit
   * @description A pure circuit that returns the modulus value of U128 (2⁶⁴).
   *
   * @circuitInfo k=5, rows=25
   *
   * @returns {Uint<65>} The value 2⁶⁴ (18446744073709551616).
   */
  export pure circuit MODULUS(): Uint<65> {
    // pow() is not supported yet, so we hardcode this value.
    return 18446744073709551616; // 2⁶⁴
  }

  /**
   * @title Zero U128 circuit
   * @description A pure circuit that returns a zero U128 struct.
   *
   * @circuitInfo k=6, rows=46
   *
   * @returns {U128} A U128 struct with low and high fields set to 0.
   */
  export pure circuit ZERO_U128(): U128 {
    return U128 { low: 0, high: 0 };
  }

  /**
   * @title MAX_U128 circuit
   * @description Returns the maximum value for a U128 struct, where both low and high
   * fields are set to the maximum 64-bit value (2⁶⁴ - 1).
   *
   * @circuitInfo k=6, rows=46
   *
   * @returns {U128} A U128 struct representing 2¹²⁸ - 1.
   */
  export pure circuit MAX_U128(): U128 {
    return U128 { low: MAX_UINT64(), high: MAX_UINT64() };
  }

  /**
   * @title MAX_UINT128 circuit
   * @description Returns the maximum value for a 128-bit unsigned integer (2¹²⁸ - 1).
   *
   * @circuitInfo k=5, rows=25
   *
   * @returns {Uint<128>} The value 340,282,366,920,938,463,463,374,607,431,768,211,455
   * (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF).
   */
  export pure circuit MAX_UINT128(): Uint<128> {
    return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
  }

  /**
   * @title To U128 circuit
   * @description Converts Uint<128> to U128 struct by splitting into 64-bit parts.
   *
   * @remarks
   * Splits value ∈ [0, 2¹²⁸ - 1] into value = high · 2⁶⁴ + low, where low, high ∈ [0, 2⁶⁴ - 1].
   *
   * Mathematical Steps:
   * 1. Compute low = value mod 2⁶⁴, high = ⌊value / 2⁶⁴⌋
   * 2. Verify high · 2⁶⁴ + low = value
   * 3. Return U128 {low, high}
   *
   * @circuitInfo k=9, rows=441
   *
   * @throws {Error} "MathU128: conversion invalid" if verification fails.
   *
   * @param {Uint<128>} value - The Uint<128> value to convert.
   *
   * @returns {U128} A U128 struct representing the 128-bit value.
   */
  export circuit toU128(value: Uint<128>): U128 {
    const result = wit_divUint128(value, MODULUS());
    const high = result.quotient.low;
    const low = result.remainder.low;

    // Verify that value = high * 2⁶⁴ + low
    const highShifted = (high as Uint<128>) * MODULUS(); // high * 2⁶⁴
    const reconstructed = highShifted + (low as Uint<128>); // high * 2⁶⁴ + low

    // Verify reconstruction matches value
    assert(reconstructed == value, "MathU128: conversion invalid");

    return U128 { low: low, high: high };
  }

  /**
   * @title From U128 circuit
   * @description Converts U128 struct to Uint<128>.
   *
   * @remarks
   * Reconstructs N = n_h · 2⁶⁴ + n_l, where n_l, n_h ∈ [0, 2⁶⁴ - 1].
   *
   * @circuitInfo k=9, rows=306
   *
   * @param {U128} value - The U128 value to convert.
   *
   * @returns {Uint<128>} A Uint<128> value representing the 128-bit value.
   */
  export pure circuit toUint128(value: U128): Uint<128> {
    const highShifted = (value.high as Uint<128>) * MODULUS();
    const result = highShifted + (value.low as Uint<128>);
    return result as Uint<128>;
  }

  /**
   * @title Is Zero circuit
   * @description Checks if a Uint<128> value equals zero.
   *
   * @circuitInfo k=8, rows=177
   *
   * @param {Uint<128>} a - The Uint<128> value to check.
   *
   * @returns {Boolean} True if a equals zero, false otherwise.
   */
  export pure circuit isZero(a: Uint<128>): Boolean {
    return a == 0;
  }

  /**
   * @title Is Zero U128 circuit
   * @description Checks if a U128 value equals zero.
   *
   * @circuitInfo k=8, rows=183
   *
   * @param {U128} a - The U128 value to check.
   *
   * @returns {Boolean} True if a equals zero (a.low = a.high = 0), false otherwise.
   */
  export pure circuit isZeroU128(a: U128): Boolean {
    return a.low == 0 && a.high == 0;
  }

  /**
   * @title Equality circuit
   * @description Compares two Uint<128> values for equality.
   *
   * @circuitInfo k=9, rows=306
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is equal than b, false otherwise.
   */
  export pure circuit eq(a: Uint<128>, b: Uint<128>): Boolean {
    return a == b;
  }

  /**
   * @title Equality U128 circuit
   * @description Compares two U128 values for equality.
   *
   * @circuitInfo k=9, rows=333
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is equal b, false otherwise.
   */
  export pure circuit eqU128(a: U128, b: U128): Boolean {
    return a.low == b.low && a.high == b.high;
  }

  /**
   * @title Less Than circuit
   * @description Checks if one Uint<128> value is less than another.
   *
   * @circuitInfo k=9, rows=357
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is less than b, false otherwise.
   */
  export pure circuit lt(a: Uint<128>, b: Uint<128>): Boolean {
    return a < b;
  }

  /**
   * @title Less Than or Equal circuit
   * @description Checks if one Uint<128> value is less than or equal to another.
   *
   * @circuitInfo k=9, rows=360
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean}
   */
  export pure circuit lte(a: Uint<128>, b: Uint<128>): Boolean {
    return a <= b;
  }

  /**
   * @title Less Than U128 circuit
   * @description Checks if one U128 value is less than another.
   *
   * @param a The first U128 value.
   * @param b The second U128 value.
   * @returns Boolean True if a is less than b, false otherwise.
   */
  export pure circuit ltU128(a: U128, b: U128): Boolean {
    return a.high < b.high || (a.high == b.high && a.low < b.low);
  }

  /**
   * @title Less Than or Equal U128 circuit
   * @description Checks if one U128 value is less than or equal to another.
   *
   * @circuitInfo k=9, rows=400
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is less than or equal to b, false otherwise.
   */
  export pure circuit lteU128(a: U128, b: U128): Boolean {
    return ltU128(a, b) || eqU128(a, b);
  }

  /**
   * @title Greater Than circuit
   * @description Checks if one Uint<128> value is greater than another.
   *
   * @circuitInfo k=9, rows=357
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is greater than b, false otherwise.
   */
  export pure circuit gt(a: Uint<128>, b: Uint<128>): Boolean {
    return a > b;
  }

  /**
   * @title Greater Than or Equal circuit
   * @description Checks if one Uint<128> value is greater than or equal to another.
   *
   * @circuitInfo k=9, rows=360
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Boolean} True if a is greater than or equal to b, false otherwise.
   */
  export pure circuit gte(a: Uint<128>, b: Uint<128>): Boolean {
    return a >= b;
  }

  /**
   * @title Greater Than U128 circuit
   * @description Checks if one U128 value is greater than another.
   *
   * @circuitInfo k=9, rows=392
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is greater than b, false otherwise.
   */
  export pure circuit gtU128(a: U128, b: U128): Boolean {
    return a.high > b.high || (a.high == b.high && a.low > b.low);
  }

  /**
   * @title Greater Than or Equal U128 circuit
   * @description Checks if one U128 value is greater than or equal to another.
   *
   * @circuitInfo k=9, rows=400
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {Boolean} True if a is greater than or equal to b, false otherwise.
   */
  export pure circuit gteU128(a: U128, b: U128): Boolean {
    return gtU128(a, b) || eqU128(a, b);
  }

  /**
   * @title Add circuit
   * @description Adds two U128 values, returning a U256.
   *
   * @remarks
   * Computes S = a + b for a, b ∈ [0, 2¹²⁸ - 1], returning S ∈ [0, 2¹²⁹ - 2] as U256.
   * Let a = a_h · 2⁶⁴ + a_l and b = b_h · 2⁶⁴ + b_l, where a_l, a_h, b_l, b_h ∈ [0, 2⁶⁴ - 1].
   *
   * Mathematical Steps:
   * 1. Lower 64-bit Addition:
   *    s_l = a_l + b_l ∈ [0, 2⁶⁵ - 2]
   *    result_l = s_l mod 2⁶⁴, carry_0 = ⌊s_l / 2⁶⁴⌋ ∈ {0, 1}
   *
   * 2. Upper 64-bit Addition:
   *    s_h = a_h + b_h + carry_0 ∈ [0, 2⁶⁵ - 1]
   *    result_h = s_h mod 2⁶⁴, carry_1 = ⌊s_h / 2⁶⁴⌋ ∈ {0, 1}
   *
   * 3. Result Assembly:
   *    S_low = result_h · 2⁶⁴ + result_l (bits 0-127)
   *    S_high = carry_1 (bit 128)
   *    Return U256 {low: S_low, high: {carry_1, 0}}
   *
   * @circuitInfo k=10, rows=902
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U256} The sum of a and b.
   */
  circuit _add(a: U128, b: U128): U256 {
    const lowSumFull = a.low + b.low;
    const lowSumFullU128 = toU128(lowSumFull);

    const carry = lowSumFullU128.high;
    const highSumIntermediate = a.high + b.high;
    const highSumFull = highSumIntermediate + carry;
    const highSumFullU128 = toU128(highSumFull);
    const carryHigh = highSumFullU128.high;

    return U256 { low: U128 { low: lowSumFullU128.low, high: highSumFullU128.low },
                  high: U128 { low: carryHigh, high: 0 } };
  }

  /**
   * @title Add circuit
   * @description Adds two Uint<128> values.
   *
   * @circuitInfo k=11, rows=1410
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {U256} The sum of a and b.
   */
  export circuit add(a: Uint<128>, b: Uint<128>): U256 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _add(aU128, bU128);
  }

  /**
   * @title Add U128 circuit
   * @description Adds two U128 values.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result is returned as `U256` to handle potential overflow.
   *
   * @circuitInfo k=10, rows=992
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U256} The sum of a and b.
   */
  export circuit addU128(a: U128, b: U128): U256 {
    return _add(a, b);
  }

  /**
   * @title Add Checked circuit
   * @description Adds two Uint<128> values with overflow checking.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=11, rows=1500
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @throws {Error} "MathU128: addition overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The sum of a and b.
   */
  export circuit addChecked(a: Uint<128>, b: Uint<128>): Uint<128> {
    const sum = add(a, b); // U256 { low: U128, high: U128 }

    // If high != 0 then a+b exceeded 2¹²⁸-1
    assert(isZeroU128(sum.high), "MathU128: addition overflow");

    return toUint128(sum.low);
  }

  /**
   * @title Add Checked U128 circuit
   * @description Adds two U128 values with overflow checking.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=9, rows=364
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: addition overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The sum of a and b.
   */
  export circuit addCheckedU128(a: U128, b: U128): Uint<128> {
    const sum = _add(a, b); // U256 { low: U128, high: U128 }

    // If high != 0 then a+b exceeded 2¹²⁸-1
    assert(isZeroU128(sum.high), "MathU128: addition overflow");

    return toUint128(sum.low);
  }

  /**
   * @title Subtract circuit
   * @description Subtracts one Uint<128> value from another.
   *
   * @remarks
   * Requirements:
   * - `a` must be greater than or equal to `b` to prevent underflow.
   * - Both inputs must be valid `Uint<128>` values.
   *
   * @circuitInfo k=10, rows=579
   *
   * @param {Uint<128>} a - The Uint<128> value to subtract from (minuend).
   * @param {Uint<128>} b - The Uint<128> value to subtract (subtrahend).
   *
   * @returns {Uint<128>} The difference between a and b.
   *
   * @throws {Error} "MathU128: subtraction underflow" If a < b.
   */
  export pure circuit sub(a: Uint<128>, b: Uint<128>): Uint<128> {
    assert(a >= b, "MathU128: subtraction underflow");
    return a - b;
  }

  /**
   * @title Subtract U128 circuit
   * @description Subtracts one U128 from another with borrow handling.
   *
   * @remarks
   * Computes D = a - b for a, b ∈ [0, 2¹²⁸ - 1] where a ≥ b.
   * Let a = a_h · 2⁶⁴ + a_l and b = b_h · 2⁶⁴ + b_l.
   *
   * Mathematical Steps:
   * 1. Underflow Check: Assert a ≥ b
   * 2. Borrow: borrow = 1 if a_l < b_l, else 0
   * 3. High Part: high_diff = a_h - (b_h + borrow)
   * 4. Low Part: low_diff = a_l - b_l (if no borrow), else a_l + 2⁶⁴ - b_l
   * 5. Return U128 {low: low_diff, high: high_diff}
   *
   * @circuitInfo k=10, rows=579
   *
   * @throws {Error} "MathU128: subtraction underflow" if a < b.
   *
   * @param {U128} a - The U128 value to subtract from.
   * @param {U128} b - The U128 value to subtract.
   *
   * @returns {U128} The difference between a and b.
   */
  export pure circuit subU128(a: U128, b: U128): U128 {
    // General case
    assert(gtU128(a, b) || eqU128(a, b), "MathU128: subtraction underflow");

    const borrow = a.low < b.low ? 1 as Uint<64> : 0 as Uint<64>;
    const highWithBorrow = b.high + borrow;
    const highDiff = a.high - highWithBorrow;

    if (borrow == 0) {
      const lowDiff = a.low - b.low;
      return U128 { low: lowDiff, high: highDiff };
    } else {
      const lowDiff = a.low + MODULUS() - b.low;
      return U128 { low: lowDiff as Uint<64>, high: highDiff };
    }
  }

  /**
   * @title Multiply circuit
   * @description Multiplies two U128 values, returning the full 256-bit result.
   *
   * @remarks
   * Computes P = a · b for a, b ∈ [0, 2¹²⁸ - 1], returning P as U256 {low: U128, high: U128}.
   * Uses schoolbook multiplication with partial products and carry propagation.
   * For a = a_h · 2⁶⁴ + a_l and b = b_h · 2⁶⁴ + b_l:
   * P = a · b = hh · 2¹²⁸ + (hl + lh) · 2⁶⁴ + ll, where ll = a_l·b_l, hl = a_h·b_l,
   * lh = a_l·b_h, hh = a_h·b_h.
   *
   * Mathematical Steps:
   * 1. Partial Products:
   *    Compute ll, hl, lh, hh where each ≤ (2⁶⁴ - 1)² = 2¹²⁸ - 2⁶⁵ + 1 < 2¹²⁸.
   *    - ll = a_l · b_l (bits [0, 127])
   *    - hl = a_h · b_l (bits [64, 191])
   *    - lh = a_l · b_h (bits [64, 191])
   *    - hh = a_h · b_h (bits [128, 255])
   *
   * 2. Cross Terms Addition:
   *    S = hl + lh ≤ 2(2¹²⁸ - 2⁶⁵ + 1) < 2¹²⁹ (fits in 129 bits)
   *    - Add low parts: (hl mod 2⁶⁴) + (lh mod 2⁶⁴) → sum s_0, carry c_0
   *    - Add high parts: ⌊hl/2⁶⁴⌋ + ⌊lh/2⁶⁴⌋ + c_0 → sum s_1, carry c_1
   *
   * 3. Lower Half [0-127]:
   *    - Bits [0, 63]: ll mod 2⁶⁴
   *    - Bits [64, 127]: (⌊ll/2⁶⁴⌋ + s_0) mod 2⁶⁴, with carry c_2 to bit 128
   *
   * 4. Upper Half [128-255]:
   *    - Bits [128, 191]: (hh mod 2⁶⁴) + s_1 + c_2 → sum, carry c_3
   *    - Bits [192, 255]: ⌊hh/2⁶⁴⌋ + c_1 + c_3
   *
   * 5. Overflow Check:
   *    Max product = (2¹²⁸ - 1)² = 2²⁵⁶ - 2¹²⁹ + 1 < 2²⁵⁶
   *    Assert final high carry = 0
   *
   * @circuitInfo k=12, rows=2769
    *
    * @param {U128} a - The first U128 value to multiply.
    * @param {U128} b - The second U128 value to multiply.
    *
    * @throws {Error} "MathU128: multiplication overflow" if the intermediate computation
    *                 suggests result would exceed 256 bits.
    *
    * @returns {U256} The product a * b as a U256 struct.
    */
  circuit _mul(a: U128, b: U128): U256 {
    // Compute partial products (each is Uint<128>)
    const ll = a.low * b.low; // Bits 0-127
    const hl = a.high * b.low; // Bits 64-191
    const lh = a.low * b.high; // Bits 64-191
    const hh = a.high * b.high; // Bits 128-255

    // Convert partial products to U128 structs
    const llU128 = toU128(ll);
    const hlU128 = toU128(hl);
    const lhU128 = toU128(lh);
    const hhU128 = toU128(hh);

    // Add cross terms (hl + lh) with carry propagation
    // Add low part of hl and lh
    const crossSum = hlU128.low + lhU128.low;
    const crossSumU128 = toU128(crossSum); // { low: sum, high: carry }
    const carry0 = crossSumU128.high;

    // Add high parts of cross terms + carry0 (bits 128-191)
    const crossHigh = hlU128.high + lhU128.high + carry0;
    const crossHighU128 = toU128(crossHigh); // { low: sum, high: carry }
    const carry1 = crossHighU128.high; // carry for bits 128-191 (0 or 1)

    // Build result low 128 bit (bits 0-127)
    // Result = ll + (crossSum << 64)
    const resultLowLow = llU128.low;

    // Bits 64-127: ll.high + crossLow.low (with potential carry)
    const midSum = llU128.high + crossSumU128.low;
    const midSumU128 = toU128(midSum); // { low: sum, high: carry }
    const carry2 = midSumU128.high; // carry for bits 64-127 (0 or 1)

    const resultLow = U128 { low: resultLowLow, high: midSumU128.low };

    // Build result high 128 bits (bits 128-255)
    // Result = hh + (crossSum >> 64) + carries
    // Bits 128-191: hh.low + crossHigh.low + carry2
    const highLowSum = hhU128.low + crossHighU128.low + carry2;
    const highLowSumU128 = toU128(highLowSum); // { low: sum, high: carry }
    const carry3 = highLowSumU128.high; // carry for bits 128-191 (0 or 1)

    // Bits 192-255: hh.high + carry1 + carry3
    const highHighSum = hhU128.high + carry1 + carry3;
    const highHighSumU128 = toU128(highHighSum); // { low: sum, high: carry }

    // High part should be 0 for valid 128-bit multiplication
    assert(highHighSumU128.high == 0, "MathU128: multiplication overflow");

    const resultHigh = U128 { low: highLowSumU128.low, high: highHighSumU128.low };

    return U256 { low: resultLow, high: resultHigh };
  }

  /**
   * @title Multiply circuit
   * @description Multiplies two Uint<128> values.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result is returned as `U256` to handle full product.
   *
   * @circuitInfo k=12, rows=3277
   *
   * @param {Uint<128>} a - The first Uint<128> value to multiply.
   * @param {Uint<128>} b - The second Uint<128> value to multiply.
   *
   * @returns {U256} The full product of a and b.
   */
  export circuit mul(a: Uint<128>, b: Uint<128>): U256 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _mul(aU128, bU128);
  }

  /**
   * @title Multiply U128 circuit
   * @description Multiplies two U128 values.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result is returned as `U256` to handle full product.
   *
   * @circuitInfo k=12, rows=2864
   *
   * @param {U128} a - The first U128 value to multiply.
   * @param {U128} b - The second U128 value to multiply.
   *
   * @returns {U256} The full product of a and b.
   */
  export circuit mulU128(a: U128, b: U128): U256 {
    return _mul(a, b);
  }

  /**
   * @title Multiply Checked U128 circuit
   * @description Internal implementation of checked multiplication for U128 values.
   *
   * @circuitInfo k=12, rows=2864
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: multiplication overflow" If the result would overflow 128 bits.
   *
   * @returns {U128} The product of a and b.
   */
  circuit _mulChecked(a: U128, b: U128): U128 {
    const result = _mul(a, b);

    assert(eqU128(result.high, ZERO_U128()), "MathU128: multiplication overflow");

    return result.low;
  }

  /**
   * @title Multiply Checked circuit
   * @description Multiplies two Uint<128> values with overflow checking.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `Uint<128>` values.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=12, rows=3372
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @throws {Error} "MathU128: multiplication overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The product of a and b.
   */
  export circuit mulChecked(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    const result = _mulChecked(aU128, bU128);
    return toUint128(result);
  }

  /**
   * @title Multiply Checked U128 circuit
   * @description Multiplies two U128 values with overflow checking.
   *
   * @remarks
   * Requirements:
   * - `a` and `b` must be valid `U128` structs.
   * - Result must not overflow 128 bits.
   *
   * @circuitInfo k=12, rows=2864
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @throws {Error} "MathU128: multiplication overflow" if the result would overflow 128 bits.
   *
   * @returns {Uint<128>} The product of a and b.
   */
  export circuit mulCheckedU128(a: U128, b: U128): Uint<128> {
    const result = _mulChecked(a, b);
    return toUint128(result);
  }

  /**
   * @title Division U128 circuit (Optimized)
   * @description Divides a U128 value by another, returning quotient and remainder.
   *
   * @remarks
   * Computes quotient q and remainder r satisfying a = q·b + r, where 0 ≤ r < b.
   * For a, b ∈ [0, 2¹²⁸ - 1] with b > 0, there exist unique q, r ∈ [0, 2¹²⁸ - 1] such that
   * a = q·b + r and 0 ≤ r < b. Since q·b = a - r < a < 2¹²⁸, the product q·b fits in 128 bits
   * (productU256.high = {0, 0}).
   *
   * Mathematical Steps:
   * 1. Zero Divisor Check: Verify b ≠ 0
   * 2. Witness Generation: Compute (q, r) = divmod(a, b) off-chain
   * 3. Remainder Bounds: Assert r < b
   * 4. Correctness Verification:
   *    a) Compute P = q·b (returns U256)
   *    b) Assert P.high = {0, 0} (P fits in 128 bits)
   *    c) Assert a - P.low = r (using subU128 for efficiency)
   * 5. Return DivResultU128 {quotient: q, remainder: r}
   *
   * @circuitInfo k=12, rows=3333
   *
   * @param {U128} a - The U128 value to divide (dividend).
   * @param {U128} b - The U128 value to divide by (divisor).
   *
   * @throws {Error} "MathU128: division by zero" If b is zero.
   * @throws {Error} "MathU128: remainder error" If remainder is not less than b.
   * @throws {Error} "MathU128: division product overflow" If q*b doesn't fit in 128 bits (indicates bad witness).
   * @throws {Error} "MathU128: division sum overflow" If (q*b) + r overflows 128 bits (indicates bad witness).
   * @throws {Error} "MathU128: division invalid" If q*b + r ≠ a.
   *
   * @returns {DivResultU128} A struct containing the quotient and remainder as U128 values.
   */
  circuit _div(a: U128, b: U128): DivResultU128 {
    // Step 1: Verify divisor is non-zero
    assert(!isZeroU128(b), "MathU128: division by zero");

    // Step 3: General case - get witness for quotient and remainder
    const result = wit_divU128(a, b);

    // Step 4: Verify remainder bounds (0 ≤ r < b)
    assert(ltU128(result.remainder, b), "MathU128: remainder error");

    // Step 5: Verify correctness (q*b + r = a)
    // Optimized: Check a - q*b = r instead of q*b + r = a

    // Compute q * b
    const productU256 = _mul(result.quotient, b);

    // Since q*b < a < 2¹²⁸, the product must fit in 128 bits
    assert(eqU128(productU256.high, ZERO_U128()), "MathU128: division product overflow");

    // Verify a - q*b = r (using subtraction instead of addition)
    // This is more efficient: subU128 returns U128, not U256
    const diff = subU128(a, productU256.low);
    assert(eqU128(diff, result.remainder), "MathU128: division invalid");

    return result;
  }

  /**
   * @title Division circuit
   * @description Divides a Uint<128> a by a Uint<128> b, returning the quotient.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=3950
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {Uint<128>} The quotient of the division.
   */
  export circuit div(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    const quotient = _div(aU128, bU128).quotient;
    return toUint128(quotient);
  }

  /**
   * @title Division U128 circuit
   * @description Divides a U128 a by a U128 b, returning the quotient.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=3333
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {U128} The quotient of the division.
   */
  export circuit divU128(a: U128, b: U128): U128 {
    return _div(a, b).quotient;
  }

  /**
   * @title Remainder circuit
   * @description Computes the remainder of dividing a Uint<128> a by a Uint<128> b.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=3950
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {Uint<128>} The remainder of the division.
   */
  export circuit rem(a: Uint<128>, b: Uint<128>): Uint<128> {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    const remainder = _div(aU128, bU128).remainder;
    return toUint128(remainder);
  }

  /**
   * @title Remainder U128 circuit
   * @description Computes the remainder of dividing a U128 a by a U128 b.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=3333
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {U128} The remainder of the division.
   */
  export circuit remU128(a: U128, b: U128): U128 {
    return _div(a, b).remainder;
  }

  /**
   * @title Division with Remainder circuit
   * @description Divides a Uint<128> a by a Uint<128> b, returning quotient and remainder.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=3863
   *
   * @param {Uint<128>} a - The Uint<128> value to divide.
   * @param {Uint<128>} b - The Uint<128> value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU128} A struct containing the quotient and remainder.
   */
  export circuit divRem(a: Uint<128>, b: Uint<128>): DivResultU128 {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _div(aU128, bU128);
  }

  /**
   * @title Division with Remainder U128 circuit
   * @description Divides a U128 a by a U128 b, returning quotient and remainder.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_div` circuit for computation.
   *
   * @circuitInfo k=12, rows=3355
   *
   * @param {U128} a - The U128 value to divide.
   * @param {U128} b - The U128 value to divide by.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   * @throws {Error} "MathU128: remainder error" if remainder is not less than b.
   * @throws {Error} "MathU128: division invalid" if quotient * b + remainder does not equal a.
   *
   * @returns {DivResultU128} A struct containing the quotient and remainder.
   */
  export circuit divRemU128(a: U128, b: U128): DivResultU128 {
    return _div(a, b);
  }

  /**
  * @title Floor Square Root U128 circuit (Optimized)
  * @description Computes the floor of the square root of a U128 value.
  *
  * @remarks
  * This circuit calculates R = ⌊√N⌋ for a 128-bit unsigned integer N, where R ∈ [0, 2⁶⁴ − 1]
  * satisfies R² ≤ N < (R + 1)².
  *
  * Mathematical Steps:
  * 1. Witness Generation:
  *    Compute R = ⌊√N⌋ off-chain using wit_sqrtU128Locally, where R ∈ [0, 2⁶⁴ - 1].
  *
  * 2. Lower Bound Verification (R² ≤ N):
  *    - Represent R as U128: R_u128 = {low: R, high: 0}
  *    - Compute S = R² using multiplication circuit
  *    - Since R ≤ 2⁶⁴ - 1, we have S < 2¹²⁸, thus S fits in U128
  *    - Verify S.high = 0 (sanity check, should always pass)
  *    - Verify S.low ≤ N (ensures R is not an overestimate)
  *
  * 3. Upper Bound Verification ((R+1)² > N):
  *    Instead of computing (R+1)² directly, use the identity:
  *    (R+1)² = R² + 2R + 1
  *
  *    This avoids a second expensive multiplication.
  *
  *    Computation:
  *    a) We already have S = R² from step 2
  *    b) Compute T = 2R (simple left shift: multiply by 2)
  *       Represent T as U128: T_u128 = {low: 2R mod 2⁶⁴, high: ⌊2R / 2⁶⁴⌋}
  *       Note: 2R ≤ 2(2⁶⁴ - 1) = 2⁶⁵ - 2 < 2⁶⁵, so T fits in 65 bits
  *    c) Compute (R+1)² = S + T + 1
  *       - First compute intermediate sum: S + T (using addU128, returns U256)
  *       - Then add 1 to the result
  *
  * 4. Overflow Handling:
  *    Since (R+1)² ≤ (2⁶⁴)² = 2¹²⁸, the result either:
  *    - Fits in 128 bits (when R < 2⁶⁴ - 1), or
  *    - Equals exactly 2¹²⁸ (when R = 2⁶⁴ - 1)
  *
  *    In the latter case, (R+1)² = 2¹²⁸ = {low: {0, 0}, high: {1, 0}} in U256.
  *    This is valid and indicates N is very close to its maximum value.
  *
  * 5. Final Verification:
  *    Let Q = (R+1)² computed as above.
  *    - If Q.high ≠ 0, then Q > 2¹²⁸ - 1 ≥ N, so verification passes
  *    - If Q.high = 0, then verify Q.low > N
  *    - This ensures (R+1)² > N, confirming R is not an underestimate
  *
  * 6. Result:
  *    Return R ∈ [0, 2⁶⁴ - 1].
  *
  * @circuitInfo k=13, rows=4414
  *
  * @param {U128} radicand - The U128 value to compute the square root of.
  *
  * @throws {Error} "MathU128: sqrt root^2 overflow" If R² overflows 128 bits (should never happen).
  * @throws {Error} "MathU128: sqrt overestimate" If R² > radicand.
  * @throws {Error} "MathU128: sqrt underestimate" If (R+1)² ≤ radicand.
  *
  * @returns {Uint<64>} The floor of the square root of radicand.
  */
  circuit _sqrt(radicand: U128): Uint<64> {
    // Step 1: Get witness for the square root
    const root = wit_sqrtU128(radicand);

    // Step 2: Verify lower bound (root² ≤ radicand)
    const rootU128 = U128 { low: root, high: 0 };
    const rootSquareU256 = _mul(rootU128, rootU128);

    // Sanity check: root² should fit in 128 bits (always true for root ≤ 2⁶⁴ - 1)
    assert(eqU128(rootSquareU256.high, ZERO_U128()), "MathU128: sqrt root^2 overflow");

    const rootSquareU128 = rootSquareU256.low;

    // Verify root² ≤ radicand
    assert(!gtU128(rootSquareU128, radicand), "MathU128: sqrt overestimate");

    // Step 3: Verify upper bound ((root+1)² > radicand)
    // Use identity: (root+1)² = root² + 2·root + 1

    // Compute 2·root using addU128 (returns U256)
    // Since root ≤ 2⁶⁴ - 1, we have 2·root ≤ 2⁶⁵ - 2 < 2¹²⁸
    const twoRootU256 = addU128(rootU128, rootU128);

    // The high part should be 0 since 2·root < 2¹²⁸
    assert(isZeroU128(twoRootU256.high), "MathU128: 2·root overflow");

    const twoRootU128 = twoRootU256.low;

    // Compute root² + 2·root (returns U256)
    const sumU256 = addU128(rootSquareU128, twoRootU128);

    // Only need to check if both additions don't overflow
    // If either overflows, (root+1)² > 2¹²⁸ - 1 ≥ radicand automatically
    if (isZeroU128(sumU256.high)) {
      // root² + 2·root fits in 128 bits, add 1 to get (root+1)²
      const one = U128 { low: 1, high: 0 };
      const nextSquareU256 = addU128(sumU256.low, one);

      // Only assert if the final result fits in 128 bits
      if (isZeroU128(nextSquareU256.high)) {
        // (root+1)² fits in 128 bits, compare directly with radicand
        assert(gtU128(nextSquareU256.low, radicand), "MathU128: sqrt underestimate");
      }
      // If adding 1 caused overflow: (root+1)² = 2¹²⁸ > radicand, verification passes
    }
    // If root² + 2·root overflowed: (root+1)² > 2¹²⁸ - 1 ≥ radicand, verification passes

    return root;
  }

  /**
   * @title Square Root circuit
   * @description Computes the square root of a Uint<128> value.
   *
   * @remarks
   * Requirements:
   * - `radicand` must be a valid `Uint<128>` value.
   * - Uses internal `_sqrt` circuit for computation.
   *
   * @circuitInfo k=13, rows=4678
   *
   * @param {Uint<128>} radicand - The Uint<128> value to compute the square root of.
   *
   * @throws {Error} "MathU128: sqrt root^2 overflow" if root² overflows.
   * @throws {Error} "MathU128: sqrt overestimate" if root² > radicand.
   * @throws {Error} "MathU128: sqrt next overflow" if (root + 1)² overflows.
   * @throws {Error} "MathU128: sqrt underestimate" if (root + 1)² <= radicand.
   *
   * @returns {Uint<64>} The floor of the square root of radicand.
   */
  export circuit sqrt(radicand: Uint<128>): Uint<64> {
    const radicandU128 = toU128(radicand);
    return _sqrt(radicandU128);
  }

  /**
   * @title Square Root U128 circuit
   * @description Computes the square root of a U128 value.
   *
   * @remarks
   * Requirements:
   * - `radicand` must be a valid `U128` struct.
   * - Uses internal `_sqrt` circuit for computation.
   *
   * @circuitInfo k=13, rows=4414
   *
   * @param {U128} radicand - The U128 value to compute the square root of.
   *
   * @throws {Error} "MathU128: sqrt root^2 overflow" if root² overflows.
   * @throws {Error} "MathU128: sqrt overestimate" if root² > radicand.
   * @throws {Error} "MathU128: sqrt next overflow" if (root + 1)² overflows.
   * @throws {Error} "MathU128: sqrt underestimate" if (root + 1)² <= radicand.
   *
   * @returns {Uint<64>} The floor of the square root of radicand.
   */
  export circuit sqrtU128(radicand: U128): Uint<64> {
    return _sqrt(radicand);
  }

  /**
   * @title Min circuit
   * @description Returns the minimum of two Uint<128> values.
   *
   * @circuitInfo k=9, rows=360
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Uint<128>} The smaller of a and b.
   */
  export pure circuit min(a: Uint<128>, b: Uint<128>): Uint<128> {
    return lte(a, b) ? a : b;
  }

  /**
   * @title Min U128 circuit
   * @description Returns the minimum of two U128 values.
   *
   * @circuitInfo k=9, rows=427
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U128} The smaller of a and b.
   */
  export pure circuit minU128(a: U128, b: U128): U128 {
    return lteU128(a, b) ? a : b;
  }

  /**
   * @title Max circuit
   * @description Returns the maximum of two Uint<128> values.
   *
   * @circuitInfo k=9, rows=360
   *
   * @param {Uint<128>} a - The first Uint<128> value.
   * @param {Uint<128>} b - The second Uint<128> value.
   *
   * @returns {Uint<128>} The larger of a and b.
   */
  export pure circuit max(a: Uint<128>, b: Uint<128>): Uint<128> {
    return gte(a, b) ? a : b;
  }

  /**
   * @title Max U128 circuit
   * @description Returns the maximum of two U128 values.
   *
   * @circuitInfo k=9, rows=427
   *
   * @param {U128} a - The first U128 value.
   * @param {U128} b - The second U128 value.
   *
   * @returns {U128} The larger of a and b.
   */
  export pure circuit maxU128(a: U128, b: U128): U128 {
    return gteU128(a, b) ? a : b;
  }

  /**
   * @title Is Multiple circuit
   * @description Checks if a U128 value is a multiple of another (a mod b = 0).
   *
   * @remarks
   * Determines if a is divisible by b with no remainder for a, b ∈ [0, 2¹²⁸ - 1].
   * Returns true if there exists an integer k such that a = k · b.
   * Let a = a_h · 2⁶⁴ + a_l and b = b_h · 2⁶⁴ + b_l.
   *
   * Mathematical Steps:
   * 1. Zero Check: Verify b ≠ 0 (b_h > 0 or b_l > 0)
   * 2. Division: Compute (quotient, remainder) where a = quotient · b + remainder
   * 3. Remainder Check: Verify remainder = 0 (remainder_h = 0 and remainder_l = 0)
   * 4. Return true if remainder = 0, false otherwise
   *
   * @circuitInfo k=12, rows=3357
   *
   * @param {U128} a - The U128 value to check.
   * @param {U128} b - The U128 value to test against.
   *
   * @returns {Boolean} True if a is a multiple of b, false otherwise.
   */
  circuit _isMultiple(a: U128, b: U128): Boolean {
    assert(b.high > 0 || b.low > 0, "MathU128: division by zero");
    const result = _div(a, b);
    return eqU128(result.remainder, ZERO_U128());
  }

  /**
   * @title Is Multiple circuit
   * @description Checks if a Uint<128> value is a multiple of another.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_isMultiple` circuit for computation.
   *
   * @circuitInfo k=12, rows=3865
   *
   * @param {Uint<128>} a - The Uint<128> value to check.
   * @param {Uint<128>} b - The Uint<128> b to test against.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   *
   * @returns {Boolean} True if value is a multiple of b, false otherwise.
   */
  export circuit isMultiple(a: Uint<128>, b: Uint<128>): Boolean {
    const aU128 = toU128(a);
    const bU128 = toU128(b);
    return _isMultiple(aU128, bU128);
  }

  /**
   * @title Is Multiple U128 circuit
   * @description Checks if a U128 value is a multiple of another.
   *
   * @remarks
   * Requirements:
   * - `b` must not be zero.
   * - Uses internal `_isMultiple` circuit for computation.
   *
   * @circuitInfo k=12, rows=3357
   *
   * @param {U128} a - The U128 value to check.
   * @param {U128} b - The U128 b to test against.
   *
   * @throws {Error} "MathU128: division by zero" if b is zero.
   *
   * @returns {Boolean} True if value is a multiple of b, false otherwise.
   */
  export circuit isMultipleU128(a: U128, b: U128): Boolean {
    return _isMultiple(a, b);
  }
}

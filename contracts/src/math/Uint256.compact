// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (math/Uint256.compact)

pragma language_version >= 0.19.0;

/**
 * @title Uint256 module
 *
 * @description A utility module providing mathematical operations for 256-bit unsigned integers
 * using the U256 struct, which represents numbers as high * 2^128 + low, where high and low are
 * 128-bit unsigned integers (Uint<128>) in [0, 2^128 - 1]. The module supports a range of
 * operations including comparisons, arithmetic, division, square root, and utility functions.
 * All operations work directly with U256 struct inputs.
 *
 * @remarks
 * Supported Mathematical Operations:
 * - Comparisons:
 *   - eq(): Checks if two 256-bit numbers are equal.
 *   - lt(): Checks if one 256-bit number is less than another.
 *   - lte(): Checks if one 256-bit number is less than or equal to another.
 *   - gt(): Checks if one 256-bit number is greater than another.
 *   - gte(): Checks if one 256-bit number is greater than or equal to another.
 */
module Uint256 {
  import { MAX_U128, eqU128, ltU128, gtU128 } from Uint128 prefix Uint128_;

  // U256 type is imported from the types module to avoid cyclic dependencies
  // between Uint128 and Uint256 modules. See TU256 module documentation.
  import "./types/TU128";
  import "./types/TU256";

  /**
   * @title ZERO_U256 circuit
   * @description Returns a U256 struct representing zero.
   *
   * @remarks
   * This circuit returns a U256 struct with all fields set to zero:
   * {low: {0, 0}, high: {0, 0}}, representing the 256-bit value 0.
   * No computations are performed, only struct construction.
   *
   * @circuitInfo k=10, rows=71
   *
   * @returns {U256} A U256 struct representing 0.
   */
  export circuit ZERO_U256(): U256 {
    return U256 { low: U128 { low: 0, high: 0 }, high: U128 { low: 0, high: 0 } };
  }

  /**
   * @title MAX_U256 circuit
   * @description Returns the maximum value for a U256 struct, where both low and high
   * fields are set to the maximum 128-bit value (2^128 - 1).
   *
   * @circuitInfo k=10, rows=72
   *
   * @returns {U256} A U256 struct representing 2^256 - 1.
   */
  export pure circuit MAX_U256(): U256 {
    return U256 { low: Uint128_MAX_U128(), high: Uint128_MAX_U128() };
  }

  /**
    * @title toBytes circuit
    * @description Converts a U256 struct to a 32-byte array using little-endian byte ordering.
    *
    * @remarks
    * This circuit converts a U256 struct to a Bytes<32> value by casting each Uint<64> limb
    * to an 8-byte array and concatenating them in little-endian order.
    *
    * Byte layout: [low.low][low.high][high.low][high.high]
    * - Bytes 0-7: least significant limb (low.low)
    * - Bytes 8-15: second limb (low.high)
    * - Bytes 16-23: third limb (high.low)
    * - Bytes 24-31: most significant limb (high.high)
    *
   * @circuitInfo k=14, rows=14786
   *
   * @param {U256} value - The U256 struct to convert.
   *
   * @returns {Bytes<32>} The corresponding 32-byte array (little-endian).
   */
  export pure circuit toBytes(value: U256): Bytes<32> {
    const b0 = value.low.low as Bytes<8>; // least significant
    const b1 = value.low.high as Bytes<8>;
    const b2 = value.high.low as Bytes<8>;
    const b3 = value.high.high as Bytes<8>; // most significant

    return Bytes[...b0, ...b1, ...b2, ...b3];
  }

  /**
   * @title eq circuit
   * @description Compares two U256 values to check if a == b.
   *
   * @remarks
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
   * to determine if A == B. It performs a field-wise comparison of the high and low parts,
   * returning true if A == B, false otherwise. No arithmetic operations are performed,
   * only comparisons and logical operations (AND).
   *
   * The circuit checks if A == B by evaluating:
   * - A.high == B.high (using Uint128_eqU128).
   * - A.low == B.low (using Uint128_eqU128).
   * The result is true only if both conditions hold.
   *
   * @circuitInfo k=10, rows=270
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a == b, false otherwise.
   */
  export circuit eq(a: U256, b: U256): Boolean {
    return Uint128_eqU128(a.high, b.high) && Uint128_eqU128(a.low, b.low);
  }

  /**
   * @title lt circuit
   * @description Compares two U256 values to check if a < b.
   *
   * @remarks
   * Theoretical Description:
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
   * b.low are in [0, 2^128 - 1], to determine if A < B. It performs a lexicographical
   * comparison by checking the high parts first, then the low parts if the high parts are
   * equal, returning true if A < B, false otherwise. No arithmetic operations are performed,
   * only comparisons and logical operations (OR, AND).
   *
   * @circuitInfo k=10, rows=335
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a < b, false otherwise.
   */
  export circuit lt(a: U256, b: U256): Boolean {
    return Uint128_ltU128(a.high, b.high) ||
           (Uint128_eqU128(a.high, b.high) && Uint128_ltU128(a.low, b.low));
  }

  /**
   * @title lte circuit
   * @description Compares two U256 values to check if a <= b.
   *
   * @remarks
   * Theoretical Description:
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
   * to determine if A <= B. It performs a lexicographical comparison by checking the high
   * parts first, then the low parts if the high parts are equal, returning true if A <= B,
   * false otherwise.
   *
   * @circuitInfo k=10, rows=350
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a <= b, false otherwise.
   */
  export circuit lte(a: U256, b: U256): Boolean {
    return lt(a, b) || eq(a, b);
  }

  /**
   * @title gt circuit
   * @description Compares two U256 values to check if a > b.
   *
   * @remarks
   * Theoretical Description:
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
   * b.low are in [0, 2^128 - 1], to determine if A > B. It performs a lexicographical
   * comparison by checking the high parts first, then the low parts if the high parts are
   * equal, returning true if A > B, false otherwise. No arithmetic operations are performed,
   * only comparisons and logical operations (OR, AND).
   *
   * @circuitInfo k=10, rows=335
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a > b, false otherwise.
   */
  export circuit gt(a: U256, b: U256): Boolean {
    return Uint128_gtU128(a.high, b.high) ||
           (Uint128_eqU128(a.high, b.high) && Uint128_gtU128(a.low, b.low));
  }

  /**
   * @title gte circuit
   * @description Compares two U256 values to check if a >= b.
   *
   * @remarks
   * Theoretical Description:
   * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
   * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
   * to determine if A >= B. It performs a lexicographical comparison by checking the high
   * parts first, then the low parts if the high parts are equal, returning true if A >= B,
   * false otherwise.
   *
   * @circuitInfo k=10, rows=350
   *
   * @param {U256} a - The first U256 value.
   * @param {U256} b - The second U256 value.
   *
   * @returns {Boolean} True if a >= b, false otherwise.
   */
  export circuit gte(a: U256, b: U256): Boolean {
    return gt(a, b) || eq(a, b);
  }
}

// SPDX-License-Identifier: MIT

pragma language_version >= 0.20.0;

/**
 *  _    _   _ _   _    _    ____  ______        ___    ____
 * | |  | | | | \ | |  / \  |  _ \/ ___\ \      / / \  |  _ \
 * | |  | | | |  \| | / _ \ | |_) \___ \\ \ /\ / / _ \ | |_) |
 * | |__| |_| | |\  |/ ___ \|  _ < ___) |\ V  V / ___ \|  __/
 * |_____\___/|_| \_/_/   \_\_| \_\____/  \_/\_/_/   \_\_|
 *
 * @title Lunarswap-V1
 * @description Main Lunarswap protocol contract implementing a decentralized exchange (DEX)
 * with automated market maker (AMM) functionality.
 *
 * @remarks
 * This is the primary entry point for the Lunarswap protocol, providing a comprehensive interface
 * for decentralized trading and liquidity provision. The protocol implements a constant product
 * AMM similar to Uniswap V2, with support for shielded transactions and privacy-preserving features.
 *
 * Key Features:
 * - Automated market making with constant product formula
 * - Liquidity provision and LP token minting
 * - Pair management and reserve tracking
 * - Protocol fee collection and distribution
 * - Shielded transaction support
 * - Price oracle functionality through cumulative price tracking
 *
 * Architecture:
 * - Factory pattern for pair creation and management
 * - Router for user-facing operations
 * - Library for mathematical utilities and token operations
 * - Fee management system for protocol sustainability
 * - LP token system for liquidity provider rewards
 *
 * Security Features:
 * - Reentrancy protection through UTXO model
 * - Slippage protection with minimum amount requirements
 * - Access control for administrative functions
 * - Overflow protection with checked arithmetic
 */

import CompactStandardLibrary;

import { U128 } from "../math/types/TU128";

import { DivResultU128 } from "../math/Uint128";

import { pool, reserves } from "./LunarswapFactory";

import { Pair } from "./LunarswapPair";

import { totalSupply, name, symbol, decimals, color } from "./LunarswapLiquidity";

import
  { initialize, addLiquidity, removeLiquidity, swapExactTokensForTokens, swapTokensForExactTokens, }
  from "./LunarswapRouter"
    prefix LunarswapRouter_;

import { getTotalSupply } from "./LunarswapLiquidity" prefix LunarswapLiquidity_;

import
  { getPair, getReserves, isIdentityExists, getAllPairLength, }
  from "./LunarswapFactory"
    prefix LunarswapFactory_;

import { sortByColor, getIdentity, } from "./LunarswapLibrary" prefix LunarswapLibrary_;

/**
 * @module Types
 * @description
 * The following types are exported for use in Lunarswap contracts and external integrations:
 *
 * - `U128`: Unsigned 128-bit integer type for high-precision arithmetic.
 * - `DivResultU128`: Result type for division operations on U128 values.
 * - `ShieldedCoinInfo`: Structure representing a coin/token with value, color, and other metadata.
 * - `QualifiedShieldedCoinInfo`: Extended coin information including nonce and Merkle tree index.
 * - `Either`: Generic sum type for representing a value of one of two possible types.
 * - `ZswapCoinPublicKey`: Public key type for shielded coin operations.
 * - `ContractAddress`: Type representing a contract address.
 * - `Pair`: Structure representing a Lunarswap trading pair and its metadata.
 */
export { U128, DivResultU128 };

export { ShieldedCoinInfo, QualifiedShieldedCoinInfo, Either, ZswapCoinPublicKey, ContractAddress };

export { Pair };

/**
 * @ledger {Map<Bytes<32>, Pair>} pool
 * @ledger {Map<Bytes<32>, QualifiedShieldedCoinInfo>} reserves
 * @ledger {Map<Bytes<32>, QualifiedShieldedCoinInfo>} totalSupply
 * @ledger {Opaque<"string">} name
 * @ledger {Opaque<"string">} symbol
 * @ledger {Uint<8>} decimals
 * @ledger {Bytes<32>} color
 */
export { pool, reserves, totalSupply, name, symbol, decimals, color };

/**
 * @title Lunarswap constructor
 * @description Initializes the Lunarswap protocol with LP token configuration and fee setter.
 *
 * @remarks
 * This constructor sets up the initial state of the Lunarswap protocol including:
 * - LP token configuration (name, symbol, decimals, nonce)
 * - Fee setter address for protocol fee management
 *
 * TODO: add deadline support
 *
 * @param {Opaque<"string">} lpTokenName     - The name of the LP token.
 * @param {Opaque<"string">} lpTokenSymbol   - The symbol of the LP token.
 * @param {Bytes<32>} lpTokenNonce           - The nonce for LP token generation.
 * @param {Uint<8>} lpTokenDecimals          - The number of decimals for LP tokens.
 * @param {ZswapCoinPublicKey} feeToSetter   - The address that can set protocol fees.
 *
 * @returns [] - No return values.
 */
constructor(lpTokenName: Opaque<"string">,
            lpTokenSymbol: Opaque<"string">,
            lpTokenNonce: Bytes<32>,
            lpTokenDecimals: Uint<8>,
            ) {
  // TODO: that would be easier to use for now for testing purposes
  const feeToSetter = ownPublicKey();
  return LunarswapRouter_initialize(
           lpTokenNonce,
           lpTokenName,
           lpTokenSymbol,
           lpTokenDecimals,
           feeToSetter
           );
}

/**
 * @title addLiquidity circuit
 * @description Adds liquidity to a trading pair and mints LP tokens.
 *
 * @remarks
 * This circuit allows users to provide liquidity to a trading pair by depositing
 * both tokens and receiving LP tokens in return. The amounts are optimized to maintain
 * the current price ratio, and any excess tokens are returned to the user.
 *
 * Requirements:
 * - `tokenA` and `tokenB` must be different tokens
 * - The amounts must meet the minimum requirements specified
 *
 * TODO: add return values [amountA, amountB, liquidity]
 *
 * @circuitInfo k=11, rows=2500
 *
 * @param {ShieldedCoinInfo} tokenA - The first token to add liquidity for.
 * @param {ShieldedCoinInfo} tokenB - The second token to add liquidity for.
 * @param {Uint<128>} amountAMin - The minimum amount of tokenA to add.
 * @param {Uint<128>} amountBMin - The minimum amount of tokenB to add.
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the LP tokens.
 *
 * @throws {Error} "Lunarswap: addLiquidity() - Identical addresses" if tokenA and tokenB are the same.
 * @throws {Error} "LunarswapRouter: Insufficient A amount" if the calculated amount is below minimum.
 * @throws {Error} "LunarswapRouter: Insufficient B amount" if the calculated amount is below minimum.
 *
 * @returns {Uint<128>} - The amount of liquidity minted.
 */
export circuit addLiquidity(
                 tokenA: ShieldedCoinInfo,
                 tokenB: ShieldedCoinInfo,
                 amountAMin: Uint<128>,
                 amountBMin: Uint<128>,
                 to: Either<ZswapCoinPublicKey, ContractAddress>,
                 ): Uint<128> {
  assert(tokenA.color != tokenB.color, "Lunarswap: addLiquidity() - Identical addresses");
  const [token0, token1] = disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
  const amount0Min = token0.color == tokenA.color ? amountAMin : amountBMin;
  const amount1Min = token0.color == tokenA.color ? amountBMin : amountAMin;
  const pairId = LunarswapLibrary_getIdentity(token0.color, token1.color, true);
  return disclose(LunarswapRouter_addLiquidity(pairId, token0, token1, amount0Min, amount1Min, to));
}

/**
 * @title removeLiquidity circuit
 * @description Removes liquidity from a trading pair and burns LP tokens.
 *
 * @remarks
 * This circuit handles the complete liquidity removal process. It receives the LP tokens,
 * adds them to the liquidity pot, burns them, and distributes the underlying tokens to the
 * liquidity provider.
 *
 * @circuitInfo k=11, rows=4000
 *
 * @param {ShieldedCoinInfo} tokenA - The first token in the pair.
 * @param {ShieldedCoinInfo} tokenB - The second token in the pair.
 * @param {ShieldedCoinInfo} liquidity - The LP tokens to remove.
 * @param {Uint<128>} amountAMin - The minimum amount of tokenA to remove.
 * @param {Uint<128>} amountBMin - The minimum amount of tokenB to remove.
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the removed tokens.
 *
 * @throws {Error} "Lunarswap: removeLiquidity() - Identical addresses" if tokenA and tokenB are the same.
 * @throws {Error} "LunarswapRouter: Insufficient A amount" if the calculated amount is below minimum.
 * @throws {Error} "LunarswapRouter: Insufficient B amount" if the calculated amount is below minimum.
 *
 * @returns [Uint<128>, Uint<128>] - The amounts of tokenA and tokenB removed.
 */
export circuit removeLiquidity(
                 tokenA: ShieldedCoinInfo,
                 tokenB: ShieldedCoinInfo,
                 liquidity: ShieldedCoinInfo,
                 amountAMin: Uint<128>,
                 amountBMin: Uint<128>,
                 to: Either<ZswapCoinPublicKey, ContractAddress>,
                 ): [Uint<128>, Uint<128>] {
  assert(tokenA.color != tokenB.color, "Lunarswap: removeLiquidity() - Identical addresses");
  const [token0, token1] = disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
  const amount0Min = token0.color == tokenA.color ? amountAMin : amountBMin;
  const amount1Min = token0.color == tokenA.color ? amountBMin : amountAMin;
  const pairId = LunarswapLibrary_getIdentity(token0.color, token1.color, true);
  const pair = LunarswapFactory_getPair(pairId);
  const [reserve0, reserve1] =
          LunarswapFactory_getReserves(pairId, pair.reserve0Id, pair.reserve1Id);

  assert(pair.token0Type == token0.color, "Lunarswap: removeLiquidity() - mismatched token0 color");
  assert(pair.token1Type == token1.color, "Lunarswap: removeLiquidity() - mismatched token1 color");
  assert(pair.lpTokenType == liquidity.color,
         "Lunarswap: removeLiquidity() - mismatched LP token color"
         );
  const [amount0, amount1] =
          disclose(LunarswapRouter_removeLiquidity(
                     pairId,
                     pair,
                     token0,
                     token1,
                     reserve0,
                     reserve1,
                     liquidity,
                     amount0Min,
                     amount1Min,
                     to
                     ));

  // Convert amounts back to original A/B order for assertions using ternary operations
  const amountA = (tokenA.color == token0.color) ? amount0 : amount1;
  const amountB = (tokenA.color == token0.color) ? amount1 : amount0;

  assert(amountA >= amountAMin, "LunarswapRouter: removeLiquidity() - Insufficient A amount");
  assert(amountB >= amountBMin, "LunarswapRouter: removeLiquidity() - Insufficient B amount");

  return [amountA, amountB];
}

/**
 * @title swapExactTokensForTokens circuit
 * @description Swaps an exact amount of input tokens for a minimum amount of output tokens.
 *
 * @remarks
 * This circuit handles the complete swap process. It receives the input tokens,
 * calculates the exact amount of output tokens, and returns the amount of input tokens
 * used.
 *
 * @circuitInfo k=11, rows=4000
 *
 * @param {ShieldedCoinInfo} tokenIn - The input token.
 * @param {ShieldedCoinInfo} tokenOut - The output token.
 * @param {Uint<128>} amountIn - The amount of input tokens to swap.
 * @param {Uint<128>} amountOutMin - The minimum amount of output tokens to receive.
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the output tokens.
 *
 * @returns {Uint<128>} - The amount of input tokens used.
 */
export circuit swapExactTokensForTokens(
                 tokenIn: ShieldedCoinInfo,
                 tokenOut: ShieldedCoinInfo,
                 amountIn: Uint<128>,
                 amountOutMin: Uint<128>,
                 to: Either<ZswapCoinPublicKey, ContractAddress>,
                 ): Uint<128> {
  assert(tokenIn.color != tokenOut.color,
         "Lunarswap: swapExactTokensForTokens() - Identical addresses"
         );
  const [token0, token1] =
          disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenIn, tokenOut));
  const pairId = LunarswapLibrary_getIdentity(token0.color, token1.color, true);
  const pair = LunarswapFactory_getPair(pairId);
  const [reserve0, reserve1] =
          LunarswapFactory_getReserves(pairId, pair.reserve0Id, pair.reserve1Id);
  return LunarswapRouter_swapExactTokensForTokens(
           pairId,
           pair,
           tokenIn,
           tokenOut,
           amountIn,
           amountOutMin,
           reserve0,
           reserve1,
           to
           );
}

/**
 * @title swapTokensForExactTokens circuit
 * @description Swaps an amount of input tokens for an exact amount of output tokens.
 *
 * @remarks
 * This circuit handles the complete swap process. It receives the input tokens,
 * calculates the exact amount of input tokens, and returns the amount of output tokens
 * received.
 *
 * @circuitInfo k=11, rows=4000
 *
 * @param {ShieldedCoinInfo} tokenIn - The input token.
 * @param {ShieldedCoinInfo} tokenOut - The output token.
 * @param {Uint<128>} amountOut - The amount of output tokens to receive.
 * @param {Uint<128>} amountInMax - The maximum amount of input tokens to use.
 * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the output tokens.
 *
 * @returns {Uint<128>} - The amount of input tokens used.
 */
export circuit swapTokensForExactTokens(
                 tokenIn: ShieldedCoinInfo,
                 tokenOut: ShieldedCoinInfo,
                 amountOut: Uint<128>,
                 amountInMax: Uint<128>,
                 to: Either<ZswapCoinPublicKey, ContractAddress>,
                 ): Uint<128> {
  assert(tokenIn.color != tokenOut.color,
         "Lunarswap: swapTokensForExactTokens() - Identical addresses"
         );
  const [token0, token1] =
          disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenIn, tokenOut));
  const pairId = LunarswapLibrary_getIdentity(token0.color, token1.color, true);
  const pair = LunarswapFactory_getPair(pairId);
  const [reserve0, reserve1] =
          LunarswapFactory_getReserves(pairId, pair.reserve0Id, pair.reserve1Id);
  return disclose(LunarswapRouter_swapTokensForExactTokens(
                    pairId,
                    pair,
                    tokenIn,
                    tokenOut,
                    amountOut,
                    amountInMax,
                    reserve0,
                    reserve1,
                    to
                    ));
}

/**
 * @title isPairExists circuit
 * @description Checks if a trading pair exists for the given token combination.
 *
 * @remarks
 * This circuit sorts the tokens to ensure consistent pair identification and checks
 * if a pair exists in the factory for the sorted token combination.
 *
 * @circuitInfo k=14, rows=14922
 *
 * @param {ShieldedCoinInfo} tokenA - The first token in the pair.
 * @param {ShieldedCoinInfo} tokenB - The second token in the pair.
 *
 * @returns {Boolean} - True if the pair exists, false otherwise.
 */
export circuit isPairExists(tokenA: ShieldedCoinInfo, tokenB: ShieldedCoinInfo): Boolean {
  const [token0, token1] = disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
  const pairId = LunarswapLibrary_getIdentity(token0.color, token1.color, true);
  return LunarswapFactory_isIdentityExists(pairId);
}

/**
 * @title getAllPairLength circuit
 * @description Returns the total number of trading pairs in the protocol.
 *
 * @remarks
 * This circuit provides a count of all registered trading pairs in the Lunarswap factory.
 *
 * @circuitInfo k=11, rows=200
 *
 * @returns {Uint<64>} - The total number of trading pairs.
 */
export circuit getAllPairLength(): Uint<64> {
  return LunarswapFactory_getAllPairLength();
}

/**
 * @title getPair circuit
 * @description Retrieves the pair information for a given token combination.
 *
 * @remarks
 * This circuit sorts the tokens and retrieves the pair data from the factory.
 * The pair must exist for this circuit to succeed.
 *
 * @circuitInfo k=11, rows=1000
 *
 * @param {ShieldedCoinInfo} tokenA - The first token in the pair.
 * @param {ShieldedCoinInfo} tokenB - The second token in the pair.
 *
 * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
 *
 * @returns {Pair} - The pair information including reserves and metadata.
 */
export circuit getPair(tokenA: ShieldedCoinInfo, tokenB: ShieldedCoinInfo): Pair {
  const [token0, token1] = disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
  const pairId = LunarswapLibrary_getIdentity(token0.color, token1.color, true);
  return LunarswapFactory_getPair(pairId);
}

/**
 * @title getPairReserves circuit
 * @description Returns the current reserves for a trading pair.
 *
 * @remarks
 * This circuit retrieves the reserves for a pair and returns them in the same order
 * as the input tokens, regardless of how they were sorted internally.
 *
 * @circuitInfo k=11, rows=1200
 *
 * @param {ShieldedCoinInfo} tokenA - The first token in the pair.
 * @param {ShieldedCoinInfo} tokenB - The second token in the pair.
 *
 * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
 *
 * @returns {[QualifiedShieldedCoinInfo, QualifiedShieldedCoinInfo]} - The reserves for tokenA and tokenB respectively.
 */
export circuit getPairReserves(
                 tokenA: ShieldedCoinInfo,
                 tokenB: ShieldedCoinInfo
                 ): [QualifiedShieldedCoinInfo, QualifiedShieldedCoinInfo] {
  const [token0, token1] = disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
  const pairId = LunarswapLibrary_getIdentity(token0.color, token1.color, true);
  const pair = LunarswapFactory_getPair(pairId);
  const [reserve0, reserve1] =
          LunarswapFactory_getReserves(pairId, pair.reserve0Id, pair.reserve1Id);
  if (tokenA.color == token0.color) {
    return [reserve0, reserve1];
  } else {
    return [reserve1, reserve0];
  }
}

/**
 * @title getPairId circuit
 * @description Generates the unique pairId hash for a token pair.
 *
 * @remarks
 * This circuit creates a deterministic hash that uniquely identifies a trading pair
 * by sorting the tokens and computing a hash of their colors.
 *
 * @circuitInfo k=11, rows=600
 *
 * @param {ShieldedCoinInfo} tokenA - The first token in the pair.
 * @param {ShieldedCoinInfo} tokenB - The second token in the pair.
 *
 * @returns {Bytes<32>} - The unique pairId hash for the pair.
 */
export circuit getPairId(tokenA: ShieldedCoinInfo, tokenB: ShieldedCoinInfo): Bytes<32> {
  const [token0, token1] = disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
  return LunarswapLibrary_getIdentity(token0.color, token1.color, true);
}

/**
 * @title getReserveId circuit
 * @description Computes the reserve pairId for a given pair pairId and token.
 *
 * @remarks
 * This circuit generates a unique identifier for a reserve by combining the pair's pairId
 * with the token's information. It is used to look up or manage reserves for a specific token
 * within a trading pair.
 *
 * @circuitInfo k=10, rows=20
 *
 * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
 * @param {Bytes<32>} tokenAType - The token type for which to compute the reserve pairId.
 *
 * @returns {Bytes<32>} - The unique reserve pairId for the given token in the pair.
 */
export circuit getReserveId(pairId: Bytes<32>, tokenAType: Bytes<32>): Bytes<32> {
  return LunarswapLibrary_getIdentity(pairId, tokenAType, false);
}

/**
 * @title getSortedCoins circuit
 * @description Sorts two ShieldedCoinInfo objects by their color in ascending order.
 *
 * @remarks
 * This circuit returns the two input tokens sorted by their color, which is used
 * to ensure consistent ordering for pair operations.
 *
 * @circuitInfo k=10, rows=30
 *
 * @param {ShieldedCoinInfo} tokenA - The first token to sort.
 * @param {ShieldedCoinInfo} tokenB - The second token to sort.
 *
 * @returns {[ShieldedCoinInfo, ShieldedCoinInfo]} - The sorted tokens, with the lower color first.
 */
export circuit getSortedCoins(
                 tokenA: ShieldedCoinInfo,
                 tokenB: ShieldedCoinInfo
                 ): [ShieldedCoinInfo, ShieldedCoinInfo] {
  return disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
}

/**
 * @title getSortedCoinsAndAmounts circuit
 * @description Sorts two ShieldedCoinInfo objects and their corresponding amounts by token color.
 *
 * @remarks
 * This circuit returns the tokens and their minimum amounts sorted by token color,
 * so that the amounts correspond to the sorted tokens. This is useful for
 * operations that require canonical token order.
 *
 * @circuitInfo k=10, rows=40
 *
 * @param {ShieldedCoinInfo} tokenA - The first token to sort.
 * @param {ShieldedCoinInfo} tokenB - The second token to sort.
 * @param {Uint<128>} amountAMin - The minimum amount for tokenA.
 * @param {Uint<128>} amountBMin - The minimum amount for tokenB.
 *
 * @returns {[ShieldedCoinInfo, ShieldedCoinInfo, Uint<128>, Uint<128>]} - The sorted tokens and their corresponding minimum amounts.
 */
export circuit getSortedCoinsAndAmounts(
                 tokenA: ShieldedCoinInfo,
                 tokenB: ShieldedCoinInfo,
                 amountAMin: Uint<128>,
                 amountBMin: Uint<128>
                 ): [ShieldedCoinInfo, ShieldedCoinInfo, Uint<128>, Uint<128>] {
  const [token0, token1] = disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
  const amount0 = token0.color == tokenA.color ? amountAMin : amountBMin;
  const amount1 = token0.color == tokenA.color ? amountBMin : amountAMin;
  return [token0, token1, amount0, amount1];
}

/**
 * @title getLpTokenTotalSupply circuit
 * @description Returns the total supply of LP tokens for a specific pair.
 *
 * @remarks
 * This circuit retrieves the total supply of liquidity provider tokens for a given trading pair.
 *
 * @circuitInfo k=14, rows=14998
 *
 * @param {ShieldedCoinInfo} tokenA - The first token in the pair.
 * @param {ShieldedCoinInfo} tokenB - The second token in the pair.
 *
 * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if the LP token doesn't exist.
 *
 * @returns {QualifiedShieldedCoinInfo} - The total supply of LP tokens for the pair.
 */
export circuit getLpTokenTotalSupply(
                 tokenA: ShieldedCoinInfo,
                 tokenB: ShieldedCoinInfo
                 ): QualifiedShieldedCoinInfo {
  const pairId = getPairId(tokenA, tokenB);
  return LunarswapLiquidity_getTotalSupply(pairId);
}

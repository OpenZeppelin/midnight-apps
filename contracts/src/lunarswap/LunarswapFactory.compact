// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (lunarswap-v1/LunarswapFactory.compact)

pragma language_version >= 0.21.0;

/**
 * @title LunarswapFactory
 * @description Factory contract for creating and managing trading pairs in the Lunarswap protocol.
 *
 * @remarks
 * The LunarswapFactory is responsible for the creation, storage, and management of all trading pairs
 * in the protocol. It implements a factory pattern where each unique token pair has a corresponding
 * pair contract that handles the actual trading logic and liquidity management.
 *
 * Key Features:
 * - Pair creation and initialization
 * - Pair storage and retrieval
 * - Reserve management and updates
 * - Deterministic pair identification through token sorting
 */
module LunarswapFactory {
  import
    { ShieldedCoinInfo,
      QualifiedShieldedCoinInfo,
      ZswapCoinPublicKey,
      ContractAddress,
      Either,
      right,
      sendShielded,
      kernel,
      mergeCoinImmediate,
      Map }
    from CompactStandardLibrary;
  import { isKeyOrAddressZero } from "../openzeppelin/Utils" prefix Utils_;

  import { Pair } from LunarswapPair;
  import { PairId, ReserveId } from LunarswapTypes;
  import
    { initialize, initializePair, getLpTokenTotalSupply }
    from LunarswapPair
      prefix LunarswapPair_;
  import { getIdentity, sortByColor } from LunarswapLibrary prefix LunarswapLibrary_;

  /**
   * @title pool ledger
   * @description Stores all trading pairs in the factory, mapping a unique pair pairId (Bytes<32>)
   *              to its corresponding Pair struct. This ledger enables efficient lookup and management
   *              of all created pairs within the Lunarswap protocol.
   *
   * @type {Map<PairId, Pair>}
   */
  export ledger pool: Map<PairId, Pair>;

  /**
   * @title reserves ledger
   * @description Maintains the reserves for each trading pair. It maps a unique pair pairId (Bytes<32>)
   *              to a nested map of token color (Bytes<32>) to its QualifiedShieldedCoinInfo. This structure allows
   *              for tracking and updating the reserves of each token within every pair.
   *
   * @type {Map<reserveType, QualifiedShieldedCoinInfo>}
   * @type {Map<ReserveId, QualifiedShieldedCoinInfo>}
   */
  export ledger reserves: Map<ReserveId, QualifiedShieldedCoinInfo>;

  /**
    * @title initialize circuit
    * @description Initializes the Lunarswap factory with LP token configuration.
    *
    * @remarks
    * This circuit sets up the initial configuration for LP tokens including name,
    * symbol, decimals, and nonce. It should only be called once during contract deployment.
    *
    * @circuitInfo k=11, rows=1200
    *
    * @param {Bytes<32>} nonce      - The nonce for LP token generation.
    * @param {Opaque<"string">} name - The name of the LP token.
    * @param {Opaque<"string">} symbol - The symbol of the LP token.
    * @param {Uint<8>} decimals     - The number of decimals for LP tokens.
    *
    * @returns [] - No return values.
    */
  export circuit initialize(
                   nonce: Bytes<32>,
                   name: Opaque<"string">,
                   symbol: Opaque<"string">,
                   decimals: Uint<8>
                   ): [] {
    return LunarswapPair_initialize(nonce, name, symbol, decimals);
  }

  /**
   * @title getPairId circuit
   * @description Returns the pairId for a given token pair.
   *
   * @remarks
   * This circuit returns the pairId for a given token pair.
   *
   * @circuitInfo k=9, rows=305
   *
   * @param {ShieldedCoinInfo} tokenA - The first token in the pair.
   * @param {ShieldedCoinInfo} tokenB - The second token in the pair.
   *
   * @returns {Bytes<32>} - The pairId for the given token pair.
   */
  export circuit getPairId(tokenA: ShieldedCoinInfo, tokenB: ShieldedCoinInfo): Bytes<32> {
    const [token0, token1] =
            disclose(LunarswapLibrary_sortByColor<ShieldedCoinInfo>(tokenA, tokenB));
    return LunarswapLibrary_getIdentity(token0.color, token1.color, true);
  }

  /**
   * @title getAllPairLength circuit
   * @description Returns the total number of trading pairs in the factory.
   *
   * @remarks
   * This circuit provides a count of all registered trading pairs stored in the liquidity pool.
   *
   * @circuitInfo k=6, rows=26
   *
   * @returns {Uint<64>} - The total number of trading pairs.
   */
  export circuit getAllPairLength(): Uint<64> {
    return pool.size();
  }

  /**
   * @title isPairExists circuit
   * @description Checks if a pair exists for the given pairId hash.
   *
   * @remarks
   * This circuit verifies whether a pair with the specified pairId hash exists
   * in the liquidity pool.
   *
   * @circuitInfo k=9, rows=305
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   *
   * @returns {Boolean} - True if the pair exists, false otherwise.
   */
  export circuit isPairExists(pairId: PairId): Boolean {
    return pool.member(disclose(pairId));
  }

  /**
   * @title getPair circuit
   * @description Retrieves the pair information for a given pairId hash.
   *
   * @remarks
   * This circuit returns the complete pair data including reserves and metadata.
   * The pair must exist for this circuit to succeed.
   *
   * @circuitInfo k=9, rows=475
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   *
   * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {Pair} - The pair information including reserves and metadata.
   */
  export circuit getPair(pairId: PairId): Pair {
    assert(isPairExists(pairId), "LunarswapFactory: getPair() - Pair does not exist");
    return pool.lookup(disclose(pairId));
  }

  /**
   * @title getReserves circuit
   * @description Returns the current reserves for a trading pair.
   *
   * @remarks
   * This circuit retrieves the reserves for a pair identified by its pairId hash
   * and token information. The reserves are returned in the order of token0 and token1.
   *
   * @circuitInfo k=10, rows=1010
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   * @param {Bytes<32>} reserve0Id - The id of the first reserve.
   * @param {Bytes<32>} reserve1Id - The id of the second reserve.
   *
   * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {[QualifiedShieldedCoinInfo, QualifiedShieldedCoinInfo]} - The reserves for token0 and token1 respectively.
   */
  export circuit getReserves(
                   pairId: PairId,
                   reserve0Id: ReserveId,
                   reserve1Id: ReserveId
                   ): [QualifiedShieldedCoinInfo, QualifiedShieldedCoinInfo] {
    assert(isPairExists(pairId), "LunarswapFactory: getReserves() - Pair does not exist");
    assert(reserves.member(disclose(reserve0Id)),
           "LunarswapFactory: getReserves() - Reserve0 does not exist"
           );
    assert(reserves.member(disclose(reserve1Id)),
           "LunarswapFactory: getReserves() - Reserve1 does not exist"
           );
    const reserve0 = reserves.lookup(disclose(reserve0Id));
    const reserve1 = reserves.lookup(disclose(reserve1Id));
    return [reserve0, reserve1];
  }

  /**
   * @title addReserves circuit
   * @description Adds the reserves for a given pair pairId with new token0 and token1 ShieldedCoinInfo.
   *
   * @circuitInfo k=17, rows=74372
   *
   * @param {ReserveId} reserve0Id - The type of the first reserve.
   * @param {ReserveId} reserve1Id - The type of the second reserve.
   * @param {ShieldedCoinInfo} token0    - The first token's ShieldedCoinInfo.
   * @param {ShieldedCoinInfo} token1    - The second token's ShieldedCoinInfo.
   *
   * @returns [] - No return values.
   */
  export circuit addReserves(
                   reserve0Id: ReserveId,
                   reserve1Id: ReserveId,
                   token0: ShieldedCoinInfo,
                   token1: ShieldedCoinInfo
                   ): [] {
    // This condition is a must because when initially depositing liquidity, the reserves are undefined.
    if (!reserves.member(disclose(reserve0Id)) && !reserves.member(disclose(reserve1Id))) {
      reserves.insertCoin(
        disclose(reserve0Id),
        disclose(token0),
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
      reserves.insertCoin(
        disclose(reserve1Id),
        disclose(token1),
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
      return [];
    }

    if (reserves.lookup(disclose(reserve0Id)).value == 0) {
      reserves.insertCoin(
        disclose(reserve0Id),
        disclose(token0),
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    } else {
      reserves.insertCoin(
        disclose(reserve0Id),
        mergeCoinImmediate(reserves.lookup(disclose(reserve0Id)), disclose(token0)),
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    }

    if (reserves.lookup(disclose(reserve1Id)).value == 0) {
      reserves.insertCoin(
        disclose(reserve1Id),
        disclose(token1),
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    } else {
      reserves.insertCoin(
        disclose(reserve1Id),
        mergeCoinImmediate(reserves.lookup(disclose(reserve1Id)), disclose(token1)),
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    }
    return [];
  }

  /**
   * @title removeReserves circuit
   * @description Removes the reserves for a given pair pairId with new token0 and token1 ShieldedCoinInfo.
   *
   * @circuitInfo k=16, rows=50487
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   * @param {ReserveId} reserve0Id - The type of the first reserve.
   * @param {ReserveId} reserve1Id - The type of the second reserve.
   * @param {Uint<128>} amount0 - The amount of token0 to remove.
   * @param {Uint<128>} amount1 - The amount of token1 to remove.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the removed tokens.
   *
   * @returns {[ShieldedCoinInfo, ShieldedCoinInfo]} - The amounts of token0 and token1 sent to the recipient.
   */
  export circuit removeReserves(
                   pairId: PairId,
                   reserve0Id: ReserveId,
                   reserve1Id: ReserveId,
                   amount0: Uint<128>,
                   amount1: Uint<128>,
                   to: Either<ZswapCoinPublicKey, ContractAddress>
                   ): [ShieldedCoinInfo, ShieldedCoinInfo] {
    const [reserve0, reserve1] = getReserves(pairId, reserve0Id, reserve1Id);
    const sendResults0 = sendShielded(reserve0, disclose(to), disclose(amount0));
    const sendResults1 = sendShielded(reserve1, disclose(to), disclose(amount1));
    if (sendResults0.change.is_some) {
      reserves.insertCoin(
        disclose(reserve0Id),
        sendResults0.change.value,
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    }
    if (sendResults1.change.is_some) {
      reserves.insertCoin(
        disclose(reserve1Id),
        sendResults1.change.value,
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    }
    return [sendResults0.sent, sendResults1.sent];
  }

  /**
   * @title swapReserves circuit
   * @description Swaps reserves between two tokens for a given pair pairId.
   *
   * @remarks
   * This circuit allows updating the reserves for a pair by either adding to the reserve
   * of `tokenIn` if its value is greater than zero, or sending out from the reserve of
   * `tokenOut` if its value is greater than zero.
   *
   * @circuitInfo k=16, rows=58791
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   * @param {ShieldedCoinInfo} tokenIn   - The input token information (to add to reserves).
   * @param {ShieldedCoinInfo} tokenOut  - The output token information (to remove from reserves).
   *
   * @returns [] - No return values.
   */
  export circuit swapReserves(
                   pairId: PairId,
                   tokenIn: ShieldedCoinInfo,
                   tokenOut: ShieldedCoinInfo,
                   to: Either<ZswapCoinPublicKey, ContractAddress>
                   ): [] {
    const reserveInType =
            LunarswapLibrary_getIdentity(
              disclose(pairId) as Bytes<32>,
              disclose(tokenIn.color),
              false
              );
    const reserveOutType =
            LunarswapLibrary_getIdentity(
              disclose(pairId) as Bytes<32>,
              disclose(tokenOut.color),
              false
              );
    const [reserveIn, reserveOut] =
            getReserves(pairId, reserveInType as ReserveId, reserveOutType as ReserveId);

    if (disclose(tokenIn.value) > 0) {
      reserves.insertCoin(
        reserveInType as ReserveId,
        mergeCoinImmediate(reserves.lookup(reserveInType as ReserveId), disclose(tokenIn)),
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    }

    if (disclose(tokenOut.value) > 0) {
      const sendResults = sendShielded(reserveOut, disclose(to), disclose(tokenOut.value));
      if (sendResults.change.is_some) {
        reserves.insertCoin(
          reserveOutType as ReserveId,
          sendResults.change.value,
          right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
          );
      }
    }

    assert(tokenIn.value > 0 || tokenOut.value > 0,
           "LunarswapFactory: swapReserves() - Invalid token"
           );

    return [];
  }

  /**
   * @title createPair circuit
   * @description Creates a new trading pair for the given tokens.
   *
   * @remarks
   * This circuit initializes a new trading pair with zero reserves and stores it
   * in the liquidity pool. The pair is identified by a unique hash generated from
   * the sorted token colors.
   *
   * Requirements:
   * - The token colors must be valid (non-zero)
   * - The pair must not already exist
   *
   * @circuitInfo k=14, rows=9693
   *
   * @param {Bytes<32>} pairId - The unique pairId hash for the new pair.
   * @param {ShieldedCoinInfo} token0    - The first token in the pair.
   * @param {ShieldedCoinInfo} token1    - The second token in the pair.
   *
   * @throws {Error} "LunarswapFactory: Invalid token color" if either token color is zero.
   *
   * @returns {Pair} - The created pair.
   */
  export circuit createPair(
                   pairId: PairId,
                   token0: ShieldedCoinInfo,
                   token1: ShieldedCoinInfo
                   ): Pair {
    // TODO: I am not sure if the Coin.Color can be set to zero.
    // TODO: UPDATE that assert is paused because the tDust token is zero address color.
    // assert (!Utils_isKeyOrAddressZero(right<ZswapCoinPublicKey, ContractAddress>( ContractAddress { bytes: token0.color }))) "LunarswapFactory: Invalid token color";
    const pair = LunarswapPair_initializePair(disclose(pairId), disclose(token0), disclose(token1));
    pool.insert(disclose(pairId), pair);
    return pair;
  }

  /**
   * @title updatePair circuit
   * @description Updates an existing trading pair with new data.
   *
   * @remarks
   * This circuit updates the pair data in the liquidity pool. The pair must already
   * exist for this operation to succeed.
   *
   * Requirements:
   * - The pair must already exist in the liquidity pool
   *
   * @circuitInfo k=12, rows=2558
   *
   * @param {Pair} pair     - The updated pair data.
   * @param {Bytes<32>} pairId          - The unique pairId hash of the pair.
   *
   * @throws {Error} "LunarswapFactory: updatePair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {Pair} - The updated pair data.
   */
  export circuit updatePair(pairId: PairId, pair: Pair): Pair {
    assert(isPairExists(pairId), "LunarswapFactory: updatePair() - Pair does not exist");
    pool.insert(disclose(pairId), disclose(pair));
    return pair;
  }

  /**
   * @title removePair circuit
   * @description Removes a trading pair from the liquidity pool.
   *
   * @remarks
   * This circuit removes a pair from the liquidity pool based on the pair's
   * token information. The pair must exist for this operation to succeed.
   *
   * Requirements:
   * - The pair must exist in the liquidity pool
   *
   * @circuitInfo k=13, rows=6023
   *
   * @param {Pair} pair - The pair to remove.
   *
   * @throws {Error} "LunarswapFactory: removePair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns [] - No return values.
   */
  export circuit removePair(pair: Pair): [] {
    const pairId = LunarswapLibrary_getIdentity(
                     disclose(pair.token0Type),
                     disclose(pair.token1Type),
                     true
                     );
    assert(isPairExists(pairId as PairId), "LunarswapFactory: removePair() - Pair does not exist");
    return pool.remove(disclose(pairId as PairId));
  }

  /**
   * @title getLpTokenTotalSupply circuit
   * @description Returns the total supply of LP tokens for the factory.
   *
   * @remarks
   * As LunarswapFactory is a parent module for LunarswapPair,
   * we need to wrap the LunarswapPair_getLpTokenTotalSupply circuit in a wrapper function.
   * This is necessary to ensure that the state is the same as the parent module otherwise
   * the state will not be the same.
   *
   * @circuitInfo k=, rows=
   *
   * @param {PairId} pairId - The unique pairId hash of the pair.
   *
   * @returns {Uint<128>} - The total supply of LP tokens for the pair.
   */
  export circuit getLpTokenTotalSupply(pairId: PairId): Uint<128> {
    return LunarswapPair_getLpTokenTotalSupply(pairId);
  }
}

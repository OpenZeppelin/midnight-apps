// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.2 (lunarswap/LunarswapLiquidity.compact)

pragma language_version >= 0.19.0;

/**
 * @title LunarswapLiquidity
 * @description Liquidity Provider (LP) token management system for the Lunarswap protocol.
 *
 * @remarks
 * The LunarswapLiquidity module manages the creation, minting, burning, and tracking of liquidity
 * provider tokens. These tokens represent a user's share of liquidity in a trading pair and
 * entitle holders to a portion of trading fees and the underlying assets.
 *
 * Key Features:
 * - LP token minting for liquidity providers
 * - LP token burning for liquidity removal
 * - Total supply tracking per trading pair
 * - Token metadata management (name, symbol, decimals)
 * - Nonce-based token generation
 * - UTXO-based token model
 */
module LunarswapLiquidity {
  import
    { ZswapCoinPublicKey,
      ContractAddress,
      Either,
      Map,
      Counter,
      left,
      ownPublicKey,
      sendImmediate,
      burnAddress,
      evolveNonce,
      mintShieldedToken,
      receiveShielded,
      sendImmediateShielded,
      QualifiedShieldedCoinInfo,
      ShieldedSendResult,
      ShieldedCoinInfo,
      shieldedBurnAddress }
    from CompactStandardLibrary;

  import { addChecked, sub } from "../math/Uint128" prefix Uint128_;
  import { isZero } from "../math/Bytes32" prefix Bytes32_;

  /**
   * @ledger _counter
   * @description
   * Internal counter used for LP token nonce evolution and minting operations.
   */
  ledger _counter: Counter;

  /**
   * @ledger nonce
   * @description
   * The global nonce used for LP token generation and uniqueness.
   */
  export ledger nonce: Bytes<32>;

  /**
   * @ledger totalSupply
   * @description Mapping of trading pair hash (id) to the total supply (Uint<128>)
   * and metadata (QualifiedShieldedCoinInfo) of LP tokens for that pair.
   *
   * @type {Map<Bytes<32>, QualifiedShieldedCoinInfo>}
   */
  export ledger totalSupply: Map<Bytes<32>, QualifiedShieldedCoinInfo>;

  /**
   * @ledger name
   * @description
   * The name of the LP token (e.g., "Lunarswap LP Token").
   */
  export sealed ledger name: Opaque<"string">;

  /**
   * @ledger symbol
   * @description
   * The symbol of the LP token (e.g., "LUNAR-LP").
   */
  export sealed ledger symbol: Opaque<"string">;

  /**
   * @ledger decimals
   * @description
   * The number of decimals used for LP tokens (e.g., 18).
   */
  export sealed ledger decimals: Uint<8>;

  /**
   * @ledger type
   * @description
   * The color/type identifier for the LP token (Bytes<32>).
   */
  export ledger type: Bytes<32>;

  /**
   * @title initialize circuit
   * @description Initializes the LP token system with basic configuration.
   *
   * @remarks
   * This circuit sets up the initial configuration for LP tokens including name,
   * symbol, decimals, and nonce. It should only be called once during contract deployment.
   *
   * @param {Bytes<32>} nonce_      - The nonce for LP token generation.
   * @param {Opaque<"string">} name_ - The name of the LP token.
   * @param {Opaque<"string">} symbol_ - The symbol of the LP token.
   * @param {Uint<8>} decimals_     - The number of decimals for LP tokens.
   *
   * @returns {[]} - No return values.
   */
  export circuit initialize(
    nonce_: Bytes<32>,
    name_: Opaque<"string">,
    symbol_: Opaque<"string">,
    decimals_: Uint<8>
  ): [] {
    nonce = disclose(nonce_);
    name = disclose(name_);
    symbol = disclose(symbol_);
    decimals = disclose(decimals_);
  }

  /**
   * @title initializePairToken circuit
   * @description Initializes token tracking for a new trading pair.
   *
   * @remarks
   * This circuit sets up the total supply tracking for a new trading pair by
   * initializing the supply to zero in the total supply map.
   *
   * Requirements:
   * - The pair id must not already have LP tokens initialized
   *
   * @param {Bytes<32>} id - The unique id hash of the trading pair.
   *
   * @throws {Error} "LunarswapLiquidity: initializePairToken() - Lp token already exists" if LP tokens already exist for this pair.
   *
   * @returns {[]} - No return values.
   */
  export circuit initializePairToken(id: Bytes<32>): [] {
    assert(!totalSupply.member(id), "LunarswapLiquidity: initializePairToken() - Lp token already exists");
    totalSupply.insert(id, default<QualifiedShieldedCoinInfo>);
    return [];
  }

  /**
   * @title getTotalSupply circuit
   * @description Returns the LP token info for a specific pair including total supply.
   *
   * @remarks
   * This circuit retrieves the qualified coin info for the LP tokens of a given
   * trading pair id. The `value` field contains the total supply.
   *
   * Requirements:
   * - The pair id must have LP tokens initialized
   *
   * @param {Bytes<32>} id - The unique id hash of the trading pair.
   *
   * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
   *
   * @returns {QualifiedShieldedCoinInfo} - The LP token info including total supply in the value field.
   */
  export circuit getTotalSupply(id: Bytes<32>): QualifiedShieldedCoinInfo {
    assert(totalSupply.member(id), "LunarswapLiquidity: totalSupply() - Lp token not found");
    return totalSupply.lookup(id);
  }

  /**
   * @title mint circuit
   * @description Mints new LP tokens and sends them to the specified recipient.
   *
   * @remarks
   * This circuit creates new LP tokens for a trading pair and sends them to the
   * specified recipient. It also updates the total supply for the pair.
   *
   * Requirements:
   * - The pair id must have LP tokens initialized
   * - The amount must be greater than zero
   *
   * @param {Bytes<32>} id - The unique id hash of the trading pair.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} recipient - The recipient of the minted LP tokens.
   * @param {Uint<128>} amount - The amount of LP tokens to mint.
   *
   * @returns {CoinInfo} - The minted LP token coin.
   */
  export circuit mint(id: Bytes<32>,
                      recipient: Either<ZswapCoinPublicKey, ContractAddress>,
                      amount: Uint<64>
                      ): ShieldedCoinInfo {
    _counter.increment(1);
    const newNonce = evolveNonce(_counter, nonce);
    // id dealt as a domainSep in the mintToken circuit
    const ret = mintShieldedToken(id, amount, newNonce, recipient);

    if (Bytes32_isZero(type)) {
      type = ret.color;
    }

    const newTotalSupply =
                  QualifiedShieldedCoinInfo { nonce: ret.nonce,
                                              color: ret.color,
                                              value: Uint128_addChecked(
                                                       totalSupply.lookup(id).value, amount),
                                              mt_index: totalSupply.lookup(id).mt_index, };
    totalSupply.insert(id, disclose(newTotalSupply));

    return ret;
  }

  /**
   * @title burn circuit
   * @description Burns LP tokens and returns the underlying assets.
   *
   * @remarks
   * This circuit burns LP tokens by receiving them and updating the total supply.
   * The burned tokens are sent to the burn address, and any change is returned
   * to the contract's own address.
   *
   * Requirements:
   * - The coin value must be sufficient for the burn amount
   * - The pair id must have LP tokens initialized
   *
   * @param {Bytes<32>} id - The unique id hash of the trading pair.
   * @param {CoinInfo} coin - The LP token coin to burn.
   * @param {Uint<128>} amount - The amount of LP tokens to burn.
   *
   * @throws {Error} "LunarswapLiquidity: burn() - Insufficient coin value" if coin value is less than burn amount.
   * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
   *
   * @returns {SendResult} - The result of the burn operation including any change.
   */
  export circuit burn(id: Bytes<32>, coin: ShieldedCoinInfo, amount: Uint<128>): ShieldedSendResult {
    assert(totalSupply.member(id), "LunarswapLiquidity: totalSupply() - Lp token not found");
    assert(coin.value >= amount, "LunarswapLiquidity: burn() - Insufficient coin value");

    receiveShielded(coin);

    const newTotalSupply =
                  QualifiedShieldedCoinInfo { nonce: coin.nonce,
                                              color: coin.color,
                                              value: Uint128_sub(
                                                       totalSupply.lookup(id).value, amount),
                                              mt_index: totalSupply.lookup(id).mt_index, // TODO: needs review
                                              };
    totalSupply.insert(id, newTotalSupply);

    const ret = sendImmediateShielded(coin, shieldedBurnAddress(), amount);
    if (ret.change.is_some) {
      const tmpAddr = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
      sendImmediateShielded(ret.change.value, tmpAddr, ret.change.value.value);
    }
    return ret;
  }
}

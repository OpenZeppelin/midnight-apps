pragma language_version >= 0.20.0;

/**
 * @title LunarswapLiquidity
 * @description Liquidity Provider (LP) token management system for the Lunarswap protocol.
 *
 * @remarks
 * The LunarswapLiquidity module manages the creation, minting, burning, and tracking of liquidity
 * provider tokens. These tokens represent a user's share of liquidity in a trading pair and
 * entitle holders to a portion of trading fees and the underlying assets.
 *
 * Key Features:
 * - LP token minting for liquidity providers
 * - LP token burning for liquidity removal
 * - Total supply tracking per trading pair
 * - Token metadata management (name, symbol, decimals)
 * - Nonce-based token generation
 * - UTXO-based token model
 */
module LunarswapLiquidity {
    import CompactStandardLibrary;

    import "../openzeppelin/ShieldedERC20" prefix ShieldedERC20_;
    import "../math/Uint128" prefix Uint128_;
    import "../math/Bytes32" prefix Bytes32_;

    import "./interfaces/ILunarswapLiquidity";

    /**
     * @title initialize circuit
     * @description Initializes the LP token system with basic configuration.
     *
     * @remarks
     * This circuit sets up the initial configuration for LP tokens including name,
     * symbol, decimals, and nonce. It should only be called once during contract deployment.
     *
     * @param {Bytes<32>} nonce_      - The nonce for LP token generation.
     * @param {Opaque<"string">} name_ - The name of the LP token.
     * @param {Opaque<"string">} symbol_ - The symbol of the LP token.
     * @param {Uint<8>} decimals_     - The number of decimals for LP tokens.
     *
     * @returns [] - No return values.
     */
    export circuit initialize(
        nonce_: Bytes<32>,
        name_: Opaque<"string">,
        symbol_: Opaque<"string">,
        decimals_: Uint<8>
    ): [] {
        lpTokenNonce = disclose(nonce_);
        lpTokenName = disclose(name_);
        lpTokenSymbol = disclose(symbol_);
        lpTokenDecimals = disclose(decimals_);
        return [];
    }

    /**
     * @title initializePairLpToken circuit
     * @description Initializes LP token tracking for a new trading pair.
     *
     * @remarks
     * This circuit sets up the total supply tracking for a new trading pair by
     * initializing the supply to zero in the total supply map.
     *
     * Requirements:
     * - The pair pairId must not already have LP tokens initialized
     *
     * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
     *
     * @throws {Error} "LunarswapLiquidity: initializePairLpToken() - Lp token already exists" if LP tokens already exist for this pair.
     *
     * @returns [] - No return values.
     */
    export circuit initializePairLpToken(pairId: Bytes<32>): [] {
        assert(!lpTotalSupply.member(disclose(pairId)), "LunarswapLiquidity: initializePairLpToken() - Lp token already exists");
        lpTotalSupply.insert(pairId, default<QualifiedShieldedCoinInfo>);
        return [];
    }

    /**
     * @title totalSupply circuit
     * @description Returns the total supply of LP tokens for a specific pair.
     *
     * @remarks
     * This circuit retrieves the total supply of liquidity provider tokens for a given
     * trading pair pairId.
     *
     * Requirements:
     * - The pair pairId must have LP tokens initialized
     *
     * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
     *
     * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
     *
     * @returns {Uint<128>} - The total supply of LP tokens for the pair.
     */
    export circuit totalSupply(pairId: Bytes<32>): QualifiedShieldedCoinInfo {
        assert(lpTotalSupply.member(disclose(pairId)), "LunarswapLiquidity: totalSupply() - Lp token not found");
        return lpTotalSupply.lookup(disclose(pairId));
    }

    /**
     * @title mint circuit
     * @description Mints new LP tokens and sends them to the specified recipient.
     *
     * @remarks
     * This circuit creates new LP tokens for a trading pair and sends them to the
     * specified recipient. It also updates the total supply for the pair.
     *
     * Requirements:
     * - The pair pairId must have LP tokens initialized
     * - The amount must be greater than zero
     * - The amount must fit in Uint<64> (max ~1.8e19)
     *
     * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} recipient - The recipient of the minted LP tokens.
     * @param {Uint<64>} amount - The amount of LP tokens to mint.
     *
     * @returns {ShieldedCoinInfo} - The minted LP token coin.
     */
    export circuit mint(
        pairId: Bytes<32>,
        recipient: Either<ZswapCoinPublicKey, ContractAddress>,
        amount: Uint<64>
    ): ShieldedCoinInfo {
        _counter.increment(1);
        const newNonce = evolveNonce(_counter, lpTokenNonce);
        // pairId is used as domainSep in mintShieldedToken
        const ret = mintShieldedToken(pairId, amount, newNonce, disclose(recipient));

        if (Bytes32_isZero(lpTokenType)) {
            lpTokenType = ret.color;
        }

        // const newTotalSupply = QualifiedShieldedCoinInfo {
        //     nonce: ret.nonce,
        //     color: ret.color,
        //     value: Uint128_addChecked(lpTotalSupply.lookup(pairId).value, amount),
        //     mt_index: lpTotalSupply.lookup(pairId).mt_index,
        // };
        lpTotalSupply.insertCoin(pairId, ret, disclose(recipient));

        return ret;
    }

    /**
     * @title burn circuit
     * @description Burns LP tokens and returns the underlying assets.
     *
     * @remarks
     * This circuit burns LP tokens by receiving them and updating the total supply.
     * The burned tokens are sent to the burn address, and any change is returned
     * to the contract's own address.
     *
     * Requirements:
     * - The coin value must be sufficient for the burn amount
     * - The pair pairId must have LP tokens initialized
     *
     * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
     * @param {ShieldedCoinInfo} coin - The LP token coin to burn.
     * @param {Uint<128>} amount - The amount of LP tokens to burn.
     *
     * @throws {Error} "LunarswapLiquidity: burn() - Insufficient coin value" if coin value is less than burn amount.
     * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
     *
     * @returns {ShieldedSendResult} - The result of the burn operation including any change.
     */
    export circuit burn(
        pairId: Bytes<32>,
        coin: ShieldedCoinInfo,
        amount: Uint<128>
    ): ShieldedSendResult {
        assert(lpTotalSupply.member(disclose(pairId)), "LunarswapLiquidity: totalSupply() - Lp token not found");
        assert(coin.value >= amount, "LunarswapLiquidity: burn() - Insufficient coin value");

        receiveShielded(disclose(coin));

        const newTotalSupply = ShieldedCoinInfo {
            nonce: coin.nonce,
            color: coin.color,
            value: Uint128_sub(lpTotalSupply.lookup(disclose(pairId)).value, amount),
        };
        lpTotalSupply.insertCoin(disclose(pairId), disclose(newTotalSupply), shieldedBurnAddress());

        const ret = disclose(sendImmediateShielded(disclose(coin), shieldedBurnAddress(), disclose(amount)));
        if (ret.change.is_some) {
            const tmpAddr = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
            sendImmediateShielded(ret.change.value, disclose(tmpAddr), ret.change.value.value);
        }
        return ret;
    }
}

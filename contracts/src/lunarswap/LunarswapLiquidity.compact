// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (lunarswap-v1/LunarswapLiquidity.compact)

pragma language_version >= 0.20.0;

/**
 * @title LunarswapLiquidity
 * @description Liquidity Provider (LP) token management system for the Lunarswap protocol.
 *
 * @remarks
 * The LunarswapLiquidity module manages the creation, minting, burning, and tracking of liquidity
 * provider tokens. These tokens represent a user's share of liquidity in a trading pair and
 * entitle holders to a portion of trading fees and the underlying assets.
 *
 * Key Features:
 * - LP token minting for liquidity providers
 * - LP token burning for liquidity removal
 * - Total supply tracking per trading pair
 * - Token metadata management (name, symbol, decimals)
 * - Nonce-based token generation
 * - UTXO-based token model
 */
module LunarswapLiquidity {
  import
    { ShieldedCoinInfo,
      QualifiedShieldedCoinInfo,
      ZswapCoinPublicKey,
      ContractAddress,
      Either,
      Map,
      Counter,
      ShieldedSendResult,
      left,
      receiveShielded,
      sendImmediateShielded,
      ownPublicKey,
      mintShieldedToken,
      shieldedBurnAddress,
      evolveNonce }
    from CompactStandardLibrary;

  import { mint, burn } from "../openzeppelin/ShieldedERC20" prefix ShieldedERC20_;
  import { sub, addChecked } from "../math/Uint128" prefix Uint128_;
  import { isZero } from "../math/Bytes32" prefix Bytes32_;

  /**
   * @ledger {Counter} _counter
   * @description Internal counter used for LP token nonce evolution and minting operations.
   */
  export ledger counter: Counter;

  /**
   * @ledger {Bytes<32>} nonce
   * @description The global nonce used for LP token generation and uniqueness.
   */
  export ledger nonce: Bytes<32>;

  /**
   * @ledger {Map<Bytes<32>, QualifiedShieldedCoinInfo>} lpTotalSupply
   * @description Mapping of trading pair hash (pairId) to the total supply and metadata of LP tokens for that pair.
   * The key is the pair hash (Bytes<32>), and the value is the QualifiedShieldedCoinInfo for the LP token.
   */
  export ledger totalSupply: Map<Bytes<32>, QualifiedShieldedCoinInfo>;

  /**
   * @ledger {Bytes<32>} domain
   * @description The color of the LP token (Bytes<32>).
   */
  export sealed ledger domain: Bytes<32>;

  /**
   * @ledger {Opaque<"string">} name
   * @description The name of the LP token (e.g., "Lunarswap LP Token").
   */
  export sealed ledger name: Opaque<"string">;

  /**
   * @ledger {Opaque<"string">} symbol
   * @description The symbol of the LP token (e.g., "LUNAR-LP").
   */
  export sealed ledger symbol: Opaque<"string">;

  /**
   * @ledger {Uint<8>} decimals
   * @description The number of decimals used for the LP token (e.g., 18).
   */
  export sealed ledger decimals: Uint<8>;

  /**
   * @ledger {Bytes<32>} color
   * @description The color of the LP token (Bytes<32>).
   */
  export ledger color: Bytes<32>;

  /**
   * @title initialize circuit
   * @description Initializes the LP token system with basic configuration.
   *
   * @remarks
   * This circuit sets up the initial configuration for LP tokens including name,
   * symbol, decimals, and nonce. It should only be called once during contract deployment.
   *
   * @param {Bytes<32>} nonce_      - The nonce for LP token generation.
   * @param {Opaque<"string">} name_ - The name of the LP token.
   * @param {Opaque<"string">} symbol_ - The symbol of the LP token.
   * @param {Uint<8>} decimals_     - The number of decimals for LP tokens.
   *
   * @returns [] - No return values.
   */
  export circuit initialize(
                   nonce_: Bytes<32>,
                   name_: Opaque<"string">,
                   symbol_: Opaque<"string">,
                   decimals_: Uint<8>
                   ): [] {
    nonce = disclose(nonce_);
    name = disclose(name_);
    symbol = disclose(symbol_);
    decimals = disclose(decimals_);
    return [];
  }

  /**
   * @title initializePairLpToken circuit
   * @description Initializes LP token tracking for a new trading pair.
   *
   * @remarks
   * This circuit sets up the total supply tracking for a new trading pair by
   * initializing the supply to zero in the total supply map.
   *
   * Requirements:
   * - The pair pairId must not already have LP tokens initialized
   *
   * @circuitInfo k=9, rows=308
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
   *
   * @throws {Error} "LunarswapLiquidity: initializePairLpToken() - Lp token already exists" if LP tokens already exist for this pair.
   *
   * @returns [] - No return values.
   */
  export circuit initializePairLpToken(pairId: Bytes<32>): [] {
    assert(!totalSupply.member(disclose(pairId)),
           "LunarswapLiquidity: initializePairLpToken() - Lp token already exists"
           );
    totalSupply.insert(pairId, default<QualifiedShieldedCoinInfo>);
    return [];
  }

  /**
   * @title getTotalSupply circuit
   * @description Returns the total supply of LP tokens for a specific pair.
   *
   * @remarks
   * This circuit retrieves the total supply of liquidity provider tokens for a given
   * trading pair pairId.
   *
   * Requirements:
   * - The pair pairId must have LP tokens initialized
   *
   * @circuitInfo k=9, rows=377
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
   *
   * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
   *
   * @returns {Uint<128>} - The total supply of LP tokens for the pair.
   */
  export circuit getTotalSupply(pairId: Bytes<32>): QualifiedShieldedCoinInfo {
    assert(totalSupply.member(disclose(pairId)),
           "LunarswapLiquidity: totalSupply() - Lp token not found"
           );
    return totalSupply.lookup(disclose(pairId));
  }

  /**
   * @title mint circuit
   * @description Mints new LP tokens and sends them to the specified recipient.
   *
   * @remarks
   * This circuit creates new LP tokens for a trading pair and sends them to the
   * specified recipient. It also updates the total supply for the pair.
   *
   * Requirements:
   * - The pair pairId must have LP tokens initialized
   * - The amount must be greater than zero
   * - The amount must fit in Uint<64> (max ~1.8e19)
   *
   * @circuitInfo k=15, rows=17016
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
   * @param {Either<ZswapCoinPublicKey, ContractAddress>} recipient - The recipient of the minted LP tokens.
   * @param {Uint<64>} amount - The amount of LP tokens to mint.
   *
   * @returns {ShieldedCoinInfo} - The minted LP token coin.
   */
  export circuit mint(pairId: Bytes<32>,
                      recipient: Either<ZswapCoinPublicKey, ContractAddress>,
                      amount: Uint<64>
                      ): ShieldedCoinInfo {
    counter.increment(1);
    const newNonce = evolveNonce(counter, nonce);
    // pairId is used as domainSep in mintShieldedToken
    const ret = mintShieldedToken(pairId, amount, newNonce, disclose(recipient));

    if (Bytes32_isZero(color)) {
      color = ret.color;
    }


    const newTotalSupply = QualifiedShieldedCoinInfo {
            nonce: ret.nonce,
            color: ret.color,
            value: Uint128_addChecked(totalSupply.lookup(disclose(pairId)).value, amount),
            mt_index: totalSupply.lookup(disclose(pairId)).mt_index,
        };
    totalSupply.insert(disclose(pairId), disclose(newTotalSupply));
    //totalSupply.insertCoin(pairId, ret, disclose(recipient));

    return ret;
  }

  /**
   * @title burn circuit
   * @description Burns LP tokens and returns the underlying assets.
   *
   * @remarks
   * This circuit burns LP tokens by receiving them and updating the total supply.
   * The burned tokens are sent to the burn address, and any change is returned
   * to the contract's own address.
   *
   * Requirements:
   * - The coin value must be sufficient for the burn amount
   * - The pair pairId must have LP tokens initialized
   *
   * @circuitInfo k=16, rows=43735
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the trading pair.
   * @param {ShieldedCoinInfo} coin - The LP token coin to burn.
   * @param {Uint<128>} amount - The amount of LP tokens to burn.
   *
   * @throws {Error} "LunarswapLiquidity: burn() - Insufficient coin value" if coin value is less than burn amount.
   * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
   *
   * @returns {ShieldedSendResult} - The result of the burn operation including any change.
   */
  export circuit burn(pairId: Bytes<32>,
                      coin: ShieldedCoinInfo,
                      amount: Uint<128>
                      ): ShieldedSendResult {
    assert(totalSupply.member(disclose(pairId)),
           "LunarswapLiquidity: totalSupply() - Lp token not found"
           );
    assert(coin.value >= amount, "LunarswapLiquidity: burn() - Insufficient coin value");

    receiveShielded(disclose(coin));

    // const newTotalSupply =
    //         ShieldedCoinInfo { nonce: coin.nonce,
    //                            color: coin.color,
    //                            value: Uint128_sub(
    //                                     totalSupply.lookup(disclose(pairId)).value,
    //                                     amount
    //                                     ), };
    const newTotalSupply = QualifiedShieldedCoinInfo {
            nonce: coin.nonce,
            color: coin.color,
            value: Uint128_sub(totalSupply.lookup(disclose(pairId)).value, amount),
            mt_index: totalSupply.lookup(disclose(pairId)).mt_index, // TODO: needs review
        };
    totalSupply.insert(disclose(pairId), disclose(newTotalSupply));

    //totalSupply.insertCoin(disclose(pairId), disclose(newTotalSupply), shieldedBurnAddress());

    const ret = disclose(sendImmediateShielded(
                           disclose(coin),
                           shieldedBurnAddress(),
                           disclose(amount)
                           ));
    if (ret.change.is_some) {
      const tmpAddr = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
      sendImmediateShielded(ret.change.value, disclose(tmpAddr), ret.change.value.value);
    }
    return ret;
  }
}

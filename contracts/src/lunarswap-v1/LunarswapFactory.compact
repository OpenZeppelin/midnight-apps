// SPDX-License-Identifier: MIT
// OpenZeppelin Midnight Apps Contracts v0.0.1-alpha.0 (lunarswap-v1/LunarswapFactory.compact)

pragma language_version >= 0.18.0;

/**
 * @title LunarswapFactory
 * @description Factory contract for creating and managing trading pairs in the Lunarswap protocol.
 * 
 * @remarks
 * The LunarswapFactory is responsible for the creation, storage, and management of all trading pairs
 * in the protocol. It implements a factory pattern where each unique token pair has a corresponding
 * pair contract that handles the actual trading logic and liquidity management.
 * 
 * Key Features:
 * - Pair creation and initialization
 * - Pair storage and retrieval
 * - Reserve management and updates
 * - Deterministic pair identification through token sorting
 */
module LunarswapFactory {
  import CompactStandardLibrary;

  import "../../../compact-contracts/contracts/src/utils/Utils" prefix Utils_;

  import "./types/TPair";

  import LunarswapPair prefix LunarswapPair_;
  import LunarswapLibrary prefix LunarswapLibrary_;

  /**
   * @title pool ledger
   * @description Stores all trading pairs in the factory, mapping a unique pair pairId (Bytes<32>)
   *              to its corresponding Pair struct. This ledger enables efficient lookup and management
   *              of all created pairs within the Lunarswap protocol.
   *
   * @type {Map<Bytes<32>, Pair>}
   */
  export ledger pool: Map<Bytes<32>, Pair>;

  /**
   * @title reserves ledger
   * @description Maintains the reserves for each trading pair. It maps a unique pair pairId (Bytes<32>)
   *              to a nested map of token color (Bytes<32>) to its QualifiedCoinInfo. This structure allows
   *              for tracking and updating the reserves of each token within every pair.
   *
   * @type {Map<reserveType, QualifiedCoinInfo>}
   * @type {Map<Bytes<32>, QualifiedCoinInfo>}
   */
  export ledger reserves: Map<Bytes<32>, QualifiedCoinInfo>;

  /**
   * @title initialize circuit
   * @description Initializes the Lunarswap factory with LP token configuration.
   * 
   * @remarks
   * This circuit sets up the initial configuration for LP tokens including name,
   * symbol, decimals, and nonce. It should only be called once during contract deployment.
   *
   * @circuitInfo k=11, rows=1200
   *
   * @param {Bytes<32>} lpTokenNonce      - The nonce for LP token generation.
   * @param {Opaque<"string">} lpTokenName - The name of the LP token.
   * @param {Opaque<"string">} lpTokenSymbol - The symbol of the LP token.
   * @param {Uint<8>} lpTokenDecimals     - The number of decimals for LP tokens.
   *
   * @returns [] - No return values.
   */
  export circuit initialize(
                   lpTokenNonce: Bytes<32>,
                   lpTokenName: Opaque<"string">,
                   lpTokenSymbol: Opaque<"string">,
                   lpTokenDecimals: Uint<8>
                   ): [] {
    return LunarswapPair_initialize(lpTokenNonce, lpTokenName, lpTokenSymbol, lpTokenDecimals);
  }

  /**
   * @title getAllPairLength circuit
   * @description Returns the total number of trading pairs in the factory.
   * 
   * @remarks
   * This circuit provides a count of all registered trading pairs stored in the liquidity pool.
   *
   * @circuitInfo k=11, rows=300
   *
   * @returns {Uint<64>} - The total number of trading pairs.
   */
  export circuit getAllPairLength(): Uint<64> {
    return pool.size();
  }

  /**
   * @title isIdentityExists circuit
   * @description Checks if a trading pair exists for the given pairId hash.
   * 
   * @remarks
   * This circuit verifies whether a pair with the specified pairId hash exists
   * in the liquidity pool.
   *
   * @circuitInfo k=11, rows=400
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   *
   * @returns {Boolean} - True if the pair exists, false otherwise.
   */
  export circuit isIdentityExists(pairId: Bytes<32>): Boolean {
    return pool.member(pairId);
  }

  /**
   * @title getPair circuit
   * @description Retrieves the pair information for a given pairId hash.
   * 
   * @remarks
   * This circuit returns the complete pair data including reserves and metadata.
   * The pair must exist for this circuit to succeed.
   *
   * @circuitInfo k=11, rows=600
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   *
   * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {Pair} - The pair information including reserves and metadata.
   */
  export circuit getPair(pairId: Bytes<32>): Pair {
    assert(isIdentityExists(pairId), "LunarswapFactory: getPair() - Pair does not exist");
    return pool.lookup(pairId);
  }

  /**
   * @title getReserves circuit
   * @description Returns the current reserves for a trading pair.
   * 
   * @remarks
   * This circuit retrieves the reserves for a pair identified by its pairId hash
   * and token information. The reserves are returned in the order of token0 and token1.
   *
   * @circuitInfo k=11, rows=800
   *
   * @param {Bytes<32>} pairId - The unique pairId hash of the pair.
   * @param {Bytes<32>} reserve0Id - The id of the first reserve.
   * @param {Bytes<32>} reserve1Id - The id of the second reserve.
   *
   * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - The reserves for token0 and token1 respectively.
   */
  export circuit getReserves(pairId: Bytes<32>, reserve0Id: Bytes<32>, reserve1Id: Bytes<32>): [QualifiedCoinInfo,
                                                                                                QualifiedCoinInfo] {
    assert(isIdentityExists(pairId), "LunarswapFactory: getReserves() - Pair does not exist");
    assert(reserves.member(reserve0Id), "LunarswapFactory: getReserves() - Reserve0 does not exist");
    assert(reserves.member(reserve1Id), "LunarswapFactory: getReserves() - Reserve1 does not exist");
    const reserve0 = reserves.lookup(reserve0Id);
    const reserve1 = reserves.lookup(reserve1Id);
    return [reserve0, reserve1];
  }

  /**
   * @title createPair circuit
   * @description Creates a new trading pair for the given tokens.
   * 
   * @remarks
   * This circuit initializes a new trading pair with zero reserves and stores it
   * in the liquidity pool. The pair is identified by a unique hash generated from
   * the sorted token colors.
   *
   * Requirements:
   * - The token colors must be valid (non-zero)
   * - The pair must not already exist
   *
   * @circuitInfo k=11, rows=1500
   *
   * @param {Bytes<32>} pairId - The unique pairId hash for the new pair.
   * @param {CoinInfo} token0    - The first token in the pair.
   * @param {CoinInfo} token1    - The second token in the pair.
   *
   * @throws {Error} "LunarswapFactory: Invalid token color" if either token color is zero.
   *
   * @returns {Pair} - The created pair.
   */
  export circuit createPair(pairId: Bytes<32>, token0: CoinInfo, token1: CoinInfo): Pair {
    // TODO: I am not sure if the Coin.Color can be set to zero.
    // TODO: UPDATE that assert is paused because the tDust token is zero address color.
    // assert (!Utils_isKeyOrAddressZero(right<ZswapCoinPublicKey, ContractAddress>( ContractAddress { bytes: token0.color }))) "LunarswapFactory: Invalid token color";
    const pair = LunarswapPair_initializePair(pairId, token0, token1);
    pool.insert(pairId, pair);
    return pair;
  }

  /**
   * @title updatePair circuit
   * @description Updates an existing trading pair with new data.
   * 
   * @remarks
   * This circuit updates the pair data in the liquidity pool. The pair must already
   * exist for this operation to succeed.
   *
   * Requirements:
   * - The pair must already exist in the liquidity pool
   *
   * @circuitInfo k=11, rows=1000
   *
   * @param {Pair} pair     - The updated pair data.
   * @param {Bytes<32>} pairId          - The unique pairId hash of the pair.
   *
   * @throws {Error} "LunarswapFactory: updatePair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns {Pair} - The updated pair data.
   */
  export circuit updatePair(pairId: Bytes<32>, pair: Pair): Pair {
    assert(isIdentityExists(pairId), "LunarswapFactory: updatePair() - Pair does not exist");
    pool.insert(pairId, disclose(pair));
    return pair;
  }

  /**
   * @title removePair circuit
   * @description Removes a trading pair from the liquidity pool.
   * 
   * @remarks
   * This circuit removes a pair from the liquidity pool based on the pair's
   * token information. The pair must exist for this operation to succeed.
   *
   * Requirements:
   * - The pair must exist in the liquidity pool
   *
   * @circuitInfo k=11, rows=800
   *
   * @param {Pair} pair - The pair to remove.
   *
   * @throws {Error} "LunarswapFactory: removePair() - Pair does not exist" if the pair doesn't exist.
   *
   * @returns [] - No return values.
   */
  export circuit removePair(pair: Pair): [] {
    const pairId = LunarswapLibrary_getIdentity(pair.token0Type, pair.token1Type, true);
    assert(isIdentityExists(pairId), "LunarswapFactory: removePair() - Pair does not exist");
    return pool.remove(pairId);
  }
}

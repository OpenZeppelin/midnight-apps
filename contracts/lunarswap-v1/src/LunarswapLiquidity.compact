// SPDX-License-Identifier: MIT

pragma language_version >= 0.15.0;

/**
 * @title LunarswapLiquidity
 * @description Liquidity Provider (LP) token management system for the Lunarswap protocol.
 * 
 * @remarks
 * The LunarswapLiquidity module manages the creation, minting, burning, and tracking of liquidity
 * provider tokens. These tokens represent a user's share of liquidity in a trading pair and
 * entitle holders to a portion of trading fees and the underlying assets.
 * 
 * Key Features:
 * - LP token minting for liquidity providers
 * - LP token burning for liquidity removal
 * - Total supply tracking per trading pair
 * - Token metadata management (name, symbol, decimals)
 * - Nonce-based token generation
 * - UTXO-based token model
 */
module LunarswapLiquidity {
    import CompactStandardLibrary;

    import "./openzeppelin/ShieldedERC20" prefix ShieldedERC20_;
    import "./node_modules/@midnight-dapps/math-contracts/dist/Uint128" prefix Uint128_;

    /**
     * @ledger _counter
     * @description Internal counter for tracking LP token operations or unique identifiers.
     * @type {Counter}
     */
    export ledger _counter: Counter;

    /**
     * @ledger _nonce
     * @description Nonce value used for LP token generation and uniqueness.
     * @type {Bytes<32>}
     */
    export ledger _nonce: Bytes<32>;

    /**
     * @ledger _totalSupply
     * @description Mapping of trading pair identity hashes to their corresponding LP token total supply.
     *              The key is the pair hash (Bytes<32>), and the value is the QualifiedCoinInfo for that pair.
     * @type {Map<Bytes<32>, QualifiedCoinInfo>}
     */
    export ledger _totalSupply: Map<Bytes<32>, QualifiedCoinInfo>;

    /**
     * @sealed @ledger _name
     * @description The name of the LP token (e.g., "Lunarswap LP Token").
     * @type {Opaque<"string">}
     */
    export sealed ledger _name: Opaque<"string">;

    /**
     * @sealed @ledger _symbol
     * @description The symbol of the LP token (e.g., "LUNAR-LP").
     * @type {Opaque<"string">}
     */
    export sealed ledger _symbol: Opaque<"string">;

    /**
     * @sealed @ledger _decimals
     * @description The number of decimal places for the LP token.
     * @type {Uint<8>}
     */
    export sealed ledger _decimals: Uint<8>;


    /**
     * @title initialize circuit
     * @description Initializes the LP token system with basic configuration.
     * 
     * @remarks
     * This circuit sets up the initial configuration for LP tokens including name,
     * symbol, decimals, and nonce. It should only be called once during contract deployment.
     *
     * @param {Bytes<32>} nonce_      - The nonce for LP token generation.
     * @param {Opaque<"string">} name_ - The name of the LP token.
     * @param {Opaque<"string">} symbol_ - The symbol of the LP token.
     * @param {Uint<8>} decimals_     - The number of decimals for LP tokens.
     *
     * @returns [] - No return values.
     */
    export circuit initialize(
        nonce_: Bytes<32>,
        name_: Opaque<"string">,
        symbol_: Opaque<"string">,
        decimals_: Uint<8>
    ): [] {
        _nonce = nonce_;
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        return [];
    }

    /**
     * @title initializePairLiquidityToken circuit
     * @description Initializes LP token tracking for a new trading pair.
     * 
     * @remarks
     * This circuit sets up the total supply tracking for a new trading pair by
     * initializing the supply to zero in the total supply map.
     *
     * Requirements:
     * - The pair identity must not already have LP tokens initialized
     *
     * @param {Bytes<32>} identity - The unique identity hash of the trading pair.
     *
     * @throws {Error} "LunarswapLiquidity: initializePairLiquidityToken() - Lp token already exists" if LP tokens already exist for this pair.
     *
     * @returns [] - No return values.
     */
    export circuit initializePairLiquidityToken(identity: Bytes<32>): [] {
        assert (!_totalSupply.member(identity)) "LunarswapLiquidity: initializePairLiquidityToken() - Lp token already exists";
        _totalSupply.insert(identity, default<QualifiedCoinInfo>);
        return [];
    }

    /**
     * @title name circuit
     * @description Returns the name of the LP token.
     * 
     * @remarks
     * This circuit retrieves the configured name for liquidity provider tokens.
     *
     * @returns {Opaque<"string">} - The LP token name.
     */
    export circuit name(): Opaque<"string"> {
        return _name;
    }

    /**
     * @title symbol circuit
     * @description Returns the symbol of the LP token.
     * 
     * @remarks
     * This circuit retrieves the configured symbol for liquidity provider tokens.
     *
     * @returns {Opaque<"string">} - The LP token symbol.
     */
    export circuit symbol(): Opaque<"string"> {
        return _symbol;
    }

    /**
     * @title decimals circuit
     * @description Returns the number of decimals for LP tokens.
     * 
     * @remarks
     * This circuit retrieves the configured decimal places for liquidity provider tokens.
     *
     * @returns {Uint<8>} - The number of decimal places for LP tokens.
     */
    export circuit decimals(): Uint<8> {
        return _decimals;
    }

    /**
     * @title totalSupply circuit
     * @description Returns the total supply of LP tokens for a specific pair.
     * 
     * @remarks
     * This circuit retrieves the total supply of liquidity provider tokens for a given
     * trading pair identity.
     *
     * Requirements:
     * - The pair identity must have LP tokens initialized
     *
     * @param {Bytes<32>} identity - The unique identity hash of the trading pair.
     *
     * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
     *
     * @returns {Uint<128>} - The total supply of LP tokens for the pair.
     */
    export circuit totalSupply(identity: Bytes<32>): QualifiedCoinInfo {
        assert (_totalSupply.member(identity)) "LunarswapLiquidity: totalSupply() - Lp token not found";
        return _totalSupply.lookup(identity);
    }

    /**
     * @title mint circuit
     * @description Mints new LP tokens and sends them to the specified recipient.
     * 
     * @remarks
     * This circuit creates new LP tokens for a trading pair and sends them to the
     * specified recipient. It also updates the total supply for the pair.
     *
     * Requirements:
     * - The pair identity must have LP tokens initialized
     * - The amount must be greater than zero
     *
     * @param {Bytes<32>} identity - The unique identity hash of the trading pair.
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} recipient - The recipient of the minted LP tokens.
     * @param {Uint<128>} amount - The amount of LP tokens to mint.
     *
     * @returns {CoinInfo} - The minted LP token coin.
     */
    export circuit mint(
        identity: Bytes<32>,
        recipient: Either<ZswapCoinPublicKey, ContractAddress>,
        amount: Uint<128>
    ): CoinInfo {
        _counter.increment(1);
        const newNonce = evolve_nonce(_counter, _nonce);
        const ret = mint_token(identity, amount, newNonce, recipient);
        
        const newTotalSupply = QualifiedCoinInfo {
            nonce: ret.nonce,
            color: ret.color,
            value: Uint128_addChecked(_totalSupply.lookup(identity).value, amount),
            mt_index: _totalSupply.lookup(identity).mt_index,
        };
        _totalSupply.insert(identity, newTotalSupply);
        
        return ret;
    }

    /**
     * @title burn circuit
     * @description Burns LP tokens and returns the underlying assets.
     * 
     * @remarks
     * This circuit burns LP tokens by receiving them and updating the total supply.
     * The burned tokens are sent to the burn address, and any change is returned
     * to the contract's own address.
     *
     * Requirements:
     * - The coin value must be sufficient for the burn amount
     * - The pair identity must have LP tokens initialized
     *
     * @param {Bytes<32>} identity - The unique identity hash of the trading pair.
     * @param {CoinInfo} coin - The LP token coin to burn.
     * @param {Uint<128>} amount - The amount of LP tokens to burn.
     *
     * @throws {Error} "LunarswapLiquidity: burn() - Insufficient coin value" if coin value is less than burn amount.
     * @throws {Error} "LunarswapLiquidity: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
     *
     * @returns {SendResult} - The result of the burn operation including any change.
     */
    export circuit burn(
        identity: Bytes<32>, 
        coin: CoinInfo, 
        amount: Uint<128>
    ): SendResult {
        assert _totalSupply.member(identity) "LunarswapLiquidity: totalSupply() - Lp token not found";
        assert coin.value >= amount "LunarswapLiquidity: burn() - Insufficient coin value";

        receive(coin);
        
        const newTotalSupply = QualifiedCoinInfo {
            nonce: coin.nonce,
            color: coin.color,
            value: Uint128_sub(_totalSupply.lookup(identity).value, amount),
            mt_index: _totalSupply.lookup(identity).mt_index, // TODO: not sure if this is correct.
        };
        _totalSupply.insert(identity, newTotalSupply);
        
        const ret = send_immediate(coin, burn_address(), amount);
        if (ret.change.is_some) {
            const tmpAddr = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
            send_immediate(ret.change.value, tmpAddr, ret.change.value.value);
        }
        return ret;
    }
}

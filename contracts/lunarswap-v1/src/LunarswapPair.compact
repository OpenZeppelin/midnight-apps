pragma language_version >= 0.14.0;

/**
 * @title LunarswapPair
 * @description Core trading pair implementation for the Lunarswap protocol, handling liquidity provision and pair state management.
 * 
 * @remarks
 * The LunarswapPair module implements the core logic for individual trading pairs in the Lunarswap protocol.
 * It manages liquidity provision, LP token minting, fee collection, and maintains the pair's state including
 * reserves, cumulative price data, and trading statistics.
 * 
 * Key Features:
 * - Liquidity provision and LP token minting
 * - Protocol fee calculation and distribution
 * - Reserve management and updates
 * - Price oracle functionality through VWAP tracking
 * - Trading volume and price cumulative tracking
 */
module LunarswapPair {
    import CompactStandardLibrary;
    
    import "./openzeppelin/Utils";
    import "../node_modules/@midnight-dapps/math/dist/Uint128" prefix Uint128_;
    import "../node_modules/@midnight-dapps/math/dist/Max";
    
    import "./interfaces/ILunarswapPair";
    
    import LunarswapLibrary prefix LunarswapLibrary_;
    import LunarswapFee prefix LunarswapFee_;
    import LunarswapLiquidity prefix LunarswapLiquidity_;

    /**
     * @title initialize circuit
     * @description Initializes the Lunarswap pair system with LP token configuration.
     * 
     * @remarks
     * This circuit sets up the initial configuration for LP tokens including name,
     * symbol, decimals, and nonce. It should only be called once during contract deployment.
     *
     * TODO: access control needed. 
     * TODO: use initialize contract to prevent double initialize.
     *
     * @circuitInfo k=11, rows=1200
     *
     * @param {Bytes<32>} lpTokenNonce      - The nonce for LP token generation.
     * @param {Opaque<"string">} lpTokenName - The name of the LP token.
     * @param {Opaque<"string">} lpTokenSymbol - The symbol of the LP token.
     * @param {Uint<8>} lpTokenDecimals     - The number of decimals for LP tokens.
     *
     * @returns [] - No return values.
     */
    export circuit initialize(
        lpTokenNonce: Bytes<32>,
        lpTokenName: Opaque<"string">,
        lpTokenSymbol: Opaque<"string">,
        lpTokenDecimals: Uint<8>
    ): [] {
        return LunarswapLiquidity_initialize(lpTokenNonce, lpTokenName, lpTokenSymbol, lpTokenDecimals);
    } 

    /**
     * @title MINIMUM_LIQUIDITY circuit
     * @description Returns the minimum liquidity required for new pairs.
     * 
     * @remarks
     * This circuit defines the minimum amount of liquidity that must be provided
     * when creating a new trading pair. This prevents division by zero issues.
     *
     * @circuitInfo k=11, rows=100
     *
     * @returns {Uint<16>} - The minimum liquidity amount (1000).
     */
    circuit MINIMUM_LIQUIDITY(): Uint<16> {
        return 1000;
    }

    /**
     * @title initializePair circuit
     * @description Initializes a new trading pair with zero reserves.
     * 
     * @remarks
     * This circuit creates a new trading pair structure with zero reserves and
     * initializes the LP token tracking for the pair. The pair is ready to accept
     * the first liquidity provision.
     *
     * @circuitInfo k=11, rows=1000
     *
     * @param {Bytes<32>} identity - The unique identity hash for the new pair.
     * @param {CoinInfo} token0    - The first token in the pair.
     * @param {CoinInfo} token1    - The second token in the pair.
     *
     * @returns {Pair} - The initialized pair with zero reserves and metadata.
     */
    export circuit initializePair(identity: Bytes<32>, token0: CoinInfo, token1: CoinInfo): Pair {
        LunarswapLiquidity_initializePairLpToken(identity);
        return Pair {
            token0: QualifiedCoinInfo { nonce: token0.nonce, color: token0.color, value: 0, mt_index: 0 },
            token1: QualifiedCoinInfo { nonce: token1.nonce, color: token1.color, value: 0, mt_index: 0 },
            price0VolCumulative: 0,
            price1VolCumulative: 0,
            volume0Cumulative: 0,
            volume1Cumulative: 0,
            kLast: 0,
        };
    }

    /**
     * @title mint circuit
     * @description Mints LP tokens for liquidity providers and updates the pair state.
     * 
     * @remarks
     * This circuit handles the minting of LP tokens when liquidity is added to a pair.
     * For the first liquidity provision, it calculates liquidity based on the geometric
     * mean of the amounts. For subsequent provisions, it calculates liquidity based on
     * the minimum ratio of the provided amounts to existing reserves.
     *
     * Requirements:
     * - The calculated liquidity must be greater than zero
     * - The liquidity must not overflow MAX_UINT128
     *
     * @circuitInfo k=11, rows=3000
     *
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the LP tokens.
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Pair} pair - The current pair state.
     * @param {CoinInfo} token0 - The first token being added.
     * @param {CoinInfo} token1 - The second token being added.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     * @param {Uint<128>} amount0 - The amount of token0 being added.
     * @param {Uint<128>} amount1 - The amount of token1 being added.
     *
     * @throws {Error} "LunarswapPair: Insufficient liquidity minted" if calculated liquidity is zero.
     * @throws {Error} "Lunarswap: liquidity overflows MAX_U128 supported size in ERC20" if liquidity overflows.
     *
     * @returns {Pair} - The updated pair state with new reserves and metadata.
     */
    export circuit mint(
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        identity: Bytes<32>,
        pair: Pair,
        token0: CoinInfo,
        token1: CoinInfo,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        amount0: Uint<128>,
        amount1: Uint<128>
    ): Pair {
        // We use addChecked here because the max amount in CoinInfo is Uint<128>
        const balance0 = Uint128_addChecked(reserve0, amount0);
        const balance1 = Uint128_addChecked(reserve1, amount1);

        const [isFeeOn, kLast] = _mintFee(identity, reserve0, reserve1, pair.kLast);
        // TODO: review the risk of using totalSupply here. Because of the nature of UTXO that 
        // a user could send the LP tokens to the burn address directly without using the burn function, 
        // but the totalSupply will not be updated.
        const totalSupply = LunarswapLiquidity_totalSupply(identity).value;
        if (totalSupply == 0) {
            // liquidity = (√amount0 * amount1) - MINIMUM_LIQUIDITY = Uint<128>
            // TODO: review disclose
            const liquidity = Uint128_sub(
                disclose(Uint128_sqrt(Uint128_mulChecked(amount0, amount1))), 
                MINIMUM_LIQUIDITY()
            );
            assert(liquidity > 0) "LunarswapPair: Insufficient liquidity minted";
            LunarswapLiquidity_mint(identity, eitherZeroSenderAddress(), MINIMUM_LIQUIDITY());
            LunarswapLiquidity_mint(identity, to, liquidity);
            // For the initial mint, set the liquidity reserve to MINIMUM_LIQUIDITY() + liquidity
            // to reflect the total minted LP tokens (including the locked minimum).
            return _update(
                pair,
                isFeeOn,
                amount0,
                amount1,
                balance0,
                balance1,
                reserve0,
                reserve1,
                kLast
            );
        } else { 
            // TODO: In case of using Uint<128> for reserves that results a conflict with 
            // the ERC20 Compact standard, since the result here is Uint<256> while the max min tokens are Uint<128>
            // liquidity = ((amount0 * totalSupply / reserve0) ∧ ((amount1 * totalSupply) / reserve1) 
            const liquidity = Uint128_min(
                disclose(Uint128_div(Uint128_mulChecked(amount0, totalSupply), reserve0)),
                disclose(Uint128_div(Uint128_mulChecked(amount1, totalSupply), reserve1))
            ); 
            // TODO: that is TBD later in the future after doing benchmarks on the performance of MathU256
            assert (liquidity <= MAX_UINT128()) "LunarswapPair: liquidity overflows MAX_U128 supported size in ERC20";
            assert(liquidity > 0) "LunarswapPair: Insufficient liquidity minted";
            LunarswapLiquidity_mint(identity, to, liquidity);
            return _update(
                pair,
                isFeeOn,
                amount0,
                amount1,
                balance0,
                balance1,
                reserve0,
                reserve1,
                kLast
            );
        }
    }

    /**
     * @title _mintFee circuit
     * @description Calculates and mints protocol fees if enabled.
     * 
     * @remarks
     * This internal circuit calculates protocol fees based on the growth in the
     * constant product (k) since the last fee mint. If fees are enabled and the
     * current k is greater than kLast, it mints new LP tokens to the fee recipient.
     *
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     * @param {Uint<128>} kLast - The k value from the last fee calculation.
     *
     * @throws {Error} "Lunarswap: liquidity overflows MAX_U128 supported size in ERC20" if calculated liquidity overflows.
     *
     * @returns {[Boolean, Uint<128>]} - Whether fees are enabled and the updated kLast value.
     */
    circuit _mintFee(
        identity: Bytes<32>,
        reserve0: Uint<128>, 
        reserve1: Uint<128>, 
        kLast: Uint<128>
    ): [Boolean, Uint<128>] {
        const isFeeToZero = isKeyOrAddressZero(left<ZswapCoinPublicKey, ContractAddress>(LunarswapFee_feeTo()));
        const isFeeOn = isFeeToZero == true ? false : true;
        if (isFeeOn) {
            if (kLast != 0) {
                // TODO: review disclose
                const rootK = disclose(Uint128_sqrt(Uint128_mulChecked(reserve0, reserve1)));
                // TODO: review disclose
                const rootKLast = disclose(Uint128_sqrt(kLast));
                if (rootK > rootKLast) {
                    // TODO: review the security of the totalSupply.
                    const totalSupply = LunarswapLiquidity_totalSupply(identity).value;
                    const numerator = Uint128_mulChecked(Uint128_sub(rootK, rootKLast), totalSupply);
                    const denominator = Uint128_addChecked(Uint128_mulChecked(rootK, 5), rootKLast);
                    const liquidity = disclose(Uint128_div(numerator, denominator));
                    assert (liquidity <= MAX_UINT128()) "LunarswapPair: liquidity overflows MAX_U128 supported size in ERC20";
                    if (liquidity as Uint<128> > 0) {
                        // Mint Liquidity Tokens for the protocol fee recipient
                        LunarswapLiquidity_mint(identity, eitherZswapCoinPublicKey(LunarswapFee_feeTo()), liquidity as Uint<128>);
                    } 
                } 
            }   
            return [isFeeOn, kLast];
        } else {
            return [false, 0];
        }
    }

    /**
     * @title burn circuit
     * @description Burns LP tokens and distributes the underlying tokens to the liquidity provider.
     * 
     * @remarks
     * This circuit handles the burning of LP tokens when liquidity is removed from a pair.
     * 
     * @circuitInfo k=11, rows=2000
     *
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the burned tokens.
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Pair} pair - The current pair state.
     * @param {QualifiedCoinInfo} token0 - The first token in the pair.
     * @param {QualifiedCoinInfo} token1 - The second token in the pair.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     *
     * @returns {[Uint<128>, Uint<128>]} - The amounts of token0 and token1 returned.
     */
    export circuit burn(
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        identity: Bytes<32>,
        pair: Pair,
        liquidity: CoinInfo,
        token0: QualifiedCoinInfo,
        token1: QualifiedCoinInfo,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
    ): [Pair, Uint<128>, Uint<128>] {
        // Trying to keep with Uniswap's implementation, Originally you would check the balanceOf 
        // function for each token contract of that address. But here we don't have the token contract,
        // so we use the reserves as the balance because the tokens in the reserves are not 
        // transferred to the recipient yet.
        const balance0 = reserve0;
        const balance1 = reserve1;
        const totalSupply = LunarswapLiquidity_totalSupply(identity).value;

        const [isFeeOn, kLast] = _mintFee(identity, reserve0, reserve1, pair.kLast);
        // Call the internal _burn circuit and return its result
        return _burn(
            to,
            identity,
            pair,
            token0,
            token1,
            balance0,
            balance1,
            reserve0,
            reserve1,
            liquidity,
            totalSupply,
            isFeeOn,
            kLast
        );
    }

    /**
     * @title _burn circuit
     * @description Internal circuit that handles the common burn logic for liquidity removal.
     * 
     * @remarks
     * This internal circuit consolidates the common logic for burning LP tokens and
     * distributing the underlying tokens to the liquidity provider. It calculates
     * the amounts to return, burns the LP tokens, and sends the tokens to the recipient.
     *
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the burned tokens.
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Pair} pair - The current pair state.
     * @param {CoinInfo} token0 - The first token in the pair.
     * @param {CoinInfo} token1 - The second token in the pair.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     * @param {Uint<128>} liquidity - The liquidity amount to burn.
     * @param {Uint<128>} totalSupply - The total supply of LP tokens.
     * @param {Boolean} isFeeOn - Whether protocol fees are enabled.
     * @param {Uint<128>} kLast - The k value from the last fee calculation.
     *
     * @throws {Error} "LunarswapPair: burn() - Insufficient liquidity burned" if calculated amounts are zero.
     *
     * @returns {[Uint<128>, Uint<128>]} - The amounts of token0 and token1 returned.
     */
    circuit _burn(
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        identity: Bytes<32>,
        pair: Pair,
        token0: QualifiedCoinInfo,
        token1: QualifiedCoinInfo,
        balance0: Uint<128>,
        balance1: Uint<128>,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        liquidity: CoinInfo,
        totalSupply: Uint<128>,
        isFeeOn: Boolean,
        kLast: Uint<128>,
    ): [Pair, Uint<128>, Uint<128>] {
        // Early validation: Calculate expected amounts and validate reserves
        const amount0 = disclose(
            Uint128_div(
                Uint128_mulChecked(
                    liquidity.value,
                    balance0
                ),
                totalSupply
            )
        );
        const amount1 = disclose(
            Uint128_div(
                Uint128_mulChecked(
                    liquidity.value,
                    balance1
                ),
                totalSupply
            )
        );
        
        // Validate that calculated amounts are positive
        assert (amount0 > 0 && amount1 > 0) "LunarswapPair: burn() - Insufficient liquidity burned";
        
        // Early validation: Check if reserves are sufficient for the calculated amounts
        assert (reserve0 >= amount0) "LunarswapPair: burn() - Insufficient reserves for token0";
        assert (reserve1 >= amount1) "LunarswapPair: burn() - Insufficient reserves for token1";
        
        LunarswapLiquidity_burn(identity, liquidity, liquidity.value);

        // Only send the used amount of the token0 to the LP.
        const splitToken0 = LunarswapLibrary_splitQualifiedCoin(token0, amount0);
        if (splitToken0.used.value > 0) {
            send(splitToken0.used, to, splitToken0.used.value);
        }

        // Only send the used amount of the token1 to the LP.
        const splitToken1 = LunarswapLibrary_splitQualifiedCoin(token1, amount1);
        if (splitToken1.used.value > 0) {
            send(splitToken1.used, to, splitToken1.used.value);
        }

        {
            const amount0 = splitToken0.used.value;
            const amount1 = splitToken1.used.value;
            const balance0 = Uint128_sub(reserve0, amount0);
            const balance1 = Uint128_sub(reserve1, amount1);
            
            const updatedPair = _update(
                pair,
                isFeeOn,
                amount0,
                amount1,
                balance0,
                balance1,
                reserve0,
                reserve1,
                kLast
            );
            return [updatedPair, amount0, amount1];
        }
    }

    // TODO: support flash swap that requires contracts to contracts calls.
    export circuit swap(
        identity: Bytes<32>,
        pair: Pair,
        balance0: Uint<128>,
        balance1: Uint<128>,
        amount0Out: Uint<128>,
        amount1Out: Uint<128>,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        to: Either<ZswapCoinPublicKey, ContractAddress>,
    ): Pair {
        assert (amount0Out > 0 || amount1Out > 0) "LunarswapPair: swap() - Insufficient output amount";
        assert (amount0Out < reserve0 && amount1Out < reserve1) "LunarswapPair: swap() - Insufficient liquidity";
        
        // Send the output tokens to the recipient
        if (amount0Out > 0) {
            const outputQualifiedCoin = QualifiedCoinInfo {
                nonce: pair.token0.nonce,
                color: pair.token0.color,
                value: amount0Out,
                mt_index: pair.token0.mt_index,
            };
            send(outputQualifiedCoin, to, amount0Out); 
        } else if (amount1Out > 0) {
            const outputQualifiedCoin = QualifiedCoinInfo {
                nonce: pair.token1.nonce,
                color: pair.token1.color,
                value: amount1Out,
                mt_index: pair.token1.mt_index,
            };
            send(outputQualifiedCoin, to, amount1Out);
        }

        const updatedBalance0 = amount0Out > 0 ? Uint128_sub(balance0, amount0Out) : balance0;
        const updatedBalance1 = amount1Out > 0 ? Uint128_sub(balance1, amount1Out) : balance1;

        const amount0In = updatedBalance0 > Uint128_sub(reserve0, amount0Out) ? Uint128_sub(updatedBalance0, Uint128_sub(reserve0, amount0Out)) : 0;
        const amount1In = updatedBalance1 > Uint128_sub(reserve1, amount1Out) ? Uint128_sub(updatedBalance1, Uint128_sub(reserve1, amount1Out)) : 0;

        assert (amount0In > 0 || amount1In > 0) "LunarswapPair: swap() - Insufficient input amount";

        const balance0Adjusted = Uint128_sub(Uint128_mulChecked(updatedBalance0, 1000), Uint128_mulChecked(amount0In, 3));
        const balance1Adjusted = Uint128_sub(Uint128_mulChecked(updatedBalance1, 1000), Uint128_mulChecked(amount1In, 3));

        assert (
            Uint128_mulChecked(balance0Adjusted, balance1Adjusted)
                >=
            Uint128_mulChecked(
                Uint128_mulChecked(reserve0, reserve1),
                1000000 // 1000 ** 2
            )
        ) "LunarswapPair: swap() - k";

        return _update(pair, false, amount0In, amount1In, updatedBalance0, updatedBalance1, reserve0, reserve1, pair.kLast);
    }

    /**
     * @title _update circuit
     * @description Updates the pair state with new balances, metadata, and cumulative statistics.
     * 
     * @remarks
     * This internal circuit combines the functionality of _updatePairPrice and _updatePair
     * to provide a single interface for updating pair state. It updates cumulative price
     * and volume data, then creates a new pair state with the updated values.
     *
     * @param {Pair} pair           - The current pair state.
     * @param {Boolean} isFeeOn     - Whether protocol fees are enabled.
     * @param {Uint<128>} amount0In - The amount of token0 added.
     * @param {Uint<128>} amount1In - The amount of token1 added.
     * @param {Uint<128>} liquidity  - The new liquidity amount.
     * @param {Uint<128>} balance0   - The new balance of token0.
     * @param {Uint<128>} balance1   - The new balance of token1.
     * @param {Uint<128>} reserve0   - The current reserve of token0.
     * @param {Uint<128>} reserve1   - The current reserve of token1.
     * @param {Uint<128>} kLast      - The k value from the last fee calculation.
     *
     * @returns {Pair} - The updated pair state.
     */
    circuit _update(
        pair: Pair,
        isFeeOn: Boolean,
        amount0In: Uint<128>,
        amount1In: Uint<128>,
        balance0: Uint<128>,
        balance1: Uint<128>,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        kLast: Uint<128>,
    ): Pair {
        const [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative] =
            _updatePairPrice(
                pair,
                reserve0,
                reserve1,
                amount0In,
                amount1In
            );
        const [updatedToken0, updatedToken1] = _updateReserve(pair.token0, pair.token1, balance0, balance1);
        const updatedKLast = _updateKLast(isFeeOn, updatedToken0.value, updatedToken1.value);
        return _updatePair(
            pair,
            updatedToken0,
            updatedToken1,
            price0VolCumulative,
            price1VolCumulative,
            volume0Cumulative,
            volume1Cumulative,
            updatedKLast
        );
    }

    /**
     * @title _updatePairPrice circuit
     * @description Updates cumulative price and volume data for the pair.
     * 
     * @remarks
     * This internal circuit updates the cumulative price and volume statistics
     * for the trading pair using VWAP (Volume Weighted Average Price). 
     * These values are used for price oracle functionality and tracking trading activity.
     *
     * @param {Pair} pair         - The current pair state.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     * @param {Uint<128>} amount0In - The amount of token0 being traded in.
     * @param {Uint<128>} amount1In - The amount of token1 being traded in.
     *
     * @returns {[Uint<128>, Uint<128>, Uint<128>, Uint<128>]} - Updated cumulativalus [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative].
     */
    circuit _updatePairPrice(
        pair: Pair,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        amount0In: Uint<128>,
        amount1In: Uint<128>,
    ): [Uint<128>, Uint<128>, Uint<128>, Uint<128>] {
        if (reserve0 != 0 && reserve1 != 0) {
            const price0 = disclose(Uint128_div(reserve1, reserve0));
            const price1 = disclose(Uint128_div(reserve0, reserve1));

            const price0VolCumulative = Uint128_addChecked(pair.price0VolCumulative, Uint128_mulChecked(price0, amount0In));
            const price1VolCumulative = Uint128_addChecked(pair.price1VolCumulative, Uint128_mulChecked(price1, amount1In));

            const volume0Cumulative = Uint128_addChecked(pair.volume0Cumulative, amount0In);
            const volume1Cumulative = Uint128_addChecked(pair.volume1Cumulative, amount1In);
            
            return [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative];
        } else {
            return [pair.price0VolCumulative, pair.price1VolCumulative, pair.volume0Cumulative, pair.volume1Cumulative];
        }
    }

    /**
     * @title _updateReserve circuit
     * @description Updates the QualifiedCoinInfo for both tokens with new reserve values.
     * 
     * @remarks
     * This internal circuit calculates the updated QualifiedCoinInfo for both tokens
     * by adding the specified amounts to their current values. This is used to update
     * the pair's token reserves when liquidity is added or removed.
     *
     * @param {QualifiedCoinInfo} token0 - The current QualifiedCoinInfo for token0.
     * @param {QualifiedCoinInfo} token1 - The current QualifiedCoinInfo for token1.
     * @param {Uint<128>} balance0 - The new balance of token0.
     * @param {Uint<128>} balance1 - The new balance of token1.
     *
     * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - The updated QualifiedCoinInfo for token0 and token1.
     */
    circuit _updateReserve(
        token0: QualifiedCoinInfo,
        token1: QualifiedCoinInfo,
        balance0: Uint<128>,
        balance1: Uint<128>,
    ): [QualifiedCoinInfo, QualifiedCoinInfo] {
        return [QualifiedCoinInfo {
            nonce: token0.nonce,
            color: token0.color,
            value: balance0,
            mt_index: token0.mt_index,
        }, QualifiedCoinInfo {
            nonce: token1.nonce,
            color: token1.color,
            value: balance1,
            mt_index: token1.mt_index,
        }];
    }

    /**
     * @title _updateKLast circuit
     * @description Updates the kLast value for fee calculation.
     * 
     * @remarks
     * This internal circuit calculates the new kLast value based on whether fees
     * are enabled. If fees are enabled, kLast is set to the product of balances;
     * otherwise, it's set to zero.
     *
     * @param {Boolean} isFeeOn   - Whether protocol fees are enabled.
     * @param {Uint<128>} reserve0 - The reserve of token0.
     * @param {Uint<128>} reserve1 - The reserve of token1.
     *
     * @returns {Uint<128>} - The updated kLast value.
     */
    circuit _updateKLast(
        isFeeOn: Boolean,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
    ): Uint<128> {
        return isFeeOn ? Uint128_mulChecked(reserve0, reserve1) : 0;
    } 

    /**
     * @title _updatePair circuit
     * @description Updates the pair state with new balances and metadata.
     * 
     * @remarks
     * This internal circuit creates a new pair state by updating the token balances,
     * liquidity, and cumulative statistics based on the provided parameters.
     *
     * @param {Pair} pair                    - The current pair state.
     * @param {Boolean} isFeeOn              - Whether protocol fees are enabled.
     * @param {Uint<128>} balance0           - The new balance of token0.
     * @param {Uint<128>} balance1           - The new balance of token1.
     * @param {Uint<128>} amount0In          - The amount of token0 added.
     * @param {Uint<128>} amount1In          - The amount of token1 added.
     * @param {Uint<128>} liquidity          - The liquidity amount to add.
     * @param {Uint<128>} price0VolCumulative - The updated price0 volume cumulative.
     * @param {Uint<128>} price1VolCumulative - The updated price1 volume cumulative.
     * @param {Uint<128>} volume0Cumulative  - The updated volume0 cumulative.
     * @param {Uint<128>} volume1Cumulative  - The updated volume1 cumulative.
     * @param {Uint<128>} kLast              - The updated kLast value.
     *
     * @returns {Pair} - The updated pair state.
     */
    circuit _updatePair(
        pair: Pair,
        updatedToken0: QualifiedCoinInfo,
        updatedToken1: QualifiedCoinInfo,
        price0VolCumulative: Uint<128>,
        price1VolCumulative: Uint<128>,
        volume0Cumulative: Uint<128>,
        volume1Cumulative: Uint<128>,
        kLast: Uint<128>,
    ): Pair {
        return Pair {
            token0: updatedToken0,
            token1: updatedToken1,
            price0VolCumulative: price0VolCumulative,
            price1VolCumulative: price1VolCumulative,
            volume0Cumulative: volume0Cumulative,
            volume1Cumulative: volume1Cumulative,
            kLast: kLast,
        };
    } 
}

pragma language_version >= 0.14.0;

/**
 * @title LunarswapPair
 * @description Core trading pair implementation for the Lunarswap protocol, handling liquidity provision and pair state management.
 * 
 * @remarks
 * The LunarswapPair module implements the core logic for individual trading pairs in the Lunarswap protocol.
 * It manages liquidity provision, LP token minting, fee collection, and maintains the pair's state including
 * reserves, cumulative price data, and trading statistics.
 * 
 * Key Features:
 * - Liquidity provision and LP token minting
 * - Protocol fee calculation and distribution
 * - Reserve management and updates
 * - Price oracle functionality through VWAP tracking
 * - Trading volume and price cumulative tracking
 */
module LunarswapPair {
    import CompactStandardLibrary;
    
    import "./openzeppelin/Utils";
    import "../node_modules/@midnight-dapps/math/dist/Uint128" prefix Uint128_;
    import "../node_modules/@midnight-dapps/math/dist/Max";
    
    import "./interfaces/ILunarswapPair";
    
    import LunarswapLibrary prefix LunarswapLibrary_;
    import LunarswapFee prefix LunarswapFee_;
    import LunarswapLiquidity prefix LunarswapLiquidity_;

    /**
     * @title initialize circuit
     * @description Initializes the Lunarswap pair system with LP token configuration.
     * 
     * @remarks
     * This circuit sets up the initial configuration for LP tokens including name,
     * symbol, decimals, and nonce. It should only be called once during contract deployment.
     *
     * TODO: access control needed. 
     * TODO: use initialize contract to prevent double initialize.
     *
     * @circuitInfo k=11, rows=1200
     *
     * @param {Bytes<32>} lpTokenNonce      - The nonce for LP token generation.
     * @param {Opaque<"string">} lpTokenName - The name of the LP token.
     * @param {Opaque<"string">} lpTokenSymbol - The symbol of the LP token.
     * @param {Uint<8>} lpTokenDecimals     - The number of decimals for LP tokens.
     *
     * @returns [] - No return values.
     */
    export circuit initialize(
        lpTokenNonce: Bytes<32>,
        lpTokenName: Opaque<"string">,
        lpTokenSymbol: Opaque<"string">,
        lpTokenDecimals: Uint<8>
    ): [] {
        return LunarswapLiquidity_initialize(lpTokenNonce, lpTokenName, lpTokenSymbol, lpTokenDecimals);
    } 

    /**
     * @title MINIMUM_LIQUIDITY circuit
     * @description Returns the minimum liquidity that is always locked in the pool to prevent share inflation attacks.
     * 
     * @remarks
     * This circuit defines the minimum amount of LP tokens (liquidity) that must be permanently locked in every new trading pair.
     * 
     * This mechanism directly mitigates the "share inflation attack" (see [OpenZeppelin: Inflation Attack](https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack))
     * as originally described in the [Uniswap v2 Whitepaper, Section 5.2](https://app.uniswap.org/whitepaper.pdf#subsection.5.2).
     * See also the Uniswap v2 code implementation: [UniswapV2Pair.sol#L77-L87](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L77-L87).
     * 
     * **Attack Prevention Mechanism:**
     * By locking a small, nonzero amount of LP shares, the cost of manipulating the pool's share value is
     * dramatically increased. This makes it economically infeasible for an attacker to inflate the value of
     * a single share by donating assets to the pool, as the minimum liquidity is
     * forever unclaimable and must be "burned" to the zero address.
     * 
     * **Decimal System Adaptation:**
     * The original Uniswap v2 implementation uses 1000 for Ethereum's 18-decimal system, representing
     * 1e-15 of a single LP token (1000 / 1e18 = 1e-15). For Midnight's 6-decimal system, we use 1,
     * which represents 1e-6 of a single LP token (1 / 1e6 = 1e-6).
     * 
     * **Value Selection Rationale:**
     * The value 1 is chosen because:
     * 1. It maintains the same proportional security as Uniswap v2 (very small fraction of total supply)
     * 2. It's negligible for honest liquidity providers (0.0001% of a token)
     * 3. It's large enough to make share inflation attacks prohibitively expensive
     * 4. It's appropriate for Midnight's token precision and economic scale
     * 
     * **Cross-Platform Equivalence:**
     * - Ethereum (18 decimals): 1000 represents 1e-15 of a token
     * - Midnight (6 decimals): 1 represents 1e-6 of a token
     * Both values serve the same security purpose while being appropriately scaled for their respective ecosystems.
     *
     * @circuitInfo k=11, rows=100
     *
     * @returns {Uint<16>} - The minimum liquidity amount (1), permanently locked to mitigate share inflation attacks.
     */
    circuit MINIMUM_LIQUIDITY(): Uint<16> {
        return 1;
    }

    /**
     * @title initializePair circuit
     * @description Initializes a new trading pair with zero reserves.
     * 
     * @remarks
     * This circuit creates a new trading pair structure with zero reserves and
     * initializes the LP token tracking for the pair. The pair is ready to accept
     * the first liquidity provision.
     *
     * @circuitInfo k=11, rows=1000
     *
     * @param {Bytes<32>} identity - The unique identity hash for the new pair.
     *
     * @returns {Pair} - The initialized pair with zero reserves and metadata.
     */
    export circuit initializePair(identity: Bytes<32>): Pair {
        LunarswapLiquidity_initializePairLpToken(identity);
        return Pair {
            token0Type: default<Bytes<32>>,
            token1Type: default<Bytes<32>>,
            price0VolCumulative: default<Uint<128>>,
            price1VolCumulative: default<Uint<128>>,
            volume0Cumulative: default<Uint<128>>,
            volume1Cumulative: default<Uint<128>>,
            kLast: default<Uint<128>>,
        };
    }

    /**
     * @title mint circuit
     * @description Mints LP tokens for liquidity providers and updates the pair state.
     * 
     * @remarks
     * This circuit handles the minting of LP tokens when liquidity is added to a pair.
     * For the first liquidity provision, it calculates liquidity based on the geometric
     * mean of the amounts. For subsequent provisions, it calculates liquidity based on
     * the minimum ratio of the provided amounts to existing reserves.
     *
     * @security
     * WARNING: This circuit is known to have a vulnerability to inflation attacks if the minimum liquidity
     * is not properly locked or if users can bypass the intended minting logic. Care must be taken to ensure
     * that the minimum liquidity is permanently locked and cannot be withdrawn, and that all minting flows
     * are strictly enforced.
     *
     * Requirements:
     * - The calculated liquidity must be greater than zero
     * - The liquidity must not overflow MAX_UINT128
     *
     * @circuitInfo k=11, rows=3000
     *
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the LP tokens.
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Pair} pair - The current pair state.
     * @param {Uint<128>} amount0 - The amount of token0 being added.
     * @param {Uint<128>} amount1 - The amount of token1 being added.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     * @param {CoinInfo} token0 - The first token being added.
     * @param {CoinInfo} token1 - The second token being added.
     *
     * @throws {Error} "LunarswapPair: Insufficient liquidity minted" if calculated liquidity is zero.
     * @throws {Error} "Lunarswap: liquidity overflows MAX_U128 supported size in ERC20" if liquidity overflows.
     *
     * @returns {[Pair, Uint<128>]} - The updated pair, liquidity minted.
     */
    export circuit mint(
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        identity: Bytes<32>,
        pair: Pair,
        amount0: Uint<128>,
        amount1: Uint<128>,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
    ): [Pair, Uint<128>] {
        // We use addChecked here because the max amount in CoinInfo is Uint<128>
        const balance0 = Uint128_addChecked(reserve0, amount0);
        const balance1 = Uint128_addChecked(reserve1, amount1);

        const [isFeeOn, kLast] = _mintFee(identity, reserve0, reserve1, pair.kLast);
        // TODO: review the risk of using totalSupply here. Because of the nature of UTXO that 
        // a user could send the LP tokens to the burn address directly without using the burn function, 
        // but the totalSupply will not be updated.
        const totalSupply = LunarswapLiquidity_totalSupply(identity).value;
        if (totalSupply == 0) {
            // liquidity = (√amount0 * amount1) - MINIMUM_LIQUIDITY = Uint<128>
            // TODO: review disclose
            const liquidity = Uint128_sub(
                disclose(Uint128_sqrt(Uint128_mulChecked(amount0, amount1))), 
                MINIMUM_LIQUIDITY()
            );
            assert(liquidity > 0) "LunarswapPair: New pair Insufficient liquidity minted";
            // TODO: WARNING! to be revised to prevent from inflation attack.
            // LunarswapLiquidity_mint(identity, burn_address(), MINIMUM_LIQUIDITY());
            LunarswapLiquidity_mint(identity, to, liquidity);
            // Send the minimum liquidity to the contract address itself to lock the minimum liquidity
            // send_immediate(minLiquidityCoinInfo, burn_address(), MINIMUM_LIQUIDITY());

            const updatedPair = _update(
                pair,
                isFeeOn,
                amount0,
                amount1,
                balance0,
                balance1,
                reserve0,
                reserve1,
                kLast
            );
            return [updatedPair, liquidity];
        } else { 
            // TODO: In case of using Uint<128> for reserves that results a conflict with 
            // the ERC20 Compact standard, since the result here is Uint<256> while the max min tokens are Uint<128>
            // liquidity = ((amount0 * totalSupply / reserve0) ∧ ((amount1 * totalSupply) / reserve1) 
            const liquidity = Uint128_min(
                disclose(Uint128_div(Uint128_mulChecked(amount0, totalSupply), reserve0)),
                disclose(Uint128_div(Uint128_mulChecked(amount1, totalSupply), reserve1))
            ); 
            // TODO: that is TBD later in the future after doing benchmarks on the performance of MathU256
            assert (liquidity <= MAX_UINT128()) "LunarswapPair: liquidity overflows MAX_U128 supported size in ERC20";
            assert(liquidity > 0) "LunarswapPair: Existing pair Insufficient liquidity minted";
            LunarswapLiquidity_mint(identity, to, liquidity);
            const updatedPair = _update(
                pair,
                isFeeOn,
                amount0,
                amount1,
                balance0,
                balance1,
                reserve0,
                reserve1,
                kLast
            );
            return [updatedPair, liquidity];
        }
    }

    /**
     * @title _mintFee circuit
     * @description Calculates and mints protocol fees if enabled.
     * 
     * @remarks
     * This internal circuit calculates protocol fees based on the growth in the
     * constant product (k) since the last fee mint. If fees are enabled and the
     * current k is greater than kLast, it mints new LP tokens to the fee recipient.
     *
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     * @param {Uint<128>} kLast - The k value from the last fee calculation.
     *
     * @throws {Error} "Lunarswap: liquidity overflows MAX_U128 supported size in ERC20" if calculated liquidity overflows.
     *
     * @returns {[Boolean, Uint<128>]} - Whether fees are enabled and the updated kLast value.
     */
    circuit _mintFee(
        identity: Bytes<32>,
        reserve0: Uint<128>, 
        reserve1: Uint<128>, 
        kLast: Uint<128>
    ): [Boolean, Uint<128>] {
        const isFeeToZero = isKeyOrAddressZero(left<ZswapCoinPublicKey, ContractAddress>(LunarswapFee_feeTo()));
        const isFeeOn = isFeeToZero == true ? false : true;
        if (isFeeOn) {
            if (kLast != 0) {
                // TODO: review disclose
                const rootK = disclose(Uint128_sqrt(Uint128_mulChecked(reserve0, reserve1)));
                // TODO: review disclose
                const rootKLast = disclose(Uint128_sqrt(kLast));
                if (rootK > rootKLast) {
                    // TODO: review the security of the totalSupply.
                    const totalSupply = LunarswapLiquidity_totalSupply(identity).value;
                    const numerator = Uint128_mulChecked(Uint128_sub(rootK, rootKLast), totalSupply);
                    const denominator = Uint128_addChecked(Uint128_mulChecked(rootK, 5), rootKLast);
                    const liquidity = disclose(Uint128_div(numerator, denominator));
                    assert (liquidity <= MAX_UINT128()) "LunarswapPair: liquidity overflows MAX_U128 supported size in ERC20";
                    if (liquidity as Uint<128> > 0) {
                        // Mint Liquidity Tokens for the protocol fee recipient
                        LunarswapLiquidity_mint(identity, eitherZswapCoinPublicKey(LunarswapFee_feeTo()), liquidity as Uint<128>);
                    } 
                } 
            }   
            return [isFeeOn, kLast];
        } else {
            return [false, 0];
        }
    }

    /**
     * @title burn circuit
     * @description Burns LP tokens and distributes the underlying tokens to the liquidity provider.
     * 
     * @remarks
     * This circuit handles the burning of LP tokens when liquidity is removed from a pair.
     * 
     * @circuitInfo k=11, rows=2000
     *
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the burned tokens.
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Pair} pair - The current pair state.
     * @param {Bytes<32>} token0Type - The first token in the pair.
     * @param {Bytes<32>} token1Type - The second token in the pair.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     *
     * @returns {[Pair, Uint<128>, Uint<128>]} - The updated pair, token0, token1.
     */
    export circuit burn(
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        identity: Bytes<32>,
        pair: Pair,
        liquidity: CoinInfo,
        token0Type: Bytes<32>,
        token1Type: Bytes<32>,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
    ): [Pair, Uint<128>, Uint<128>] {
        // Trying to keep with Uniswap's implementation, Originally you would check the balanceOf 
        // function for each token contract of that address. But here we don't have the token contract,
        // so we use the reserves as the balance because the tokens in the reserves are not 
        // transferred to the recipient yet.
        const balance0 = reserve0;
        const balance1 = reserve1;
        const totalSupply = LunarswapLiquidity_totalSupply(identity).value;

        const [isFeeOn, kLast] = _mintFee(identity, reserve0, reserve1, pair.kLast);
        // Call the internal _burn circuit and return its result
        return _burn(
            to,
            identity,
            pair,
            token0Type,
            token1Type,
            balance0,
            balance1,
            reserve0,
            reserve1,
            liquidity,
            totalSupply,
            isFeeOn,
            kLast
        );
    }

    /**
     * @title _burn circuit
     * @description Internal circuit that handles the common burn logic for liquidity removal.
     * 
     * @remarks
     * This internal circuit consolidates the common logic for burning LP tokens and
     * distributing the underlying tokens to the liquidity provider. It calculates
     * the amounts to return, burns the LP tokens, and sends the tokens to the recipient.
     *
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the burned tokens.
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Pair} pair - The current pair state.
     * @param {Bytes<32>} token0Type - The first token in the pair.
     * @param {Bytes<32>} token1Type - The second token in the pair.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     * @param {Uint<128>} liquidity - The liquidity amount to burn.
     * @param {Uint<128>} totalSupply - The total supply of LP tokens.
     * @param {Boolean} isFeeOn - Whether protocol fees are enabled.
     * @param {Uint<128>} kLast - The k value from the last fee calculation.
     *
     * @throws {Error} "LunarswapPair: burn() - Insufficient liquidity burned" if calculated amounts are zero.
     *
     * @returns {[Uint<128>, Uint<128>]} - The amounts of token0 and token1 returned.
     */
    circuit _burn(
        to: Either<ZswapCoinPublicKey, ContractAddress>,
        identity: Bytes<32>,
        pair: Pair,
        token0Type: Bytes<32>,
        token1Type: Bytes<32>,
        balance0: Uint<128>,
        balance1: Uint<128>,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        liquidity: CoinInfo,
        totalSupply: Uint<128>,
        isFeeOn: Boolean,
        kLast: Uint<128>,
    ): [Pair, Uint<128>, Uint<128>] {
        // Early validation: Calculate expected amounts and validate reserves
        const amount0 = disclose(
            Uint128_div(
                Uint128_mulChecked(
                    liquidity.value,
                    balance0
                ),
                totalSupply
            )
        );
        const amount1 = disclose(
            Uint128_div(
                Uint128_mulChecked(
                    liquidity.value,
                    balance1
                ),
                totalSupply
            )
        );
        
        // Validate that calculated amounts are positive
        assert (amount0 > 0 && amount1 > 0) "LunarswapPair: burn() - Insufficient liquidity burned";
        
        // Early validation: Check if reserves are sufficient for the calculated amounts
        assert (reserve0 >= amount0) "LunarswapPair: burn() - Insufficient reserves for token0";
        assert (reserve1 >= amount1) "LunarswapPair: burn() - Insufficient reserves for token1";
        
        LunarswapLiquidity_burn(identity, liquidity, liquidity.value);

        // Only send the used amount of the token0 to the LP.
        // const splitToken0 = LunarswapLibrary_splitQualifiedCoin(token0, amount0);
        // if (splitToken0.used.value > 0) {
        //     send(splitToken0.used, to, splitToken0.used.value);
        // }

        // Only send the used amount of the token1 to the LP.
        // const splitToken1 = LunarswapLibrary_splitQualifiedCoin(token1, amount1);
        // if (splitToken1.used.value > 0) {
        //     send(splitToken1.used, to, splitToken1.used.value);
        // }

        {
            const balance0 = Uint128_sub(reserve0, amount0);
            const balance1 = Uint128_sub(reserve1, amount1);
            
            const updatedPair = _update(
                pair,
                isFeeOn,
                amount0,
                amount1,
                balance0,
                balance1,
                reserve0,
                reserve1,
                kLast
            );
            return [updatedPair, amount0, amount1];
        }
    }

    // TODO: support flash swap that requires contracts to contracts calls.
    export circuit swap(
        identity: Bytes<32>,
        pair: Pair,
        balance0: Uint<128>,
        balance1: Uint<128>,
        amount0Out: Uint<128>,
        amount1Out: Uint<128>,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        to: Either<ZswapCoinPublicKey, ContractAddress>,
    ): Pair {
        assert (amount0Out > 0 || amount1Out > 0) "LunarswapPair: swap() - Insufficient output amount";
        assert (amount0Out < reserve0 && amount1Out < reserve1) "LunarswapPair: swap() - Insufficient liquidity";
        
        // Send the output tokens to the recipient
        if (amount0Out > 0) { 
            send(pair.token0, to, amount0Out); 
        } else if (amount1Out > 0) {
            send(pair.token1, to, amount1Out);
        }

        const updatedBalance0 = amount0Out > 0 ? Uint128_sub(balance0, amount0Out) : balance0;
        const updatedBalance1 = amount1Out > 0 ? Uint128_sub(balance1, amount1Out) : balance1;

        const amount0In = updatedBalance0 > Uint128_sub(reserve0, amount0Out) ? Uint128_sub(updatedBalance0, Uint128_sub(reserve0, amount0Out)) : 0;
        const amount1In = updatedBalance1 > Uint128_sub(reserve1, amount1Out) ? Uint128_sub(updatedBalance1, Uint128_sub(reserve1, amount1Out)) : 0;

        assert (amount0In > 0 || amount1In > 0) "LunarswapPair: swap() - Insufficient input amount";

        const balance0Adjusted = Uint128_sub(Uint128_mulChecked(updatedBalance0, 1000), Uint128_mulChecked(amount0In, 3));
        const balance1Adjusted = Uint128_sub(Uint128_mulChecked(updatedBalance1, 1000), Uint128_mulChecked(amount1In, 3));

        assert (
            Uint128_mulChecked(balance0Adjusted, balance1Adjusted)
                >=
            Uint128_mulChecked(
                Uint128_mulChecked(reserve0, reserve1),
                1000000 // 1000 ** 2
            )
        ) "LunarswapPair: swap() - k";

        return _update(pair, false, amount0In, amount1In, updatedBalance0, updatedBalance1, reserve0, reserve1, pair.kLast);
    }

    /**
     * @title _update circuit
     * @description Updates the pair state with new balances, metadata, and cumulative statistics.
     * 
     * @remarks
     * This internal circuit combines the functionality of _updatePairPrice and _updatePair
     * to provide a single interface for updating pair state. It updates cumulative price
     * and volume data, then creates a new pair state with the updated values.
     *
     * @param {Pair} pair           - The current pair state.
     * @param {Boolean} isFeeOn     - Whether protocol fees are enabled.
     * @param {CoinInfo} token0 - The first token being added.
     * @param {CoinInfo} token1 - The second token being added.
     * @param {Uint<128>} liquidity  - The new liquidity amount.
     * @param {Uint<128>} balance0   - The new balance of token0.
     * @param {Uint<128>} balance1   - The new balance of token1.
     * @param {Uint<128>} reserve0   - The current reserve of token0.
     * @param {Uint<128>} reserve1   - The current reserve of token1.
     * @param {Uint<128>} kLast      - The k value from the last fee calculation.
     *
     * @returns {Pair} - The updated pair state.
     */
    circuit _update(
        pair: Pair,
        isFeeOn: Boolean,
        amount0In: Uint<128>,
        amount1In: Uint<128>,
        balance0: Uint<128>,
        balance1: Uint<128>,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        kLast: Uint<128>,
    ): Pair {
        const [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative] =
            _updatePairPrice(
                pair,
                reserve0,
                reserve1,
                amount0In,
                amount1In
            );
        const updatedKLast = isFeeOn ? Uint128_mulChecked(balance0, balance1) : 0;
        return Pair {
            token0Type: pair.token0Type,
            token1Type: pair.token1Type,
            price0VolCumulative: price0VolCumulative,
            price1VolCumulative: price1VolCumulative,
            volume0Cumulative: volume0Cumulative,
            volume1Cumulative: volume1Cumulative,
            kLast: updatedKLast,
        };
    }

    /**
     * @title _updatePairPrice circuit
     * @description Updates cumulative price and volume data for the pair.
     * 
     * @remarks
     * This internal circuit updates the cumulative price and volume statistics
     * for the trading pair using VWAP (Volume Weighted Average Price). 
     * These values are used for price oracle functionality and tracking trading activity.
     *
     * @param {Pair} pair         - The current pair state.
     * @param {Uint<128>} reserve0 - The current reserve of token0.
     * @param {Uint<128>} reserve1 - The current reserve of token1.
     * @param {Uint<128>} amount0In - The amount of token0 being traded in.
     * @param {Uint<128>} amount1In - The amount of token1 being traded in.
     *
     * @returns {[Uint<128>, Uint<128>, Uint<128>, Uint<128>]} - Updated cumulativalus [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative].
     */
    circuit _updatePairPrice(
        pair: Pair,
        reserve0: Uint<128>,
        reserve1: Uint<128>,
        amount0In: Uint<128>,
        amount1In: Uint<128>,
    ): [Uint<128>, Uint<128>, Uint<128>, Uint<128>] {
        if (reserve0 != 0 && reserve1 != 0) {
            const price0 = disclose(Uint128_div(reserve1, reserve0));
            const price1 = disclose(Uint128_div(reserve0, reserve1));

            const price0VolCumulative = Uint128_addChecked(pair.price0VolCumulative, Uint128_mulChecked(price0, amount0In));
            const price1VolCumulative = Uint128_addChecked(pair.price1VolCumulative, Uint128_mulChecked(price1, amount1In));

            const volume0Cumulative = Uint128_addChecked(pair.volume0Cumulative, amount0In);
            const volume1Cumulative = Uint128_addChecked(pair.volume1Cumulative, amount1In);
            
            return [price0VolCumulative, price1VolCumulative, volume0Cumulative, volume1Cumulative];
        } else {
            return [pair.price0VolCumulative, pair.price1VolCumulative, pair.volume0Cumulative, pair.volume1Cumulative];
        }
    }
}

pragma language_version >= 0.15.0;

/**
 * @title LunarswapLpTokens
 * @description Liquidity Provider (LP) token management system for the Lunarswap protocol.
 * 
 * @remarks
 * The LunarswapLpTokens module manages the creation, minting, burning, and tracking of liquidity
 * provider tokens. These tokens represent a user's share of liquidity in a trading pair and
 * entitle holders to a portion of trading fees and the underlying assets.
 * 
 * Key Features:
 * - LP token minting for liquidity providers
 * - LP token burning for liquidity removal
 * - Total supply tracking per trading pair
 * - Token metadata management (name, symbol, decimals)
 * - Nonce-based token generation
 * - UTXO-based token model
 */
module LunarswapLpTokens {
    import CompactStandardLibrary;

    import "./openzeppelin/ShieldedERC20" prefix ShieldedERC20_;
    import "./node_modules/@midnight-dapps/math-contracts/dist/MathU128";

    export ledger _counter: Counter;
    export ledger _nonce: Bytes<32>;
    // That is a map of all the liquidity LP tokens, the key is the pair hash.
    export ledger _totalSupply: Map<Bytes<32>, Uint<128>>;
    export sealed ledger _name: Opaque<"string">;
    export sealed ledger _symbol: Opaque<"string">;
    export sealed ledger _decimals: Uint<8>;


    /**
     * @title initialize circuit
     * @description Initializes the LP token system with basic configuration.
     * 
     * @remarks
     * This circuit sets up the initial configuration for LP tokens including name,
     * symbol, decimals, and nonce. It should only be called once during contract deployment.
     *
     * @circuitInfo k=11, rows=800
     *
     * @param {Bytes<32>} nonce_      - The nonce for LP token generation.
     * @param {Opaque<"string">} name_ - The name of the LP token.
     * @param {Opaque<"string">} symbol_ - The symbol of the LP token.
     * @param {Uint<8>} decimals_     - The number of decimals for LP tokens.
     *
     * @returns [] - No return values.
     */
    export circuit initialize(
        nonce_: Bytes<32>,
        name_: Opaque<"string">,
        symbol_: Opaque<"string">,
        decimals_: Uint<8>
    ): [] {
        _nonce = nonce_;
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        return [];
    }

    /**
     * @title initializePairLpToken circuit
     * @description Initializes LP token tracking for a new trading pair.
     * 
     * @remarks
     * This circuit sets up the total supply tracking for a new trading pair by
     * initializing the supply to zero in the total supply map.
     *
     * Requirements:
     * - The pair identity must not already have LP tokens initialized
     *
     * @circuitInfo k=11, rows=600
     *
     * @param {Bytes<32>} identity - The unique identity hash of the trading pair.
     *
     * @throws {Error} "LunarswapLpTokens: initializePairLpToken() - Lp token already exists" if LP tokens already exist for this pair.
     *
     * @returns [] - No return values.
     */
    export circuit initializePairLpToken(identity: Bytes<32>): [] {
        assert (!_totalSupply.member(identity)) "LunarswapLpTokens: initializePairLpToken() - Lp token already exists";
        _totalSupply.insert(identity, 0);
        return [];
    }

    /**
     * @title name circuit
     * @description Returns the name of the LP token.
     * 
     * @remarks
     * This circuit retrieves the configured name for liquidity provider tokens.
     *
     * @circuitInfo k=11, rows=200
     *
     * @returns {Opaque<"string">} - The LP token name.
     */
    export circuit name(): Opaque<"string"> {
        return _name;
    }

    /**
     * @title symbol circuit
     * @description Returns the symbol of the LP token.
     * 
     * @remarks
     * This circuit retrieves the configured symbol for liquidity provider tokens.
     *
     * @circuitInfo k=11, rows=200
     *
     * @returns {Opaque<"string">} - The LP token symbol.
     */
    export circuit symbol(): Opaque<"string"> {
        return _symbol;
    }

    /**
     * @title decimals circuit
     * @description Returns the number of decimals for LP tokens.
     * 
     * @remarks
     * This circuit retrieves the configured decimal places for liquidity provider tokens.
     *
     * @circuitInfo k=11, rows=200
     *
     * @returns {Uint<8>} - The number of decimal places for LP tokens.
     */
    export circuit decimals(): Uint<8> {
        return _decimals;
    }

    /**
     * @title totalSupply circuit
     * @description Returns the total supply of LP tokens for a specific pair.
     * 
     * @remarks
     * This circuit retrieves the total supply of liquidity provider tokens for a given
     * trading pair identity.
     *
     * Requirements:
     * - The pair identity must have LP tokens initialized
     *
     * @circuitInfo k=11, rows=400
     *
     * @param {Bytes<32>} identity - The unique identity hash of the trading pair.
     *
     * @throws {Error} "LunarswapLpTokens: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
     *
     * @returns {Uint<128>} - The total supply of LP tokens for the pair.
     */
    export circuit totalSupply(identity: Bytes<32>): Uint<128> {
        assert (_totalSupply.member(identity)) "LunarswapLpTokens: totalSupply() - Lp token not found";
        return _totalSupply.lookup(identity);
    }
    
    /**
     * @title mint circuit
     * @description Mints new LP tokens and sends them to the specified recipient.
     * 
     * @remarks
     * This circuit creates new LP tokens for a trading pair and sends them to the
     * specified recipient. It also updates the total supply for the pair.
     *
     * Requirements:
     * - The pair identity must have LP tokens initialized
     * - The amount must be greater than zero
     *
     * @circuitInfo k=11, rows=1500
     *
     * @param {Bytes<32>} identity - The unique identity hash of the trading pair.
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} recipient - The recipient of the minted LP tokens.
     * @param {Uint<128>} amount - The amount of LP tokens to mint.
     *
     * @throws {Error} "LunarswapLpTokens: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
     *
     * @returns {CoinInfo} - The minted LP token coin.
     */
    export circuit mint(identity: Bytes<32>, recipient: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<128>): CoinInfo {
        _counter.increment(1);
        const newNonce = evolve_nonce(_counter, _nonce);
        const ret = mint_token(identity, amount, newNonce, recipient);
        const newTotalSupply = addChecked(_totalSupply.lookup(identity), amount);
        _totalSupply.insert(identity, newTotalSupply);
        return ret;
    }

    /**
     * @title burn circuit
     * @description Burns LP tokens and returns the underlying assets.
     * 
     * @remarks
     * This circuit burns LP tokens by receiving them and updating the total supply.
     * The burned tokens are sent to the burn address, and any change is returned
     * to the contract's own address.
     *
     * Requirements:
     * - The coin value must be sufficient for the burn amount
     * - The pair identity must have LP tokens initialized
     *
     * @circuitInfo k=11, rows=1800
     *
     * @param {Bytes<32>} identity - The unique identity hash of the trading pair.
     * @param {CoinInfo} coin - The LP token coin to burn.
     * @param {Uint<128>} amount - The amount of LP tokens to burn.
     *
     * @throws {Error} "LunarswapLpTokens: burn() - Insufficient coin value" if coin value is less than burn amount.
     * @throws {Error} "LunarswapLpTokens: totalSupply() - Lp token not found" if LP tokens don't exist for this pair.
     *
     * @returns {SendResult} - The result of the burn operation including any change.
     */
    export circuit burn(identity: Bytes<32>, coin: CoinInfo, amount: Uint<128>): SendResult {
        assert coin.value >= amount "LunarswapLpTokens: burn() - Insufficient coin value";

        receive(coin);
        const newTotalSupply = sub(_totalSupply.lookup(identity), amount);
        _totalSupply.insert(identity, newTotalSupply);
        const ret = send_immediate(coin, burn_address(), amount);
        if (ret.change.is_some) {
            const tmpAddr = left<ZswapCoinPublicKey, ContractAddress>(own_public_key());
            send_immediate(ret.change.value, tmpAddr, ret.change.value.value);
        }
        return ret;
    }
}

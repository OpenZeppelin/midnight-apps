// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

/**
 * @description A utility module providing mathematical operations for unsigned integers. Most functions operate on
 * `Uint<64>` values in the range [0, 2^64 - 1], while the `sqrt` function accepts a `Uint<128>` input in the range
 * [0, 2^128 - 1]. The module supports arithmetic, division, square root, and utility functions with overflow and
 * underflow checks where applicable.
 *
 * Supported Mathematical Operations:
 * - Division:
 *   - div(): Computes the quotient of dividing one `Uint<64>` number by another.
 *   - rem(): Computes the remainder of dividing one `Uint<64>` number by another.
 * - Square Root:
 *   - sqrt(): Computes the floor of the square root of a `Uint<128>` number using the Newton-Raphson method.
 * - Utility:
 *   - isMultiple(): Checks if one `Uint<64>` number is a multiple of another.
 *   - min(): Returns the smaller of two `Uint<64>` numbers.
 *   - max(): Returns the larger of two `Uint<64>` numbers.
 */
module MathU64 {
    import CompactStandardLibrary;

    import "./interfaces/IMathU64";

    import Max prefix Max_; 

    /**
     * @description Internal circuit to divide a Uint<64> number by another, returning quotient and remainder.
     *
     * Theoretical Description:
     * This circuit computes the quotient and remainder of dividing a 64-bit unsigned integer a by another b,
     * both represented as Uint<64> values in [0, 2^64 - 1]. It returns a DivResultU64 struct containing the
     * quotient and remainder, satisfying a = quotient * b + remainder, where 0 <= remainder < b.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If b = 0, throw "Math: division by zero".
     *    - Else if a = 0, return { quotient: 0, remainder: 0 }.
     *    - Else if b = 1, return { quotient: a, remainder: 0 }.
     *    - Else if a = b, return { quotient: 1, remainder: 0 }.
     *    - Else if a < b, return { quotient: 0, remainder: a }.
     * 2. Division Computation:
     *    - Compute result = (quotient, remainder) using divU64Locally, where quotient = floor(a / b)
     *      and remainder = a mod b.
     * 3. Verification:
     *    - Assert remainder < b, ensuring 0 <= remainder < b.
     *    - Assert quotient * b + remainder = a, ensuring correctness.
     * 4. Result:
     *    - Return DivResultU64 { quotient, remainder }.
     *
     * @param a The Uint<64> value to divide (dividend).
     * @param b The Uint<64> value to divide by (divisor).
     * @returns DivResultU64 A struct containing the quotient and remainder as Uint<64> values.
     * @throws Math: division by zero If b is zero.
     * @throws Math: remainder error If remainder is not less than b.
     * @throws Math: division invalid If quotient * b + remainder does not equal a.
     */
    circuit _div(a: Uint<64>, b: Uint<64>): DivResultU64 {
        assert b != 0 "Math: division by zero";
        if (a == 0) {
            return DivResultU64 { quotient: 0 as Uint<64>, remainder: 0 as Uint<64> };
        } else if (b == 1) {
            return DivResultU64 { quotient: a, remainder: 0 as Uint<64> };
        } else if (a == b) {
            return DivResultU64 { quotient: 1 as Uint<64>, remainder: 0 as Uint<64> };
        } else if (a < b) {
            return DivResultU64 { quotient: 0 as Uint<64>, remainder: a };
        } else {
            const result = divU64Locally(a, b);
            assert (result.remainder < b) "Math: remainder error";
            assert ((result.quotient * b + result.remainder) as Uint<64> == a) "Math: division invalid";
            return result;
        }
    }

    /**
     * @description Divides a `Uint<64>` number `a` by `b`, returning the quotient.
     * @param a - The unsigned 64-bit integer to divide (dividend).
     * @param b - The unsigned 64-bit integer to divide by (divisor).
     * @returns The quotient of `a` divided by `b` as a `Uint<64>` value.
     * @throws If `b` is zero, causing division by zero.
     * @throws If the division result is invalid or the remainder is not less than `b`.
     */
    export circuit div(a: Uint<64>, b: Uint<64>): Uint<64> {
        return _div(a, b).quotient; 
    }

    /**
     * @description Computes the remainder of dividing a `Uint<64>` number `a` by `b`.
     * @param a - The unsigned 64-bit integer to divide (dividend).
     * @param b - The unsigned 64-bit integer to divide by (divisor).
     * @returns The remainder of `a` divided by `b` as a `Uint<64>` value.
     * @throws If `b` is zero, causing division by zero.
     * @throws If the division result is invalid or the remainder is not less than `b`.
     */
    export circuit rem(a: Uint<64>, b: Uint<64>): Uint<64> {
        return _div(a, b).remainder;
    }

    /**
     * @description Divides a Uint<64> number by another, returning both quotient and remainder.
     * @param a The Uint<64> value to divide (dividend).
     * @param b The Uint<64> value to divide by (divisor).
     * @returns DivResultU64 A struct containing the quotient and remainder as Uint<64> values.
     * @throws Math: division by zero If b is zero.
     * @throws Math: remainder error If remainder is not less than b.
     * @throws Math: division invalid If quotient * b + remainder does not equal a.
     */
    export circuit divRem(a: Uint<64>, b: Uint<64>): DivResultU64 {
        return _div(a, b);
    }

    /**
     * @description Computes the floor of the square root of a Uint<64> value.
     *
     * Theoretical Description:
     * This circuit calculates the floor of the square root R = floor(sqrt(N)) of a 64-bit unsigned integer
     * N, provided as a Uint<64> value in [0, 2^64 - 1]. The result is a Uint<32> value R in [0, 2^32 - 1],
     * such that R^2 <= N < (R + 1)^2. It uses a witness-based approach for the general case and includes
     * special cases for common inputs to optimize performance.
     *
     * Mathematical Steps:
     * 1. General Case Computation:
     *    - Compute R = floor(sqrt(N)) using sqrtLocally, where R is in [0, 2^32 - 1].
     * 2. Root Verification:
     *    - Compute rootSquare = R * R using mul.
     *    - Assert rootSquare <= N, ensuring R^2 <= N.
     * 3. Next Value Verification:
     *    - Compute next = R + 1, where next is in [1, 2^32].
     *    - Compute nextSquare = next * next using mul.
     *    - Assert nextSquare > N, ensuring (R + 1)^2 > N.
     * 4. Result:
     *    - Return R as Uint<32>.
     *
     * @param radicand The Uint<64> value to compute the square root of.
     * @returns Uint<32> The floor of the square root of radicand.
     * @throws Math: sqrt overestimate If R^2 > radicand.
     * @throws Math: sqrt underestimate If (R + 1)^2 <= radicand.
     */
    export circuit sqrt(radicand: Uint<64>): Uint<32> {
        const root = sqrtU64Locally(radicand);
        const rootSquare = root * root;
        assert (rootSquare <= radicand) "Math: sqrt overestimate";
        
        const next = root + 1;
        const nextSquare = next * next;
        assert (nextSquare > radicand) "Math: sqrt underestimate";
        
        return root;
    }

    /**
     * @description Checks if a `Uint<64>` number is a multiple of another.
     * @param value - The unsigned 64-bit integer to check.
     * @param b - The unsigned 64-bit integer divisor.
     * @returns `true` if `value` is a multiple of `b`, `false` otherwise.
     * @throws If `b` is zero, causing division by zero.
     */
    export circuit isMultiple(value: Uint<64>, b: Uint<64>): Boolean {
        return rem(value, b) == 0;
    }

    /**
     * @description Returns the minimum of two `Uint<64>` values.
     * @param a - The first unsigned 64-bit integer.
     * @param b - The second unsigned 64-bit integer.
     * @returns The smaller of `a` and `b` as a `Uint<64>` value.
     */
    export circuit min(a: Uint<64>, b: Uint<64>): Uint<64> {
        return a < b ? a : b;
    }

    /**
     * @description Returns the maximum of two `Uint<64>` values.
     * @param a - The first unsigned 64-bit integer.
     * @param b - The second unsigned 64-bit integer.
     * @returns The larger of `a` and `b` as a `Uint<64>` value.
     */
    export circuit max(a: Uint<64>, b: Uint<64>): Uint<64> {
        return a > b ? a : b;
    }
}

// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

/**
 * @description A utility module providing mathematical operations for 256-bit unsigned integers
 * using the U256 struct, which represents numbers as high * 2^128 + low, where high and low are
 * 128-bit unsigned integers (Uint<128>) in [0, 2^128 - 1]. The module supports a range of
 * operations including conversions, comparisons, arithmetic, division, square root, and utility
 * functions. Operations are provided in dual forms: 
 * one for Uint<256> inputs with conversions to/from U256, and another for direct U256 inputs.
 *
 * Supported Mathematical Operations:
 * - Conversions:
 *   - toU256(): Converts a Uint<256> to a U256 struct by splitting into high and low 128-bit parts.
 *   - fromU256(): Converts a U256 struct to a Uint<256> by combining high and low parts.
 * - Comparisons:
 *   - le(), leU256(): Checks if one 256-bit number is less than another.
 *   - gt(), gtU256(): Checks if one 256-bit number is greater than another.
 * - Arithmetic:
 *   - add(), addU256(): Adds two 256-bit numbers, checking for overflow.
 *   - sub(), subU256(): Subtracts one 256-bit number from another, checking for underflow.
 *   - mul(), mulU256(): Multiplies two 256-bit numbers, checking for overflow.
 * - Division:
 *   - div(), divU256(): Computes the quotient of dividing one 256-bit number by another.
 *   - rem(), remU256(): Computes the remainder of dividing one 256-bit number by another.
 * - Square Root:
 *   - sqrt(), sqrtU256(): Computes the floor of the square root of a 256-bit number, with special cases
 *     for efficiency.
 * - Utility:
 *   - min(), minU256:() Returns the smaller of two 256-bit numbers.
 *   - max(), maxU256(): Returns the larger of two 256-bit numbers.
 *   - isMultiple(), isMultipleU256(): Checks if one 256-bit number is a multiple of another.
 * 
 * TODO: Future Operations:
 * - pow(), powU256(): Compute the power of a 256-bit number raised to a given exponent.
 * - fromU256(), toU256(): Needs support of Uint<256> type.
 *
 * @module MathU256
 */
module MathU256 {
    import CompactStandardLibrary;
    
    import "./interfaces/IUint256";
    import "./interfaces/IMathU256";

    import Max prefix Max_;
    import Math prefix Math_;

    /**
     * @description A pure circuit that returns the modulus value of U256.
     *
     * @returns None
     */
    export pure circuit MODULUS(): Field {
        // pow() is not supported yet so we hardcode this value.
        // Uint256_MODULUS as a modulus value
        return 340282366920938463463374607431768211456;
    }

    /**
     * @description Compares two U256 values to check if a < b.
     *
     * Theoretical Description:
     * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
     * B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1], to determine if A < B. It performs a lexicographical
     * comparison by checking the high parts first, then the low parts if the high parts are
     * equal, returning true if A < B, false otherwise. No arithmetic operations are performed,
     * only comparisons and logical operations (OR, AND).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns Boolean True if a < b, false otherwise.
     */
    export circuit le(a: U256, b: U256): Boolean {
        return a.high < b.high || (a.high == b.high && a.low < b.low);
    }

    /**
     * @description Compares two U256 values to check if a > b.
     *
     * Theoretical Description:
     * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
     * B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1], to determine if A > B. It performs a lexicographical
     * comparison by checking the high parts first, then the low parts if the high parts are
     * equal, returning true if A > B, false otherwise. No arithmetic operations are performed,
     * only comparisons and logical operations (OR, AND).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns Boolean True if a > b, false otherwise.
     */
    export circuit gt(a: U256, b: U256): Boolean {
        return a.high > b.high || (a.high == b.high && a.low > b.low);
    }

    /**
     * @description Adds two U256 values, checking for overflow.
     *
     * Theoretical Description:
     * This circuit computes the sum S = A + B of two 256-bit numbers represented as U256 structs,
     * where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low, and
     * a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a U256
     * struct {low: S mod 2^128, high: floor(S / 2^128)}.
     *
     * Mathematical Steps:
     * 1. Low Part Addition:
     *    - Compute lowSum = a.low + b.low, where a.low, b.low are in
     *      [0, 2^128 - 1], so lowSum is in [0, 2^129 - 2].
     *    - Split lowSum into carry = floor(lowSum / 2^128) (0 or 1) and
     *      lowResult = lowSum mod 2^128.
     * 2. High Part Addition with Carry:
     *    - Compute highSum = a.high + b.high + carry, where a.high,
     *      b.high are in [0, 2^128 - 1] and carry is 0 or 1, so highSum is in
     *      [0, 2^129 - 1].
     * 3. Overflow Check:
     *    - Ensure S = highSum * 2^128 + lowResult <= 2^256 - 1.
     *    - Assert highSum <= 2^128 - 1 by checking floor(highSum / 2^128) = 0.
     *    - If false, S > (2^128 - 1) * 2^128 + (2^128 - 1) = 2^256 - 1, throw
     *      "MathU256: addition overflow".
     * 4. Construct Result:
     *    - Return U256 {low: lowResult, high: highSum}, representing
     *      S = highSum * 2^128 + lowResult.
     *
     * @param a The first U256 value to add.
     * @param b The second U256 value to add.
     * @returns U256 The sum of a and b.
     * @throws MathU256: addition overflow If the sum exceeds 2^256 - 1.
     */
    export circuit add(a: U256, b: U256): U256 {
        // Add the low parts as Uint<256> to handle potential carry
        const lowSumFull = a.low + b.low;
        
        // Split lowSumFull into high and low parts to get the carry
        const lowSumFullU256 = U256 {
            low: lowSumFull as Uint<128>,
            high: 0 as Uint<128>
        };
        const carry = lowSumFullU256.high; // 0 or 1, since lowSumFull <= 2^129 - 2
        
        // Add the high parts plus the carry
        const highSumIntermediate = a.high + b.high;
        const highSumFull = highSumIntermediate + carry;
        
        // Check for overflow: highSumFull must fit in 128 bits (i.e., highSumFull.high == 0)
        const highSumFullU256 = toU256(highSumFull);
        assert (highSumFullU256.high == 0) "MathU256: addition overflow";
        
        return U256 {
            low: lowSumFullU256.low,
            high: highSumFullU256.low
        };
    }

    /**
     * @description Subtracts one U256 value from another, checking for underflow.
     *
     * Theoretical Description:
     * This circuit computes the difference D = A - B of two 256-bit numbers represented as U256
     * structs, where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low,
     * and a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a
     * U256 struct {low: D mod 2^128, high: floor(D / 2^128)}.
     *
     * Mathematical Steps:
     * 1. Check for Underflow:
     *    - Assert A >= B (i.e., not A < B) using le.
     *    - If false, D < 0, throw "MathU256: subtraction underflow".
     * 2. Low Part Subtraction:
     *    - Compute borrow = 1 if a.low < b.low, else 0.
     *    - If a.low >= b.low, compute lowDiff = a.low - b.low.
     *    - Else, compute lowDiff = a.low + 2^128 - b.low, ensuring
     *      lowDiff is in [0, 2^128 - 1] via modular arithmetic.
     * 3. High Part Subtraction with Borrow:
     *    - Compute highDiff = a.high - b.high - borrow.
     * 4. Construct Result:
     *    - Return U256 {low: lowDiff, high: highDiff}, representing
     *      D = highDiff * 2^128 + lowDiff.
     * The underflow check ensures D >= 0, and the result is in [0, 2^256 - 1].
     *
     * @param a The U256 value to subtract from (minuend).
     * @param b The U256 value to subtract (subtrahend).
     * @returns U256 The difference between a and b.
     */
    export circuit sub(a: U256, b: U256): U256 {
        // Check for underflow: a must be >= b
        assert (!le(a, b)) "MathU256: subtraction underflow";
        
        // Handle low part subtraction with borrow
        const borrow = a.low < b.low ? 1 as Uint<128> : 0 as Uint<128>;
        const highWithBorrow = b.high + borrow;
        const highDiff = a.high - highWithBorrow;
        
        // TODO: change to ternary expression after this bug is resolved: https://github.com/midnightntwrk/compactc/issues/982 
        if (borrow == 0) {
            const lowDiff = a.low - b.low;
            return U256 {
                low: lowDiff,
                high: highDiff
            };
        } else {
            const lowDiff = a.low + Uint256_MODULUS() - b.low;
            return U256 {
                low: lowDiff as Uint<128>,
                high: highDiff
            };
        }
    }

   
    /**
     * @description Multiply two U256 values, checking for overflow.
     *
     * Theoretical Description:
     * This circuit computes the product P = A * B of two 256-bit numbers represented as U256
     * structs, where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low,
     * and a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a
     * U256 struct {low: P mod 2^128, high: floor(P / 2^128)}, ensuring P <= 2^256 - 1.
     *
     * Mathematical Steps:
     * 1. Compute Partial Products:
     *    - Represent A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low.
     *    - Compute four partial products using Math_mul (128-bit to 256-bit multiplication):
     *      ll = a.low * b.low (bits 0-255)
     *      hl = a.high * b.low (bits 128-383)
     *      lh = a.low * b.high (bits 128-383)
     *      hh = a.high * b.high (bits 256-511)
     *    - Each partial product is a Uint<256> in [0, (2^128 - 1)^2].
     * 2. Convert Partial Products to U256:
     *    - Convert each partial product to a U256 struct using toU256:
     *      llU256 = {low: ll mod 2^128, high: floor(ll / 2^128)}
     *      Similarly for hlU256, lhU256, hhU256.
     * 3. Combine Partial Products:
     *    - Add partial products with proper bit alignment using _add:
     *      - crossSum = _add(hlU256, lhU256) (sum of middle terms, bits 128-383)
     *      - crossShifted = {low: 0, high: crossSum.low} (align to bits 128-255)
     *      - lowAndCross = _add(llU256, crossShifted) (add low and middle terms)
     *      - crossCarry = {low: crossSum.high, high: 0} (carry to bits 256-383)
     *      - hhShiftedU256 = _add({low: hhU256.low, high: hhU256.high}, crossCarry)
     *        (align hh and add carry)
     *      - resultU256 = _add(lowAndCross, hhShiftedU256) (final sum)
     * 4. Overflow Check:
     *    - Ensure P = resultU256.high * 2^128 + resultU256.low <= 2^256 - 1.
     *    - Assert hhShiftedU256.low = 0 and hhShiftedU256.high = 0, ensuring bits
     *      256-511 are zero.
     *    - If false, P > 2^256 - 1, throw "MathU256: multiplication overflow".
     *    - Additional check: resultU256.high < 2^128 - 1 or (resultU256.high = 2^128 - 1
     *      and resultU256.low <= 2^128 - 1).
     * 5. Return Result:
     *    - Return resultU256 as a U256 struct.
     *
     * @param a The first U256 value to multiply.
     * @param b The second U256 value to multiply.
     * @returns U256 The product of a and b.
     * @throws MathU256: multiplication overflow If the product exceeds 2^256 - 1.
     */
    export circuit mul(a: U256, b: U256): U256 {
        // Compute partial products
        const ll = Math_mul(a.low, b.low);
        const hl = Math_mul(a.high, b.low);
        const lh = Math_mul(a.low, b.high);
        const hh = Math_mul(a.high, b.high);
        
        // Convert to U256 structs
        const llU256 = toU256(ll);
        const hlU256 = toU256(hl);
        const lhU256 = toU256(lh);
        const hhU256 = toU256(hh);
        
        // Combine contributions
        const crossSum = _add(hlU256, lhU256);
        const crossShifted = U256 { low: 0 as Uint<128>, high: crossSum.low };
        const lowAndCross = _add(llU256, crossShifted);
        const crossCarry = U256 { low: crossSum.high, high: 0 as Uint<128> };
        const hhShiftedU256 = _add(U256 { low: hhU256.low, high: hhU256.high }, crossCarry);
        const resultU256 = _add(lowAndCross, hhShiftedU256);
        
        // Check for overflow: upper 256 bits (bits 256-511) must be zero
        assert (hhShiftedU256.low == 0 && hhShiftedU256.high == 0) "MathU256: multiplication overflow";
        
        // Additional check to ensure result fits within Max_U256
        assert (
            resultU256.high < Max_U128() || 
            (resultU256.high == Max_U128() && resultU256.low <= Max_U128())
        ) "MathU256: multiplication overflow";
        
        return resultU256;
    }

    /**
     * @description Internal implementation to divide a U256 dividend by a U256 divisor, returning quotient and remainder.
     *
     * Theoretical Description:
     * This circuit computes the quotient quot and remainder rem of dividing a 256-bit number
     * divd = dividend.high * 2^128 + dividend.low by another 256-bit number
     * divs = divisor.high * 2^128 + divisor.low, where dividend.high, dividend.low,
     * divisor.high, divisor.low are in [0, 2^128 - 1]. The result is a DivResultU256 struct
     * containing quot and rem as U256 structs, satisfying divd = quot * divs + rem with
     * 0 <= rem < divs.
     *
     * Mathematical Steps:
     * 1. Check for Division by Zero:
     *    - Assert divs != 0 (i.e., divisor.high > 0 or divisor.low > 0).
     * 2. Convert Inputs to Uint<256>:
     *    - Compute divd_Uint256 = dividend.high * 2^128 + dividend.low using fromU256.
     *    - Compute divs_Uint256 = divisor.high * 2^128 + divisor.low using fromU256.
     * 3. Compute Division:
     *    - Use a division witness (divU256Locally) to compute quot_Uint256 = floor(divd / divs)
     *      and rem_Uint256 = divd mod divs, both as Uint<256> values.
     * 4. Convert Results to U256:
     *    - Convert quot_Uint256 and rem_Uint256 to U256 structs: quotientU256, remainderU256.
     * 5. Verify Remainder:
     *    - Assert remainderU256 < divisor using le, ensuring rem < divs.
     * 6. Verify Correctness:
     *    - Compute P = quot * divs using _mul.
     *    - Compute S = P + rem using _add.
     *    - Assert S.high = dividend.high and S.low = dividend.low, ensuring
     *      S = divd.
     * 7. Return Result:
     *    - Return DivResultU256 {quotient: quotientU256, remainder: remainderU256}.
     * The operations include division, modulus, multiplication, addition, comparison, and
     * conversion.
     *
     * @param dividend The U256 value to divide.
     * @param divisor The U256 value to divide by.
     * @returns DivResultU256 The quotient and remainder of the division as U256 structs.
     */
    circuit _div(dividend: U256, divisor: U256): DivResultU256 {
        assert (divisor.high > 0 || divisor.low > 0) "MathU256: division by zero";
        
        const dividendUint256 = fromU256(dividend);
        const divisorUint256 = fromU256(divisor);
        const result = divU256Locally(dividendUint256, divisorUint256);
        
        // Compare remainder < divisor using high and low parts
        const remainderU256 = result.remainder;
        assert (le(remainderU256, divisor)) "MathU256: remainder error";

        // Verify: quotient * divisor + remainder == dividend
        const quotientU256 = result.quotient;
        const product = _mul(quotientU256, divisor);
        const sum = _add(product, remainderU256);
        
        assert (
            sum.high == dividend.high &&
            sum.low == dividend.low
        ) "MathU256: division invalid";

        return result;
    }

    /**
     * @description Divides a U256 dividend by a U256 divisor, returning quotient.
     *
     * @param dividend The U256 value to divide.
     * @param divisor The U256 value to divide by.
     * @returns U256 The quotient of the division.
     */
    export circuit div(dividend: U256, divisor: U256): U256 {
        return _div(dividend, divisor).quotient;
    }

    /**
     * @description Computes the remainder of dividing a U256 dividend by a U256 divisor.
     *
     * @param dividend The U256 value to divide.
     * @param divisor The U256 value to divide by.
     * @returns U256 The remainder of the division.
     */
    export circuit rem(dividend: U256, divisor: U256): U256 {
        return _div(dividend, divisor).remainder;
    }

    /**
     * @description Computes the square root of a U256 value, verified on-chain.
     *
     * Theoretical Description:
     * This circuit computes the floor of the square root R = floor(sqrt(N)) of a 256-bit number
     * N = radicand.high * 2^128 + radicand.low, where radicand.high, radicand.low are in
     * [0, 2^128 - 1]. The result is a Uint<128> value R in [0, 2^128 - 1]. It uses the
     * Newton-Raphson method via a witness and includes special cases for efficiency.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If N = 0 (radicand.high = 0, radicand.low = 0), return 0.
     *    - If N = 1 (radicand.high = 0, radicand.low = 1), return 1.
     *    - If N = 2^8 - 1 (radicand.high = 0, radicand.low = Max_U8), return 15.
     *    - If N = 2^16 - 1 (radicand.high = 0, radicand.low = Max_U16), return 255.
     *    - If N = 2^32 - 1 (radicand.high = 0, radicand.low = Max_U32), return 65535.
     *    - If N = 2^64 - 1 (radicand.high = 0, radicand.low = Max_U64), return 4294967295.
     *    - If N = 2^128 - 1 (radicand.high = 0, radicand.low = Max_U128), return
     *      18446744073709551615.
     *    - If N = 2^256 - 1 (radicand.high = Max_U128, radicand.low = Max_U128), return
     *      Max_U128 (2^128 - 1).
     * 2. General Case:
     *    - Convert N to Uint<256>: N_Uint256 = radicand.high * 2^128 + radicand.low using
     *      fromU256.
     *    - Compute R = floor(sqrt(N_Uint256)) using a Newton-Raphson witness (sqrtU256Locally).
     * 3. Verify Correctness:
     *    - Compute R^2 using _mul with R as a U256 struct {low: R, high: 0}.
     *    - Compute (R + 1)^2, where R + 1 is in [0, 2^128], using _mul with R + 1 as
     *      a U256 struct {low: R + 1, high: 0}.
     *    - Assert R^2 <= N (i.e., not gt), ensuring R^2 <= N.
     *    - Assert (R + 1)^2 > N using gt, ensuring (R + 1)^2 > N.
     * 4. Return Result:
     *    - Return R as Uint<128>.
     * The operations include square root computation, multiplication, comparison, and conversion.
     * The checks ensure R^2 <= N < (R + 1)^2, confirming R = floor(sqrt(N)).
     *
     * @param radicand The U256 value to compute the square root of.
     * @returns Uint<128> The square root of radicand.
     */
    export circuit sqrt(radicand: U256): Uint<128> {
        // Special case: radicand = 0
        if (radicand.high == 0 && radicand.low == 0) {
            return 0 as Uint<128>;
        }
        
        // Special case: radicand = 1
        if (radicand.high == 0 && radicand.low == 1) {
            return 1 as Uint<128>;
        }
        
        // Special case: radicand = Max_U8
        if (radicand.high == 0 && radicand.low == Max_U8()) {
            return 15 as Uint<128>;
        }
        
        // Special case: radicand = Max_U16
        if (radicand.high == 0 && radicand.low == Max_U16()) {
            return 255 as Uint<128>;
        }
        
        // Special case: radicand = Max_U32
        if (radicand.high == 0 && radicand.low == Max_U32()) {
            return 65535 as Uint<128>;
        }
        
        // Special case: radicand = Max_U64
        if (radicand.high == 0 && radicand.low == Max_U64()) {
            return 4294967295 as Uint<128>;
        }
        
        // Special case: radicand = Max_U128
        if (radicand.high == 0 && radicand.low == Max_U128()) {
            return 18446744073709551615 as Uint<128>;
        }
        
        // Special case: radicand = Max_U256
        const maxU256 = U256 { low: Max_U128(), high: Max_U128() };
        if (radicand.high == maxU256.high && radicand.low == maxU256.low) {
            return Max_U128();
        }
        
        // General case
        const radicandUint256 = fromU256(radicand);
        const root = sqrtU256Locally(radicandUint256);
        
        // Compute root^2
        const rootSquareU256 = _mul(U256 { low: root, high: 0 }, U256 { low: root, high: 0 }); // Uint<256>
        
        // Compute (root + 1)^2
        const next = root + 1 as Uint<128>; // Uint<128> + 1 fits in Uint<128> since root <= 2^128 - 1
        const nextSquareU256 = _mul(U256 { low: next, high: 0 }, U256 { low: next, high: 0 }); // Uint<256>
        
        // Verify: root^2 <= radicand
        assert (!gt(rootSquareU256, radicand)) "MathU256: sqrt overestimate (root² > radicand)";
        
        // Verify: (root + 1)² > radicand
        assert (gt(nextSquareU256, radicand)) "MathU256: sqrt underestimate (next root still ≤ radicand)";
        
        return root;
    }

    /**
     * @description Returns the minimum of two U256 values.
     *
     * Theoretical Description:
     * This circuit computes the minimum of two 256-bit numbers A = a.high * 2^128 + a.low
     * and B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1]. It returns the smaller value as a U256 struct.
     *
     * Mathematical Steps:
     * 1. Compare Inputs:
     *    - Use le to check if A < B.
     * 2. Select Minimum:
     *    - If A < B, return a.
     *    - Otherwise, return b.
     * The operation involves comparison and conditional selection, with no arithmetic operations
     * beyond the comparison logic. The result is a U256 struct representing min(A, B).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns U256 The smaller of a and b.
     */
    export circuit min(a: U256, b: U256): U256 {
        return le(a, b) ? a : b;
    }

    /**
     * @description Returns the maximum of two U256 values.
     *
     * Theoretical Description:
     * This circuit computes the maximum of two 256-bit numbers A = a.high * 2^128 + a.low
     * and B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1]. It returns the larger value as a U256 struct.
     *
     * Mathematical Steps:
     * 1. Compare Inputs:
     *    - Use le to check if A < B.
     * 2. Select Maximum:
     *    - If A < B, return b.
     *    - Otherwise, return a.
     * The operation involves comparison and conditional selection, with no arithmetic operations
     * beyond the comparison logic. The result is a U256 struct representing max(A, B).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns U256 The larger of a and b.
     */
    export circuit max(a: U256, b: U256): U256 {
        return le(a, b) ? b : a;
    }

    /**
     * @description Checks if a U256 value is a multiple of another.
     *
     * Theoretical Description:
     * This circuit determines if a 256-bit number N = value.high * 2^128 + value.low is a multiple
     * of another 256-bit number M = divisor.high * 2^128 + divisor.low, where value.high,
     * value.low, divisor.high, divisor.low are in [0, 2^128 - 1]. It returns true if N is a
     * multiple of M (i.e., N mod M = 0), false otherwise.
     *
     * Mathematical Steps:
     * 1. Check for Division by Zero:
     *    - Assert M != 0 (i.e., divisor.high > 0 or divisor.low > 0).
     * 2. Compute Remainder:
     *    - Compute rem = N mod M using _div, where rem is a U256 struct.
     * 3. Check Multiplicity:
     *    - Compare rem to zero (rem.high = 0 and rem.low = 0).
     *    - Return true if rem = 0, false otherwise.
     * The operations include division, comparison, and logical checks. The result is a boolean
     * indicating whether N is a multiple of M.
     *
     * @param value The U256 value to check.
     * @param divisor The U256 divisor to test against.
     * @returns Boolean True if value is a multiple of divisor, false otherwise.
     */
    export circuit isMultiple(value: U256, divisor: U256): Boolean {
        assert (divisor.high > 0 || divisor.low > 0) "MathU256: division by zero";
        const result = _div(value, divisor);
        return result.remainder.high == 0 && result.remainder.low == 0;
    }
}

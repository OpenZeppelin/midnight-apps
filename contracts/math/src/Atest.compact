pragma language_version >= 0.14.0;

import CompactStandardLibrary;

constructor() {}

struct Pair {
    token0Type: Bytes<32>,
    token1Type: Bytes<32>,
    price0VolCumulative: Uint<128>, // Sum of (price0 * volume), Token 1 per Token 0
    price1VolCumulative: Uint<128>, // Sum of (price1 * volume), Token 0 per Token 1
    volume0Cumulative: Uint<128>, 
    volume1Cumulative: Uint<128>,
    kLast: Uint<128>,
}

export ledger reserves: Map<Bytes<32>, Map<Bytes<32>, QualifiedCoinInfo>>;
export ledger pool: Map<Bytes<32>, Pair>;

circuit updateReserves(identity: Bytes<32>, token0: CoinInfo, token1: CoinInfo, isRemove: Bool): [] {
    const foundPair = pool.lookup(identity);
    reserves.lookup(identity).insert_coin(token0.color, token0, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
    reserves.lookup(identity).insert_coin(token1.color, token1, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
    return [];
}

circuit 

circuit testPair(token0: CoinInfo, token1: CoinInfo): [] {
    const identity = persistent_hash<Vector<2, CoinInfo>>([token0, token1]);
    const foundPair = pool.lookup(identity);
    // Reserve calculation
    reserves.lookup(identity).insert_coin(token0.color, token0, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
    reserves.lookup(identity).insert_coin(token1.color, token1, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
    // Minting
    foundPair.token0.write_coin(token0, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
    const updatedToken1 = foundPair.token1.write_coin(token1, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
    const pair = Pair {
        foundPair.token0.write_coin(token0, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())),
        token1: foundPair.token1.write_coin(token1, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())),
        price0VolCumulative: default<Uint<128>>,
        price1VolCumulative: default<Uint<128>>,
        volume0Cumulative: default<Uint<128>>,
        volume1Cumulative: default<Uint<128>>,
        kLast: default<Uint<128>>,
    };
    return [];
}

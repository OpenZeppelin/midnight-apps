// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

import CompactStandardLibrary;

import "../../interfaces/IUint128";
import "../../interfaces/IUint256";
import "../../interfaces/IMathU256";

import "../../MathU256" prefix MathU256_;

export circuit isZero(a: U256): Boolean {
    return MathU256_isZero(a);
}

export circuit ZERO_U256(): U256 {
    return MathU256_ZERO_U256();
}

export circuit MAX_U256(): U256 {
    return MathU256_MAX_U256();
}

export circuit eq(a: U256, b: U256): Boolean {
    return MathU256_eq(a, b);
}

export circuit le(a: U256, b: U256): Boolean {
    return MathU256_le(a, b);
}

export circuit gt(a: U256, b: U256): Boolean {
    return MathU256_gt(a, b);
}

export circuit add(a: U256, b: U256): U256 {
    return disclose(MathU256_add(a, b));
}

export circuit sub(a: U256, b: U256): U256 {
    return disclose(MathU256_sub(a, b));
}

export circuit mul(a: U256, b: U256): U256 {
    return disclose(MathU256_mul(a, b));
}

export circuit div(a: U256, b: U256): U256 {
    return disclose(MathU256_div(a, b));
}

export circuit rem(a: U256, b: U256): U256 {
    return disclose(MathU256_rem(a, b));
}

export circuit divRem(a: U256, b: U256): DivResultU256 {
    return disclose(MathU256_divRem(a, b));
}

export circuit sqrt(radicand: U256): Uint<128> {
    return disclose(MathU256_sqrt(radicand));
}

export circuit min(a: U256, b: U256): U256 {
    return disclose(MathU256_min(a, b));
}

export circuit max(a: U256, b: U256): U256 {
    return disclose(MathU256_max(a, b));
}

export circuit isMultiple(value: U256, b: U256): Boolean {
    return disclose(MathU256_isMultiple(value, b));
}

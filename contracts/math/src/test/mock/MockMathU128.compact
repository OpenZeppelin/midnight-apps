pragma language_version >= 0.14.0;

import CompactStandardLibrary;

import "../../interfaces/IUint128";
import "../../interfaces/IUint256";
import "../../interfaces/IMathU128";

import "../../MathU128" prefix MathU128_;

/**
 * @description A mock contract for testing the MathU128 module's circuits.
 */

export circuit toU128(value: Uint<128>): U128 {
    return disclose(MathU128_toU128(value));
}

export circuit fromU128(value: U128): Uint<128> {
    return disclose(MathU128_fromU128(value));
}

export circuit le(a: Uint<128>, b: Uint<128>): Boolean {
    return disclose(MathU128_le(a, b));
}

export circuit leU128(a: U128, b: U128): Boolean {
    return disclose(MathU128_leU128(a, b));
}

export circuit gt(a: Uint<128>, b: Uint<128>): Boolean {
    return disclose(MathU128_gt(a, b));
}

export circuit gtU128(a: U128, b: U128): Boolean {
    return disclose(MathU128_gtU128(a, b));
}

export circuit add(a: Uint<128>, b: Uint<128>): U256 {
    return disclose(MathU128_add(a, b));
}

export circuit addU128(a: U128, b: U128): U256 {
    return disclose(MathU128_addU128(a, b));
}

export circuit sub(a: Uint<128>, b: Uint<128>): Uint<128> {
    return disclose(MathU128_sub(a, b));
}

export circuit subU128(a: U128, b: U128): U128 {
    return MathU128_subU128(a, b);
}

export circuit mul(a: Uint<128>, b: Uint<128>): U256 {
    return disclose(MathU128_mul(a, b));
}

export circuit mulU128(a: U128, b: U128): U256 {
    return disclose(MathU128_mulU128(a, b));
}

export circuit div(a: Uint<128>, b: Uint<128>): Uint<128> {
    return disclose(MathU128_div(a, b));
}

export circuit divU128(a: U128, b: U128): U128 {
    return disclose(MathU128_divU128(a, b));
}

export circuit rem(a: Uint<128>, b: Uint<128>): Uint<128> {
    return disclose(MathU128_rem(a, b));
}

export circuit remU128(a: U128, b: U128): U128 {
    return disclose(MathU128_remU128(a, b));
}

export circuit divRem(a: Uint<128>, b: Uint<128>): DivResultU128 {
    return disclose(MathU128_divRem(a, b));
}

export circuit divRemU128(a: U128, b: U128): DivResultU128 {
    return disclose(MathU128_divRemU128(a, b));
}

export circuit sqrt(radicand: Uint<128>): Uint<64> {
    return disclose(MathU128_sqrt(radicand));
}

export circuit sqrtU128(radicand: U128): Uint<64> {
    return disclose(MathU128_sqrtU128(radicand));
}

export circuit min(a: Uint<128>, b: Uint<128>): Uint<128> {
    return disclose(MathU128_min(a, b));
}

export circuit minU128(a: U128, b: U128): U128 {
    return MathU128_minU128(a, b);
}

export circuit max(a: Uint<128>, b: Uint<128>): Uint<128> {
    return disclose(MathU128_max(a, b));
}

export circuit maxU128(a: U128, b: U128): U128 {
    return disclose(MathU128_maxU128(a, b));
}

export circuit isMultiple(value: Uint<128>, b: Uint<128>): Boolean {
    return disclose(MathU128_isMultiple(value, b));
}

export circuit isMultipleU128(value: U128, b: U128): Boolean {
    return disclose(MathU128_isMultipleU128(value, b));
}

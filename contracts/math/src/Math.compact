// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

/**
 * @description A utility module providing mathematical operations for 128-bit unsigned integers
 * (Uint<128>) in the range [0, 2^128 - 1]. The module supports arithmetic, division, square root,
 * and utility functions. Operations are implemented with internal circuits for core logic and 
 * exported circuits for public use, ensuring overflow and underflow checks where applicable.
 *
 * Supported Mathematical Operations:
 * - Arithmetic:
 *   - add(): Adds two Uint<128> numbers, checking for overflow.
 *   - sub(): Subtracts one Uint<128> number from another, checking for underflow.
 *   - mul(): Multiplies two Uint<128> numbers, returning a Uint<256> result.
 * - Division:
 *   - div(): Computes the quotient of dividing one Uint<128> number by another.
 *   - rem(): Computes the remainder of dividing one Uint<128> number by another.
 * - Square Root:
 *   - sqrt(): Computes the floor of the square root of a Uint<128> number using the Newton-Raphson method.
 * - Utility:
 *   - isMultiple(): Checks if one Uint<128> number is a multiple of another.
 *   - min(): Returns the smaller of two Uint<128> numbers.
 *   - max(): Returns the larger of two Uint<128> numbers.
 *
 * TODO: Future Operations:
 * - po(w: Compute the power of a Uint<128> number raised to a given exponent, returning a Uint<256>
 *   result with overflow checking.
 *
 * @module Math
 */
module Math {
    import CompactStandardLibrary;

    import "./interface/IMath";
    import "./interface/IMaxUint";

    import MaxUint prefix MaxUint_;

    /**
     * @description Initializes the max value constants for common Uint types.
     *
     * @returns None
     */
    export circuit initialize(): [] {
        MaxUint_initialize();
    }

    /**
     * @description Internal implementation of addition for two Uint<128> numbers, checking for overflow.
     *
     * @param addend The first number to add.
     * @param augend The second number to add.
     * @returns Uint<128> The sum of addend and augend.
     */
    circuit _add(
        addend: Uint<128>,
        augend: Uint<128>
    ): Uint<128> {
        const result = addend + augend;
        assert (result <= MAX_U128) "Math: addition overflow";
        return result as Uint<128>;
    }

    /**
     * @description Adds two Uint<128> numbers-den, checking for overflow.
     *
     * @param addend The first number to add.
     * @param augend The second number to add.
     * @returns Uint<128> The sum of addend and augend.
     */
    export circuit add(
        addend: Uint<128>,
        augend: Uint<128>
    ): Uint<128> {
        return _add(addend, augend);
    }

    /**
     * @description Internal implementation of subtraction for Uint<128>, checking for underflow.
     *
     * @param minuend The number to subtract from.
     * @param subtrahend The number to subtract.
     * @returns Uint<128> The difference between minuend and subtrahend.
     */
    circuit _sub(
        minuend: Uint<128>,
        subtrahend: Uint<128>
    ): Uint<128> {
        assert (minuend >= subtrahend) "Math: subtraction underflow";
        return minuend - subtrahend;
    }

    /**
     * @description Subtracts subtrahend from minuend, checking for underflow.
     *
     * @param minuend The number to subtract from.
     * @param subtrahend The number to subtract.
     * @returns Uint<128> The difference between minuend and subtrahend.
     */
    export circuit sub(
        minuend: Uint<128>,
        subtrahend: Uint<128>
    ): Uint<128> {
        return _sub(minuend, subtrahend);
    }

    /**
     * @description Internal implementation of multiplication for two Uint<128> values, returning a Uint<256> result.
     *
     * @param multiplicand The first number to multiply.
     * @param multiplier The second number to multiply.
     * @returns Uint<256> The product of multiplicand and multiplier.
     */
    circuit _mul(
        multiplicand: Uint<128>,
        multiplier: Uint<128>
    ): Uint<256> {
        return multiplicand * multiplier;
    }

    /**
     * @description Multiplies two Uint<128> values, returning a Uint<256> result.
     *
     * @param multiplicand The first number to multiply.
     * @param multiplier The second number to multiply.
     * @returns Uint<256> The product of multiplicand and multiplier.
     */
    export circuit mul(
        multiplicand: Uint<128>,
        multiplier: Uint<128>
    ): Uint<256> {
        return _mul(multiplicand, multiplier);
    }

    /**
     * @description Divides a Uint<128> dividend by a divisor, returning quotient.
     *
     * @param dividend The number to divide.
     * @param divisor The number to divide by.
     * @returns Uint<128> The quotient of the division.
     * @dev Uses a local division witness and verifies the result on-chain.
     */
    export circuit div(
        dividend: Uint<128>, 
        divisor: Uint<128>
    ): Uint<128> {
        return _div(dividend, divisor).quotient;
    }

    /**
     * @description Computes the remainder of dividing dividend by divisor.
     *
     * @param dividend The number to divide.
     * @param divisor The number to divide by.
     * @returns Uint<128> The remainder of the division.
     */
    export circuit rem(
        dividend: Uint<128>,
        divisor: Uint<128>
    ): Uint<128> {
        return _div(dividend, divisor).remainder;
    }

    /**
     * @description Divides a Uint<128> dividend by a divisor, returning quotient and remainder.
     *
     * @param dividend The number to divide.
     * @param divisor The number to divide by.
     * @returns DivResult The quotient and remainder of the division.
     * @dev Uses a local division witness and verifies the result on-chain.
     */
    circuit _div(
        dividend: Uint<128>, 
        divisor: Uint<128>
    ): DivResult {
        assert (divisor > 0) "Math: division by zero";
        const result = divLocally(dividend, divisor);
        assert (result.remainder < divisor) "Math: remainder error";
        assert (
            (_mul(result.quotient, divisor) + result.remainder) as Uint<128> == dividend
        ) "Math: division invalid";
        return result;
    }

    /**
     * @description Internal implementation of square root for a Uint<128> value, verified on-chain.
     *
     * @param radicand The number to compute the square root of.
     * @returns Uint<128> The square root of radicand.
     */
    circuit _sqrt(
        radicand: Uint<128>
    ): Uint<128> {
        const root = sqrtLocally(radicand);
        assert (mul(root, root) as Field as Uint<222> <= radicand as Field as Uint<222>) "Math: sqrt overestimate (root² > radicand)";
        assert (mul(add(root, 1), add(root, 1)) as Field as Uint<222> > radicand as Field as Uint<222>) "Math: sqrt underestimate (next root still ≤ radicand)";
        return root;
    }

    /**
     * @description Computes the square root of a Uint<128> value, verified on-chain.
     *
     * The implementation uses the Newton-Raphson method via the sqrtLocally witness,
     * avoiding floating-point precision issues inherent in Math.sqrt by performing
     * all calculations with bigint arithmetic. For imperfect squares, the result is
     * rounded toward zero (i.e., floor(sqrt(radicand))).
     *
     * For perfect squares (e.g., 16), the result is exact (√16 = 4).
     * For imperfect squares (e.g., 20), the result is floored (√20 ≈ 4.47 → 4).
     * 
     * The ZK circuit enforces:
     *  - root² ≤ radicand
     *  - (root + 1)² > radicand
     *
     * @param radicand The number to compute the square root of.
     * @returns Uint<128> The square root of radicand.
     */
    export circuit sqrt(
        radicand: Uint<128>
    ): Uint<128> {
        return _sqrt(radicand);
    }

    /**
     * @description Internal implementation to check if a number is a multiple of another.
     *
     * @param value The number to check.
     * @param divisor The divisor to test against.
     * @returns Boolean True if value is a multiple of divisor, false otherwise.
     */
    circuit _isMultiple(
        value: Uint<128>,
        divisor: Uint<128>
    ): Boolean {
        assert (divisor > 0) "Math: division by zero";
        return rem(value, divisor) == 0;
    }

    /**
     * @description Checks if a number is a multiple of another.
     *
     * @param value The number to check.
     * @param divisor The divisor to test against.
     * @returns Boolean True if value is a multiple of divisor, false otherwise.
     */
    export circuit isMultiple(
        value: Uint<128>,
        divisor: Uint<128>
    ): Boolean {
        return _isMultiple(value, divisor);
    }

    /**
     * @description Internal implementation to return the minimum of two Uint<128> values.
     *
     * @param a The first number.
     * @param b The second number.
     * @returns Uint<128> The smaller of a and b.
     */
    circuit _min(
        a: Uint<128>,
        b: Uint<128>
    ): Uint<128> {
        return a < b ? a : b;
    }

    /**
     * @description Returns the minimum of two Uint<128> values.
     *
     * @param a The first number.
     * @param b The second number.
     * @returns Uint<128> The smaller of a and b.
     */
    export circuit min(
        a: Uint<128>,
        b: Uint<128>
    ): Uint<128> {
        return _min(a, b);
    }

    /**
     * @description Internal implementation to return the maximum of two Uint<128> values.
     *
     * @param a The first number.
     * @param b The second number.
     * @returns Uint<128> The larger of a and b.
     */
    circuit _max(
        a: Uint<128>,
        b: Uint<128>
    ): Uint<128> {
        return a > b ? a : b;
    }

    /**
     * @description Returns the maximum of two Uint<128> values.
     *
     * @param a The first number.
     * @param b The second number.
     * @returns Uint<128> The larger of a and b.
     */
    export circuit max(
        a: Uint<128>,
        b: Uint<128>
    ): Uint<128> {
        return _max(a, b);
    }
}

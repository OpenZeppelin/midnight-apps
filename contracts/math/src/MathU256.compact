// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

/**
 * @description A utility module providing mathematical operations for 256-bit unsigned integers
 * using the U256 struct, which represents numbers as high * 2^128 + low, where high and low are
 * 128-bit unsigned integers (Uint<128>) in [0, 2^128 - 1]. The module supports a range of
 * operations including conversions, comparisons, arithmetic, division, square root, and utility
 * functions. Operations are provided in dual forms: 
 * one for Uint<256> inputs with conversions to/from U256, and another for direct U256 inputs.
 *
 * Supported Mathematical Operations:
 * - Conversions:
 *   - toU256(): Converts a Uint<256> to a U256 struct by splitting into high and low 128-bit parts.
 *   - fromU256(): Converts a U256 struct to a Uint<256> by combining high and low parts.
 * - Comparisons:
 *   - lessThan(), lessThanU256(): Checks if one 256-bit number is less than another.
 *   - greaterThan(), greaterThanU256(): Checks if one 256-bit number is greater than another.
 * - Arithmetic:
 *   - add(), addU256(): Adds two 256-bit numbers, checking for overflow.
 *   - sub(), subU256(): Subtracts one 256-bit number from another, checking for underflow.
 *   - mul(), mulU256(): Multiplies two 256-bit numbers, checking for overflow.
 * - Division:
 *   - div(), divU256(): Computes the quotient of dividing one 256-bit number by another.
 *   - rem(), remU256(): Computes the remainder of dividing one 256-bit number by another.
 * - Square Root:
 *   - sqrt(), sqrtU256(): Computes the floor of the square root of a 256-bit number, with special cases
 *     for efficiency.
 * - Utility:
 *   - min(), minU256:() Returns the smaller of two 256-bit numbers.
 *   - max(), maxU256(): Returns the larger of two 256-bit numbers.
 *   - isMultiple(), isMultipleU256(): Checks if one 256-bit number is a multiple of another.
 * 
 * TODO: Future Operations:
 * - pow(), powU256(): Compute the power of a 256-bit number raised to a given exponent.
 *
 * @module MathU256
 */
module MathU256 {
    import CompactStandardLibrary;
    
    import "./interfaces/IMaxUint";
    import "./interfaces/IUint256";
    import "./interfaces/IMathU256";

    import MaxUint prefix MaxUint_;
    import Uint256 prefix Uint256_;
    import Math prefix Math_;

    /**
     * @description Initializes IU256 interface module.
     *
     * @returns None
     */
    export circuit initialize(): [] {
        MaxUint_initialize();
        Uint256_initialize();
    }

    /**
     * @description Internal implementation to convert a Uint<256> value to a U256 struct by splitting into high and low parts.
     *
     * Theoretical Description:
     * This circuit converts a 256-bit unsigned integer N in the range [0, 2^256 - 1] into a U256
     * struct with two 128-bit parts: low = N mod 2^128 and high = floor(N / 2^128).
     *
     * Mathematical Steps:
     * 1. Perform division:
     *    - Compute quotient = floor(N / 2^128) and remainder = N mod 2^128 using a division
     *      witness (divU256Locally).
     * 2. Construct U256 struct:
     *    - Set low = remainder, high = quotient, both as Uint<128> values in [0, 2^128 - 1].
     *    - The struct represents N = high * 2^128 + low.
     * No overflow checks are needed, as N <= 2^256 - 1 ensures quotient, remainder <= 2^128 - 1.
     *
     * @param value The Uint<256> value to convert.
     * @returns U256 The high and low 128-bit parts of the value.
     */
    circuit _toU256(value: Uint<256>): U256 {
        const divResult = divU256Locally(value, TWO_POW_128); // 2^128
        return disclose(U256 {
            low: divResult.remainder.low,
            high: divResult.quotient.low
        });
    }

    /**
     * @description Converts a Uint<256> value to a U256 struct by splitting into high and low parts.
     *
     * @param value The Uint<256> value to convert.
     * @returns U256 The high and low 128-bit parts of the value.
     */
    export circuit toU256(value: Uint<256>): U256 {
        return _toU256(value);
    }

    /**
     * @description Internal implementation to convert a U256 struct to a Uint<256> value by combining high and low parts.
     *
     * Theoretical Description:
     * This circuit converts a U256 struct, representing a 256-bit number N = high * 2^128 + low
     * where high, low are in [0, 2^128 - 1], into a single Uint<256> value.
     *
     * Mathematical Steps:
     * 1. Construct highShifted:
     *    - Set highShifted = high * 2^128 as a U256 struct: {low: 0, high: high}.
     * 2. Construct lowU256:
     *    - Set lowU256 = low as a U256 struct: {low: low, high: 0}.
     * 3. Add U256 structs:
     *    - Compute S = highShifted + lowU256 = (high * 2^128) + low using addU256,
     *      producing a U256 struct {low: S mod 2^128, high: floor(S / 2^128)}.
     * 4. Convert to Uint<256>:
     *    - Compute N = (resultU256.high * 2^128) + resultU256.low using field arithmetic,
     *      casting high, low to Field and the result back to Uint<256>.
     * The operation ensures N <= 2^256 - 1, as addU256 enforces overflow checks.
     *
     * @param valueU256 The U256 struct to convert.
     * @returns Uint<256> The combined value (high * 2^128 + low).
     */
    circuit _fromU256(valueU256: U256): Uint<256> {
        // Compute highShifted = valueU256.high * 2^128 as a U256 struct
        const highShiftedU256 = U256 { low: 0, high: valueU256.high }; // Equivalent to value.high * 2^128
        // Represent valueU256.low as a U256 struct
        const lowU256 = U256 { low: valueU256.low, high: 0 };
        // Add using addU256 to get the combined result
        const resultU256 = addU256(highShiftedU256, lowU256);
        // Combine high and low parts using Field arithmetic to ensure bounds
        const highAsField = resultU256.high as Field;
        const lowAsField = resultU256.low as Field;
        const twoPow128AsField = TWO_POW_128 as Field;
        const result = highAsField * twoPow128AsField + lowAsField;
        return result as Uint<256>;
    }

    /**
     * @description Converts a U256 struct to a Uint<256> value by combining high and low parts.
     *
     * @param valueU256 The U256 struct to convert.
     * @returns Uint<256> The combined value (high * 2^128 + low).
     */
    export circuit fromU256(valueU256: U256): Uint<256> {
        return _fromU256(valueU256);
    }

    /**
     * @description Compares two U256 values to check if aU256 < bU256.
     *
     * Theoretical Description:
     * This circuit compares two 256-bit numbers A = aU256.high * 2^128 + aU256.low and
     * B = bU256.high * 2^128 + bU256.low, where aU256.high, aU256.low, bU256.high,
     * bU256.low are in [0, 2^128 - 1], to determine if A < B. It performs a lexicographical
     * comparison by checking the high parts first, then the low parts if the high parts are
     * equal, returning true if A < B, false otherwise. No arithmetic operations are performed,
     * only comparisons and logical operations (OR, AND).
     *
     * @param aU256 The first U256 value.
     * @param bU256 The second U256 value.
     * @returns Boolean True if aU256 < bU256, false otherwise.
     */
    circuit _lessThan(aU256: U256, bU256: U256): Boolean {
        return aU256.high < bU256.high || (aU256.high == bU256.high && aU256.low < bU256.low);
    }

    /**
     * @description Compares two U256 values to check if aU256 < bU256.
     *
     * @param aU256 The first U256 value.
     * @param bU256 The second U256 value.
     * @returns Boolean True if aU256 < bU256, false otherwise.
     */
    export circuit lessThanU256(aU256: U256, bU256: U256): Boolean {
        return _lessThan(aU256, bU256);
    }

    /**
     * @description Compares two Uint<256> values to check if a < b.
     *
     * @param a The first Uint<256> value.
     * @param b The second Uint<256> value.
     * @returns Boolean True if a < b, false otherwise.
     */
    export circuit lessThan(a: Uint<256>, b: Uint<256>): Boolean {
        const aU256 = _toU256(a);
        const bU256 = _toU256(b);
        return _lessThan(aU256, bU256);
    }

    /**
     * @description Internal implementation to compare two U256 values to check if aU256 > bU256.
     *
     * Theoretical Description:
     * This circuit compares two 256-bit numbers A = aU256.high * 2^128 + aU256.low and
     * B = bU256.high * 2^128 + bU256.low, where aU256.high, aU256.low, bU256.high,
     * bU256.low are in [0, 2^128 - 1], to determine if A > B. It performs a lexicographical
     * comparison by checking the high parts first, then the low parts if the high parts are
     * equal, returning true if A > B, false otherwise. No arithmetic operations are performed,
     * only comparisons and logical operations (OR, AND).
     *
     * @param aU256 The first U256 value.
     * @param bU256 The second U256 value.
     * @returns Boolean True if aU256 > bU256, false otherwise.
     */
    circuit _greaterThan(aU256: U256, bU256: U256): Boolean {
        return aU256.high > bU256.high || (aU256.high == bU256.high && aU256.low > bU256.low);
    }

    /**
     * @description Compares two U256 values to check if aU256 > bU256.
     *
     * @param aU256 The first U256 value.
     * @param bU256 The second U256 value.
     * @returns Boolean True if aU256 > bU256, false otherwise.
     */
    export circuit greaterThanU256(aU256: U256, bU256: U256): Boolean {
        return _greaterThan(aU256, bU256);
    }

    /**
     * @description Compares two Uint<256> values to check if a > b.
     *
     * @param a The first Uint<256> value.
     * @param b The second Uint<256> value.
     * @returns Boolean True if a > b, false otherwise.
     */
    export circuit greaterThan(a: Uint<256>, b: Uint<256>): Boolean {
        const aU256 = _toU256(a);
        const bU256 = _toU256(b);
        return _greaterThan(aU256, bU256);
    }

    /**
     * @description Internal implementation to add two U256 values, checking for overflow.
     *
     * Theoretical Description:
     * This circuit computes the sum S = A + B of two 256-bit numbers represented as U256 structs,
     * where A = aU256.high * 2^128 + aU256.low, B = bU256.high * 2^128 + bU256.low, and
     * aU256.high, aU256.low, bU256.high, bU256.low are in [0, 2^128 - 1]. The result is a U256
     * struct {low: S mod 2^128, high: floor(S / 2^128)}.
     *
     * Mathematical Steps:
     * 1. Low Part Addition:
     *    - Compute lowSum = aU256.low + bU256.low, where aU256.low, bU256.low are in
     *      [0, 2^128 - 1], so lowSum is in [0, 2^129 - 2].
     *    - Split lowSum into carry = floor(lowSum / 2^128) (0 or 1) and
     *      lowResult = lowSum mod 2^128.
     * 2. High Part Addition with Carry:
     *    - Compute highSum = aU256.high + bU256.high + carry, where aU256.high,
     *      bU256.high are in [0, 2^128 - 1] and carry is 0 or 1, so highSum is in
     *      [0, 2^129 - 1].
     * 3. Overflow Check:
     *    - Ensure S = highSum * 2^128 + lowResult <= 2^256 - 1.
     *    - Assert highSum <= 2^128 - 1 by checking floor(highSum / 2^128) = 0.
     *    - If false, S > (2^128 - 1) * 2^128 + (2^128 - 1) = 2^256 - 1, throw
     *      "MathU256: addition overflow".
     * 4. Construct Result:
     *    - Return U256 {low: lowResult, high: highSum}, representing
     *      S = highSum * 2^128 + lowResult.
     *
     * @param aU256 The first U256 value to add.
     * @param bU256 The second U256 value to add.
     * @returns U256 The sum of a and b.
     * @throws MathU256: addition overflow If the sum exceeds 2^256 - 1.
     */
    circuit _add(aU256: U256, bU256: U256): U256 {
        // Add the low parts as Uint<256> to handle potential carry
        const lowSumFull = aU256.low + bU256.low; // Results in Uint<256>
        
        // Split lowSumFull into high and low parts to get the carry
        const lowSumFullU256 = _toU256(lowSumFull);
        const carry = lowSumFullU256.high; // 0 or 1, since lowSumFull <= 2^129 - 2
        
        // Add the high parts plus the carry
        const highSumIntermediate = aU256.high + bU256.high;
        const highSumFull = highSumIntermediate + carry;
        
        // Check for overflow: highSumFull must fit in 128 bits (i.e., highSumFull.high == 0)
        const highSumFullU256 = _toU256(highSumFull);
        assert (highSumFullU256.high == 0) "MathU256: addition overflow";
        
        return U256 {
            low: lowSumFullU256.low,
            high: highSumFullU256.low
        };
    }

    /**
     * @description Adds two Uint<256> values, checking for overflow.
     *
     * @param a The first Uint<256> value to add.
     * @param b The second Uint<256> value to add.
     * @returns Uint<256> The sum of a and b.
     */
    export circuit add(a: Uint<256>, b: Uint<256>): Uint<256> {
        const aU256 = _toU256(a);
        const bU256 = _toU256(b);
        const sumU256 = _add(aU256, bU256);
        return _fromU256(sumU256);
    }

    /**
     * @description Adds two U256 values, checking for overflow.
     *
     * @param a The first U256 value to add.
     * @param b The second U256 value to add.
     * @returns U256 The sum of a and b.
     */
    export circuit addU256(a: U256, b: U256): U256 {
        return _add(a, b);
    }

    /**
     * @description Internal implementation to subtract one U256 value from another, checking for underflow.
     *
     * Theoretical Description:
     * This circuit computes the difference D = A - B of two 256-bit numbers represented as U256
     * structs, where A = aU256.high * 2^128 + aU256.low, B = bU256.high * 2^128 + bU256.low,
     * and aU256.high, aU256.low, bU256.high, bU256.low are in [0, 2^128 - 1]. The result is a
     * U256 struct {low: D mod 2^128, high: floor(D / 2^128)}.
     *
     * Mathematical Steps:
     * 1. Check for Underflow:
     *    - Assert A >= B (i.e., not A < B) using _lessThan.
     *    - If false, D < 0, throw "MathU256: subtraction underflow".
     * 2. Low Part Subtraction:
     *    - Compute borrow = 1 if aU256.low < bU256.low, else 0.
     *    - If aU256.low >= bU256.low, compute lowDiff = aU256.low - bU256.low.
     *    - Else, compute lowDiff = aU256.low + 2^128 - bU256.low, ensuring
     *      lowDiff is in [0, 2^128 - 1] via modular arithmetic.
     * 3. High Part Subtraction with Borrow:
     *    - Compute highDiff = aU256.high - bU256.high - borrow.
     * 4. Construct Result:
     *    - Return U256 {low: lowDiff, high: highDiff}, representing
     *      D = highDiff * 2^128 + lowDiff.
     * The underflow check ensures D >= 0, and the result is in [0, 2^256 - 1].
     *
     * @param aU256 The U256 value to subtract from (minuend).
     * @param bU256 The U256 value to subtract (subtrahend).
     * @returns U256 The difference between a and b.
     */
    circuit _sub(aU256: U256, bU256: U256): U256 {
        // Check for underflow: a must be >= b
        assert (!_lessThan(aU256, bU256)) "MathU256: subtraction underflow";
        
        // Handle low part subtraction with borrow
        const borrow = aU256.low < bU256.low ? 1 as Uint<128> : 0 as Uint<128>;
        const highWithBorrow = bU256.high + borrow;
        const highDiff = aU256.high - highWithBorrow;
        
        // TODO: change to ternary expression after this bug is resolved: https://github.com/midnightntwrk/compactc/issues/982 
        if (borrow == 0) {
            const lowDiff = aU256.low - bU256.low;
            return U256 {
                low: lowDiff,
                high: highDiff
            };
        } else {
            const lowDiff = aU256.low + TWO_POW_128 - bU256.low;
            return U256 {
                low: lowDiff as Uint<128>,
                high: highDiff
            };
        }
    }

    /**
     * @description Subtracts one Uint<256> value from another, checking for underflow.
     *
     * @param a The Uint<256> value to subtract from (minuend).
     * @param b The Uint<256> value to subtract (subtrahend).
     * @returns Uint<256> The difference between a and b.
     */
    export circuit sub(a: Uint<256>, b: Uint<256>): Uint<256> {
        const aU256 = _toU256(a);
        const bU256 = _toU256(b);
        const diffU256 = _sub(aU256, bU256);
        return _fromU256(diffU256);
    }

    /**
     * @description Subtracts one U256 value from another, checking for underflow.
     *
     * @param a The U256 value to subtract from (minuend).
     * @param b The U256 value to subtract (subtrahend).
     * @returns U256 The difference between a and b.
     */
    export circuit subU256(aU256: U256, bU256: U256): U256 {
        return _sub(aU256, bU256);
    }

    /**
     * @description Internal implementation to multiply two U256 values, checking for overflow.
     *
     * Theoretical Description:
     * This circuit computes the product P = A * B of two 256-bit numbers represented as U256
     * structs, where A = aU256.high * 2^128 + aU256.low, B = bU256.high * 2^128 + bU256.low,
     * and aU256.high, aU256.low, bU256.high, bU256.low are in [0, 2^128 - 1]. The result is a
     * U256 struct {low: P mod 2^128, high: floor(P / 2^128)}, ensuring P <= 2^256 - 1.
     *
     * Mathematical Steps:
     * 1. Compute Partial Products:
     *    - Represent A = aU256.high * 2^128 + aU256.low, B = bU256.high * 2^128 + bU256.low.
     *    - Compute four partial products using Math_mul (128-bit to 256-bit multiplication):
     *      ll = aU256.low * bU256.low (bits 0-255)
     *      hl = aU256.high * bU256.low (bits 128-383)
     *      lh = aU256.low * bU256.high (bits 128-383)
     *      hh = aU256.high * bU256.high (bits 256-511)
     *    - Each partial product is a Uint<256> in [0, (2^128 - 1)^2].
     * 2. Convert Partial Products to U256:
     *    - Convert each partial product to a U256 struct using _toU256:
     *      llU256 = {low: ll mod 2^128, high: floor(ll / 2^128)}
     *      Similarly for hlU256, lhU256, hhU256.
     * 3. Combine Partial Products:
     *    - Add partial products with proper bit alignment using _add:
     *      - crossSum = _add(hlU256, lhU256) (sum of middle terms, bits 128-383)
     *      - crossShifted = {low: 0, high: crossSum.low} (align to bits 128-255)
     *      - lowAndCross = _add(llU256, crossShifted) (add low and middle terms)
     *      - crossCarry = {low: crossSum.high, high: 0} (carry to bits 256-383)
     *      - hhShiftedU256 = _add({low: hhU256.low, high: hhU256.high}, crossCarry)
     *        (align hh and add carry)
     *      - resultU256 = _add(lowAndCross, hhShiftedU256) (final sum)
     * 4. Overflow Check:
     *    - Ensure P = resultU256.high * 2^128 + resultU256.low <= 2^256 - 1.
     *    - Assert hhShiftedU256.low = 0 and hhShiftedU256.high = 0, ensuring bits
     *      256-511 are zero.
     *    - If false, P > 2^256 - 1, throw "MathU256: multiplication overflow".
     *    - Additional check: resultU256.high < 2^128 - 1 or (resultU256.high = 2^128 - 1
     *      and resultU256.low <= 2^128 - 1).
     * 5. Return Result:
     *    - Return resultU256 as a U256 struct.
     *
     * @param aU256 The first U256 value to multiply.
     * @param bU256 The second U256 value to multiply.
     * @returns U256 The product of a and b.
     * @throws MathU256: multiplication overflow If the product exceeds 2^256 - 1.
     */
    circuit _mul(aU256: U256, bU256: U256): U256 {
        // Compute partial products
        const ll = Math_mul(aU256.low, bU256.low);
        const hl = Math_mul(aU256.high, bU256.low);
        const lh = Math_mul(aU256.low, bU256.high);
        const hh = Math_mul(aU256.high, bU256.high);
        
        // Convert to U256 structs
        const llU256 = _toU256(ll);
        const hlU256 = _toU256(hl);
        const lhU256 = _toU256(lh);
        const hhU256 = _toU256(hh);
        
        // Combine contributions
        const crossSum = _add(hlU256, lhU256);
        const crossShifted = U256 { low: 0 as Uint<128>, high: crossSum.low };
        const lowAndCross = _add(llU256, crossShifted);
        const crossCarry = U256 { low: crossSum.high, high: 0 as Uint<128> };
        const hhShiftedU256 = _add(U256 { low: hhU256.low, high: hhU256.high }, crossCarry);
        const resultU256 = _add(lowAndCross, hhShiftedU256);
        
        // Check for overflow: upper 256 bits (bits 256-511) must be zero
        assert (hhShiftedU256.low == 0 && hhShiftedU256.high == 0) "MathU256: multiplication overflow";
        
        // Additional check to ensure result fits within MAX_U256
        assert (
            resultU256.high < MAX_U128 || 
            (resultU256.high == MAX_U128 && resultU256.low <= MAX_U128)
        ) "MathU256: multiplication overflow";
        
        return resultU256;
    }

    /**
     * @description Multiplies two Uint<256> values, checking for overflow.
     *
     * @param a The first Uint<256> value to multiply.
     * @param b The second Uint<256> value to multiply.
     * @returns Uint<256> The product of a and b.
     */
    export circuit mul(a: Uint<256>, b: Uint<256>): Uint<256> {
        const aU256 = _toU256(a);
        const bU256 = _toU256(b);
        const resultU256 = _mul(aU256, bU256);
        return _fromU256(resultU256);
    }

    /**
     * @description Multiplies two U256 values, checking for overflow.
     *
     * @param aU256 The first U256 value to multiply.
     * @param bU256 The second U256 value to multiply.
     * @returns U256 The product of a and b.
     */
    export circuit mulU256(aU256: U256, bU256: U256): U256 {
        return _mul(aU256, bU256);
    }

    /**
     * @description Internal implementation to divide a U256 dividend by a U256 divisor, returning quotient and remainder.
     *
     * Theoretical Description:
     * This circuit computes the quotient quot and remainder rem of dividing a 256-bit number
     * divd = dividend.high * 2^128 + dividend.low by another 256-bit number
     * divs = divisor.high * 2^128 + divisor.low, where dividend.high, dividend.low,
     * divisor.high, divisor.low are in [0, 2^128 - 1]. The result is a DivResultU256 struct
     * containing quot and rem as U256 structs, satisfying divd = quot * divs + rem with
     * 0 <= rem < divs.
     *
     * Mathematical Steps:
     * 1. Check for Division by Zero:
     *    - Assert divs != 0 (i.e., divisor.high > 0 or divisor.low > 0).
     * 2. Convert Inputs to Uint<256>:
     *    - Compute divd_Uint256 = dividend.high * 2^128 + dividend.low using _fromU256.
     *    - Compute divs_Uint256 = divisor.high * 2^128 + divisor.low using _fromU256.
     * 3. Compute Division:
     *    - Use a division witness (divU256Locally) to compute quot_Uint256 = floor(divd / divs)
     *      and rem_Uint256 = divd mod divs, both as Uint<256> values.
     * 4. Convert Results to U256:
     *    - Convert quot_Uint256 and rem_Uint256 to U256 structs: quotientU256, remainderU256.
     * 5. Verify Remainder:
     *    - Assert remainderU256 < divisor using _lessThan, ensuring rem < divs.
     * 6. Verify Correctness:
     *    - Compute P = quot * divs using _mul.
     *    - Compute S = P + rem using _add.
     *    - Assert S.high = dividend.high and S.low = dividend.low, ensuring
     *      S = divd.
     * 7. Return Result:
     *    - Return DivResultU256 {quotient: quotientU256, remainder: remainderU256}.
     * The operations include division, modulus, multiplication, addition, comparison, and
     * conversion.
     *
     * @param dividend The U256 value to divide.
     * @param divisor The U256 value to divide by.
     * @returns DivResultU256 The quotient and remainder of the division as U256 structs.
     */
    circuit _div(dividend: U256, divisor: U256): DivResultU256 {
        assert (divisor.high > 0 || divisor.low > 0) "MathU256: division by zero";
        
        const dividendUint256 = _fromU256(dividend);
        const divisorUint256 = _fromU256(divisor);
        const result = divU256Locally(dividendUint256, divisorUint256);
        
        // Compare remainder < divisor using high and low parts
        const remainderU256 = result.remainder;
        assert (_lessThan(remainderU256, divisor)) "MathU256: remainder error";

        // Verify: quotient * divisor + remainder == dividend
        const quotientU256 = result.quotient;
        const product = _mul(quotientU256, divisor);
        const sum = _add(product, remainderU256);
        
        assert (
            sum.high == dividend.high &&
            sum.low == dividend.low
        ) "MathU256: division invalid";

        return result;
    }

    /**
     * @description Divides a Uint<256> dividend by a divisor, returning quotient.
     *
     * @param dividend The number to divide.
     * @param divisor The number to divide by.
     * @returns Uint<256> The quotient of the division.
     */
    export circuit div(dividend: Uint<256>, divisor: Uint<256>): Uint<256> {
        const dividendU256 = _toU256(dividend);
        const divisorU256 = _toU256(divisor);
        const result = _div(dividendU256, divisorU256);
        return _fromU256(result.quotient);
    }

    /**
     * @description Divides a U256 dividend by a U256 divisor, returning quotient.
     *
     * @param dividend The U256 value to divide.
     * @param divisor The U256 value to divide by.
     * @returns U256 The quotient of the division.
     */
    export circuit divU256(dividend: U256, divisor: U256): U256 {
        return _div(dividend, divisor).quotient;
    }

    /**
     * @description Computes the remainder of dividing a Uint<256> dividend by a divisor.
     *
     * @param dividend The number to divide.
     * @param divisor The number to divide by.
     * @returns Uint<256> The remainder of the division.
     */
    export circuit rem(dividend: Uint<256>, divisor: Uint<256>): Uint<256> {
        const dividendU256 = _toU256(dividend);
        const divisorU256 = _toU256(divisor);
        const result = _div(dividendU256, divisorU256);
        return _fromU256(result.remainder);
    }

    /**
     * @description Computes the remainder of dividing a U256 dividend by a U256 divisor.
     *
     * @param dividend The U256 value to divide.
     * @param divisor The U256 value to divide by.
     * @returns U256 The remainder of the division.
     */
    export circuit remU256(dividend: U256, divisor: U256): U256 {
        return _div(dividend, divisor).remainder;
    }

    /**
     * @description Internal implementation to compute the square root of a U256 value, verified on-chain.
     *
     * Theoretical Description:
     * This circuit computes the floor of the square root R = floor(sqrt(N)) of a 256-bit number
     * N = radicand.high * 2^128 + radicand.low, where radicand.high, radicand.low are in
     * [0, 2^128 - 1]. The result is a Uint<128> value R in [0, 2^128 - 1]. It uses the
     * Newton-Raphson method via a witness and includes special cases for efficiency.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If N = 0 (radicand.high = 0, radicand.low = 0), return 0.
     *    - If N = 1 (radicand.high = 0, radicand.low = 1), return 1.
     *    - If N = 2^8 - 1 (radicand.high = 0, radicand.low = MAX_U8), return 15.
     *    - If N = 2^16 - 1 (radicand.high = 0, radicand.low = MAX_U16), return 255.
     *    - If N = 2^32 - 1 (radicand.high = 0, radicand.low = MAX_U32), return 65535.
     *    - If N = 2^64 - 1 (radicand.high = 0, radicand.low = MAX_U64), return 4294967295.
     *    - If N = 2^128 - 1 (radicand.high = 0, radicand.low = MAX_U128), return
     *      18446744073709551615.
     *    - If N = 2^256 - 1 (radicand.high = MAX_U128, radicand.low = MAX_U128), return
     *      MAX_U128 (2^128 - 1).
     * 2. General Case:
     *    - Convert N to Uint<256>: N_Uint256 = radicand.high * 2^128 + radicand.low using
     *      _fromU256.
     *    - Compute R = floor(sqrt(N_Uint256)) using a Newton-Raphson witness (sqrtU256Locally).
     * 3. Verify Correctness:
     *    - Compute R^2 using _mul with R as a U256 struct {low: R, high: 0}.
     *    - Compute (R + 1)^2, where R + 1 is in [0, 2^128], using _mul with R + 1 as
     *      a U256 struct {low: R + 1, high: 0}.
     *    - Assert R^2 <= N (i.e., not _greaterThan), ensuring R^2 <= N.
     *    - Assert (R + 1)^2 > N using _greaterThan, ensuring (R + 1)^2 > N.
     * 4. Return Result:
     *    - Return R as Uint<128>.
     * The operations include square root computation, multiplication, comparison, and conversion.
     * The checks ensure R^2 <= N < (R + 1)^2, confirming R = floor(sqrt(N)).
     *
     * @param radicand The U256 value to compute the square root of.
     * @returns Uint<128> The square root of radicand.
     */
    circuit _sqrt(radicand: U256): Uint<128> {
        // Special case: radicand = 0
        if (radicand.high == 0 && radicand.low == 0) {
            return 0 as Uint<128>;
        }
        
        // Special case: radicand = 1
        if (radicand.high == 0 && radicand.low == 1) {
            return 1 as Uint<128>;
        }
        
        // Special case: radicand = MAX_U8
        if (radicand.high == 0 && radicand.low == MAX_U8) {
            return 15 as Uint<128>;
        }
        
        // Special case: radicand = MAX_U16
        if (radicand.high == 0 && radicand.low == MAX_U16) {
            return 255 as Uint<128>;
        }
        
        // Special case: radicand = MAX_U32
        if (radicand.high == 0 && radicand.low == MAX_U32) {
            return 65535 as Uint<128>;
        }
        
        // Special case: radicand = MAX_U64
        if (radicand.high == 0 && radicand.low == MAX_U64) {
            return 4294967295 as Uint<128>;
        }
        
        // Special case: radicand = MAX_U128
        if (radicand.high == 0 && radicand.low == MAX_U128) {
            return 18446744073709551615 as Uint<128>;
        }
        
        // Special case: radicand = MAX_U256
        const maxU256 = U256 { low: MAX_U128, high: MAX_U128 };
        if (radicand.high == maxU256.high && radicand.low == maxU256.low) {
            return MAX_U128;
        }
        
        // General case
        const radicandUint256 = _fromU256(radicand);
        const root = sqrtU256Locally(radicandUint256);
        
        // Compute root^2
        const rootSquareU256 = _mul(U256 { low: root, high: 0 }, U256 { low: root, high: 0 }); // Uint<256>
        
        // Compute (root + 1)^2
        const next = root + 1 as Uint<128>; // Uint<128> + 1 fits in Uint<128> since root <= 2^128 - 1
        const nextSquareU256 = _mul(U256 { low: next, high: 0 }, U256 { low: next, high: 0 }); // Uint<256>
        
        // Verify: root^2 <= radicand
        assert (!_greaterThan(rootSquareU256, radicand)) "MathU256: sqrt overestimate (root² > radicand)";
        
        // Verify: (root + 1)² > radicand
        assert (_greaterThan(nextSquareU256, radicand)) "MathU256: sqrt underestimate (next root still ≤ radicand)";
        
        return root;
    }

    /**
     * @description Computes the square root of a Uint<256> value, verified on-chain.
     *
     * @param radicand The number to compute the square root of.
     * @returns Uint<128> The square root of radicand.
     */
    export circuit sqrt(radicand: Uint<256>): Uint<128> {
        const radicandU256 = _toU256(radicand);
        return _sqrt(radicandU256);
    }

    /**
     * @description Computes the square root of a U256 value, verified on-chain.
     *
     * @param radicand The U256 value to compute the square root of.
     * @returns Uint<128> The square root of radicand.
     */
    export circuit sqrtU256(radicand: U256): Uint<128> {
        return _sqrt(radicand);
    }

    /**
     * @description Internal implementation to return the minimum of two U256 values.
     *
     * Theoretical Description:
     * This circuit computes the minimum of two 256-bit numbers A = aU256.high * 2^128 + aU256.low
     * and B = bU256.high * 2^128 + bU256.low, where aU256.high, aU256.low, bU256.high,
     * bU256.low are in [0, 2^128 - 1]. It returns the smaller value as a U256 struct.
     *
     * Mathematical Steps:
     * 1. Compare Inputs:
     *    - Use _lessThan to check if A < B.
     * 2. Select Minimum:
     *    - If A < B, return aU256.
     *    - Otherwise, return bU256.
     * The operation involves comparison and conditional selection, with no arithmetic operations
     * beyond the comparison logic. The result is a U256 struct representing min(A, B).
     *
     * @param aU256 The first U256 value.
     * @param bU256 The second U256 value.
     * @returns U256 The smaller of aU256 and bU256.
     */
    circuit _min(aU256: U256, bU256: U256): U256 {
        return _lessThan(aU256, bU256) ? aU256 : bU256;
    }

    /**
     * @description Returns the minimum of two Uint<256> values.
     *
     * @param a The first Uint<256> value.
     * @param b The second Uint<256> value.
     * @returns Uint<256> The smaller of a and b.
     */
    export circuit min(a: Uint<256>, b: Uint<256>): Uint<256> {
        const aU256 = _toU256(a);
        const bU256 = _toU256(b);
        const minU256 = _min(aU256, bU256);
        return _fromU256(minU256);
    }

    /**
     * @description Returns the minimum of two U256 values.
     *
     * @param aU256 The first U256 value.
     * @param bU256 The second U256 value.
     * @returns U256 The smaller of aU256 and bU256.
     */
    export circuit minU256(aU256: U256, bU256: U256): U256 {
        return _min(aU256, bU256);
    }

    /**
     * @description Internal implementation to return the maximum of two U256 values.
     *
     * Theoretical Description:
     * This circuit computes the maximum of two 256-bit numbers A = aU256.high * 2^128 + aU256.low
     * and B = bU256.high * 2^128 + bU256.low, where aU256.high, aU256.low, bU256.high,
     * bU256.low are in [0, 2^128 - 1]. It returns the larger value as a U256 struct.
     *
     * Mathematical Steps:
     * 1. Compare Inputs:
     *    - Use _lessThan to check if A < B.
     * 2. Select Maximum:
     *    - If A < B, return bU256.
     *    - Otherwise, return aU256.
     * The operation involves comparison and conditional selection, with no arithmetic operations
     * beyond the comparison logic. The result is a U256 struct representing max(A, B).
     *
     * @param aU256 The first U256 value.
     * @param bU256 The second U256 value.
     * @returns U256 The larger of aU256 and bU256.
     */
    circuit _max(aU256: U256, bU256: U256): U256 {
        return _lessThan(aU256, bU256) ? bU256 : aU256;
    }

    /**
     * @description Returns the maximum of two Uint<256> values.
     *
     * @param a The first Uint<256> value.
     * @param b The second Uint<256> value.
     * @returns Uint<256> The larger of a and b.
     */
    export circuit max(a: Uint<256>, b: Uint<256>): Uint<256> {
        const aU256 = _toU256(a);
        const bU256 = _toU256(b);
        const maxU256 = _max(aU256, bU256);
        return _fromU256(maxU256);
    }

    /**
     * @description Returns the maximum of two U256 values.
     *
     * @param aU256 The first U256 value.
     * @param bU256 The second U256 value.
     * @returns U256 The larger of aU256 and bU256.
     */
    export circuit maxU256(aU256: U256, bU256: U256): U256 {
        return _max(aU256, bU256);
    }

    /**
     * @description Internal implementation to check if a U256 value is a multiple of another.
     *
     * Theoretical Description:
     * This circuit determines if a 256-bit number N = value.high * 2^128 + value.low is a multiple
     * of another 256-bit number M = divisor.high * 2^128 + divisor.low, where value.high,
     * value.low, divisor.high, divisor.low are in [0, 2^128 - 1]. It returns true if N is a
     * multiple of M (i.e., N mod M = 0), false otherwise.
     *
     * Mathematical Steps:
     * 1. Check for Division by Zero:
     *    - Assert M != 0 (i.e., divisor.high > 0 or divisor.low > 0).
     * 2. Compute Remainder:
     *    - Compute rem = N mod M using _div, where rem is a U256 struct.
     * 3. Check Multiplicity:
     *    - Compare rem to zero (rem.high = 0 and rem.low = 0).
     *    - Return true if rem = 0, false otherwise.
     * The operations include division, comparison, and logical checks. The result is a boolean
     * indicating whether N is a multiple of M.
     *
     * @param value The U256 value to check.
     * @param divisor The U256 divisor to test against.
     * @returns Boolean True if value is a multiple of divisor, false otherwise.
     */
    circuit _isMultiple(value: U256, divisor: U256): Boolean {
        assert (divisor.high > 0 || divisor.low > 0) "MathU256: division by zero";
        const result = _div(value, divisor);
        return result.remainder.high == 0 && result.remainder.low == 0;
    }

    /**
     * @description Checks if a Uint<256> value is a multiple of another.
     *
     * @param value The Uint<256> value to check.
     * @param divisor The Uint<256> divisor to test against.
     * @returns Boolean True if value is a multiple of divisor, false otherwise.
     */
    export circuit isMultiple(value: Uint<256>, divisor: Uint<256>): Boolean {
        const valueU256 = _toU256(value);
        const divisorU256 = _toU256(divisor);
        return _isMultiple(valueU256, divisorU256);
    }

    /**
     * @description Checks if a U256 value is a multiple of another.
     *
     * @param value The U256 value to check.
     * @param divisor The U256 divisor to test against.
     * @returns Boolean True if value is a multiple of divisor, false otherwise.
     */
    export circuit isMultipleU256(value: U256, divisor: U256): Boolean {
        return _isMultiple(value, divisor);
    }
}

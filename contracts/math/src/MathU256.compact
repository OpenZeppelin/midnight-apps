// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

/**
 * @description A utility module providing mathematical operations for 256-bit unsigned integers
 * using the U256 struct, which represents numbers as high * 2^128 + low, where high and low are
 * 128-bit unsigned integers (Uint<128>) in [0, 2^128 - 1]. The module supports a range of
 * operations including conversions, comparisons, arithmetic, division, square root, and utility
 * functions. Operations are provided in dual forms: 
 * one for Uint<256> inputs with conversions to/from U256, and another for direct U256 inputs.
 *
 * Supported Mathematical Operations:
 * - Conversions:
 *   - toU256(): Converts a Uint<256> to a U256 struct by splitting into high and low 128-bit parts.
 *   - fromU256(): Converts a U256 struct to a Uint<256> by combining high and low parts.
 * - Comparisons:
 *   - le(), leU256(): Checks if one 256-bit number is less than another.
 *   - gt(), gtU256(): Checks if one 256-bit number is greater than another.
 * - Arithmetic:
 *   - add(), addU256(): Adds two 256-bit numbers, checking for overflow.
 *   - sub(), subU256(): Subtracts one 256-bit number from another, checking for underflow.
 *   - mul(), mulU256(): Multiplies two 256-bit numbers, checking for overflow.
 * - Division:
 *   - div(), divU256(): Computes the quotient of dividing one 256-bit number by another.
 *   - rem(), remU256(): Computes the remainder of dividing one 256-bit number by another.
 * - Square Root:
 *   - sqrt(), sqrtU256(): Computes the floor of the square root of a 256-bit number, with special cases
 *     for efficiency.
 * - Utility:
 *   - isZero(): Checks if a U256 value equals zero.
 *   - ZERO_U256(): Returns a U256 struct representing zero.
 *   - MAX_U256(): Returns a U256 struct representing the maximum 256-bit value (2^256 - 1).
 *   - min(), minU256:() Returns the smaller of two 256-bit numbers.
 *   - max(), maxU256(): Returns the larger of two 256-bit numbers.
 *   - isMultiple(), isMultipleU256(): Checks if one 256-bit number is a multiple of another.
 * 
 * TODO: Future Operations:
 * - pow(), powU256(): Compute the power of a 256-bit number raised to a given exponent.
 * - fromU256(), toU256(): Needs support of Uint<256> type.
 *
 * @module MathU256
 */
module MathU256 {
    import CompactStandardLibrary;
    
    import "./interfaces/IUint128";
    import "./interfaces/IUint256";
    import "./interfaces/IMathU256";

    import Max prefix Max_;
    import MathU128 prefix MathU128_;

    /**
     * @description Returns a U256 struct representing zero.
     *
     * This circuit returns a U256 struct with all fields set to zero:
     * {low: {0, 0}, high: {0, 0}}, representing the 256-bit value 0.
     * No computations are performed, only struct construction.
     *
     * @returns U256 A U256 struct representing 0.
     */
    export circuit ZERO_U256(): U256 {
        return U256 {
            low: U128 { low: 0, high: 0 },
            high: U128 { low: 0, high: 0 }
        };
    }

    /**
     * @description Returns a U256 struct representing the maximum 256-bit value.
     *
     * This circuit returns a U256 struct with all fields set to MAX_U64 (2^64 - 1):
     * {low: {MAX_U64, MAX_U64}, high: {MAX_U64, MAX_U64}}, representing the 256-bit value
     * 2^256 - 1. No computations are performed, only struct construction using MathU128_MAX_U64.
     *
     * @returns U256 A U256 struct representing 2^256 - 1.
     */
    export circuit MAX_U256(): U256 {
        return U256 {
            low: MathU128_MAX_U128(),
            high: MathU128_MAX_U128()
        };
    }

    /**
     * @description Checks if a U256 value equals zero.
     *
     * This circuit checks if a 256-bit number A = a.high * 2^128 + a.low is zero by verifying
     * that all fields (a.high.low, a.high.high, a.low.low, a.low.high) are zero.
     * Returns true if A = 0, false otherwise. No arithmetic operations are performed,
     * only field comparisons and logical operations (AND).
     *
     * @param a The U256 value to check.
     * @returns Boolean True if a equals zero, false otherwise.
     */
    export circuit isZero(a: U256): Boolean {
        return eq(a, ZERO_U256());
    }

    /**
     * @description Compares two U256 values to check if a == b.
     *
     * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
     * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
     * to determine if A == B. It performs a field-wise comparison of the high and low parts,
     * returning true if A == B, false otherwise. No arithmetic operations are performed,
     * only comparisons and logical operations (AND).
     *
     * The circuit checks if A == B by evaluating:
     * - A.high == B.high (using MathU128_eqU128).
     * - A.low == B.low (using MathU128_eqU128).
     * The result is true only if both conditions hold.
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns Boolean True if a == b, false otherwise.
     */
    export circuit eq(a: U256, b: U256): Boolean {
        return MathU128_eqU128(a.high, b.high) && MathU128_eqU128(a.low, b.low);
    } 

    /**
     * @description Compares two U256 values to check if a <= b.
     *
     * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
     * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
     * to determine if A <= B. It performs a lexicographical comparison by checking the high
     * parts first, then the low parts if the high parts are equal, returning true if A <= B,
     * false otherwise. No arithmetic operations are performed, only comparisons and logical
     * operations (OR, AND).
     *
     * Theoretical Description:
     * The circuit checks if A <= B by evaluating:
     * - A.high < B.high (using MathU128_leU128), or
     * - A.high = B.high (i.e., A.high.low = B.high.low and A.high.high = B.high.high) and
     *   A.low <= B.low (using MathU128_leU128).
     *
     * Mathematical Steps:
     * 1. Compare High Parts:
     *    - If A.high < B.high, return true.
     * 2. Check Equality of High Parts:
     *    - If A.high.low = B.high.low and A.high.high = B.high.high, proceed to low parts.
     * 3. Compare Low Parts:
     *    - If A.low <= B.low, return true.
     * 4. Return Result:
     *    - Otherwise, return false.
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns Boolean True if a <= b, false otherwise.
     */
    export circuit le(a: U256, b: U256): Boolean {
        if (!MathU128_leU128(a.high, b.high)) {
            return false;
        } else if (MathU128_eqU128(a.high, b.high)) {
            return MathU128_leU128(a.low, b.low);
        } else {
            return true;
        }
    }

    /**
     * @description Compares two U256 values to check if a > b.
     *
     * Theoretical Description:
     * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
     * B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1], to determine if A > B. It performs a lexicographical
     * comparison by checking the high parts first, then the low parts if the high parts are
     * equal, returning true if A > B, false otherwise. No arithmetic operations are performed,
     * only comparisons and logical operations (OR, AND).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns Boolean True if a > b, false otherwise.
     */
    export circuit gt(a: U256, b: U256): Boolean {
        return MathU128_gtU128(a.high, b.high) || 
            (a.high.low == b.high.low &&
            a.high.high == b.high.high &&
            MathU128_gtU128(a.low, b.low));
    }

    /**
     * @description Adds two U256 values, checking for overflow.
     *
     * Theoretical Description:
     * This circuit computes the sum S = A + B of two 256-bit numbers represented as U256 structs,
     * where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low, and
     * a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a U256
     * struct {low: S mod 2^128, high: floor(S / 2^128)}.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If A = 0 (using isZero), return B (0 + B = B).
     *    - Else if B = 0 (using isZero), return A (A + 0 = A).
     *    - Else if A = 2^256 - 1 (using MAX_U256) and B = 1 (b.low = {1, 0}, b.high = {0, 0}),
     *      throw "MathU256: addition overflow" (2^256 - 1 + 1 = 2^256).
     * 2. Low Part Addition:
     *    - Compute lowSum = a.low + b.low using MathU128_addU128, where lowSum is in [0, 2^129 - 2].
     *    - Extract carry = floor(lowSum / 2^128) (0 or 1) and lowResult = lowSum mod 2^128.
     * 3. High Part Addition with Carry:
     *    - Compute highSum = a.high + b.high + carry using MathU128_addU128, where highSum is in [0, 2^129 - 1].
     * 4. Overflow Check:
     *    - Assert highSum <= 2^128 - 1 by checking highSum.high = {0, 0}.
     *    - If false, throw "MathU256: addition overflow".
     * 5. Construct Result:
     *    - Return U256 {low: lowResult, high: highSum.low}, representing
     *      S = highSum.low * 2^128 + lowResult.
     *
     * @param a The first U256 value to add.
     * @param b The second U256 value to add.
     * @returns U256 The sum of a and b.
     * @throws MathU256: addition overflow If the sum exceeds 2^256 - 1.
     */
    export circuit add(a: U256, b: U256): U256 {
        // Special case: a = 0, return b
        if (isZero(a)) {
            return b;
        } else if (isZero(b)) {
            return a;
        } else if (eq(a, MAX_U256()) && 
                b.low.low == 1 && b.low.high == 0 && 
                b.high.low == 0 && b.high.high == 0) {
            assert false "MathU256: addition overflow";
            // TODO: Compiler: Should return sth, otherwise will throw an error
            return ZERO_U256();
        } else {
            // General case
            const lowSum = MathU128_addU128(a.low, b.low);
            const carry = lowSum.high.low; // 0 or 1
            const bHighCarrySum = MathU128_addU128(b.high, MathU128_toU128(carry));
            const highSum = MathU128_addU128(a.high, bHighCarrySum.low);
            assert (highSum.high.low == 0 && highSum.high.high == 0) "MathU256: addition overflow";
            return U256 {
                low: lowSum.low,
                high: highSum.low
            };
        }
    }

    /**
     * @description Subtracts one U256 value from another, checking for underflow.
     *
     * Theoretical Description:
     * This circuit computes the difference D = A - B of two 256-bit numbers represented as U256
     * structs, where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low,
     * and a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a
     * U256 struct {low: D mod 2^128, high: floor(D / 2^128)}.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If B = 0 (using isZero), return A (A - 0 = A).
     *    - Else if A = B (using eq), return 0 (ZERO_U256).
     *    - Else if A = 2^256 - 1 (using MAX_U256) and B = 1 (b.low = {1, 0}, b.high = {0, 0}),
     *      return 2^256 - 2 ({low: {MAX_U64 - 1, MAX_U64}, high: {MAX_U64, MAX_U64}}).
     * 2. Check for Underflow:
     *    - Assert A >= B using gt and eq (i.e., A > B or A == B).
     *    - If false, D < 0, throw "MathU256: subtraction underflow".
     * 3. Low Part Subtraction:
     *    - Compute borrow = 1 if a.low < b.low (using MathU128_leU128), else 0.
     *    - If borrow = 0 (a.low >= b.low), compute lowDiff = a.low - b.low using MathU128_subU128.
     *    - If borrow = 1 (a.low < b.low), set lowDiff = 2^128 - 1 (MathU128_MAX_U128) to reflect
     *      borrowing from the high part, ensuring lowDiff is in [0, 2^128 - 1].
     * 4. High Part Subtraction with Borrow:
     *    - Compute highWithBorrow = b.high + borrow using MathU128_addU128.
     *    - Compute highDiff = a.high - highWithBorrow using MathU128_subU128.
     * 5. Construct Result:
     *    - Return U256 {low: lowDiff, high: highDiff}, representing
     *      D = highDiff * 2^128 + lowDiff.
     * The underflow check ensures D >= 0, and the result is in [0, 2^256 - 1].
     *
     * @param a The U256 value to subtract from (minuend).
     * @param b The U256 value to subtract (subtrahend).
     * @returns U256 The difference between a and b.
     * @throws MathU256: subtraction underflow If a < b.
     */
    export circuit sub(a: U256, b: U256): U256 {
        if (isZero(b)) {
            // Special case: b = 0, return a
            return a;
        } else if (eq(a, b)) {
            // Special case: a = b return 0
            return ZERO_U256();
        } else if (eq(a, MAX_U256()) && 
            b.low.low == 1 && b.low.high == 0 && 
            b.high.low == 0 && b.high.high == 0) {
            // Special case: a = MAX_U256, b = 1, returns MAX_U256 - 1
            return U256 {
                low: U128 { 
                    low: Max_U64() - 1, 
                    high: Max_U64() 
                },
                high: U128 { 
                    low: Max_U64(), 
                    high: Max_U64()
                }
            };
        } else {
            // Check for underflow: a must be >= b
            assert (gt(a, b) || eq(a, b)) "MathU256: subtraction underflow";
            
            // Handle low part subtraction with borrow
            const borrow = MathU128_leU128(a.low, b.low) ? 1 : 0;
            const highWithBorrow = MathU128_addU128(b.high, MathU128_toU128(borrow)).low;
            const highDiff = MathU128_subU128(a.high, highWithBorrow);

            if (borrow == 0) {
                const lowDiff = MathU128_subU128(a.low, b.low);
                return U256 { 
                    low: lowDiff, 
                    high: highDiff
                };
            } else {
                return U256 { 
                    low: MathU128_MAX_U128(), 
                    high: highDiff
                };
            }
        }
    }

   
    /**
     * @description Multiplies two U256 values, checking for overflow.
     *
     * Theoretical Description:
     * This circuit computes the product P = A * B of two 256-bit numbers represented as U256
     * structs, where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low,
     * and a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a
     * U256 struct {low: P mod 2^128, high: floor(P / 2^128)}, ensuring P <= 2^256 - 1.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If A = 0 or B = 0 (using isZero), return 0 (ZERO_U256).
     *    - Else if A = 1 (a.low = {1, 0}, a.high = {0, 0}), return B (1 * B = B).
     *    - Else if B = 1 (b.low = {1, 0}, b.high = {0, 0}), return A (A * 1 = A).
     *    - Else if A = 2^256 - 1 (using MAX_U256) and B = 2 (b.low = {2, 0}, b.high = {0, 0}),
     *      throw "MathU256: multiplication overflow" (2^256 - 1 * 2 > 2^256 - 1).
     * 2. Compute Partial Products:
     *    - Compute four partial products using MathU128_mulU128:
     *      ll = a.low * b.low (bits 0-255)
     *      hl = a.high * b.low (bits 128-383)
     *      lh = a.low * b.high (bits 128-383)
     *      hh = a.high * b.high (bits 256-511)
     * 3. Combine Partial Products:
     *    - Add partial products with proper bit alignment using add:
     *      - crossSum = add(hl, lh) (sum of middle terms, bits 128-383)
     *      - crossShifted = {low: 0, high: crossSum.low} (align to bits 128-255)
     *      - lowAndCross = add(ll, crossShifted) (add low and middle terms)
     *      - crossCarry = {low: crossSum.high, high: 0} (carry to bits 256-383)
     *      - hhShifted = add({low: hh.low, high: hh.high}, crossCarry)
     *      - result = add(lowAndCross, hhShifted) (final sum)
     * 4. Overflow Check:
     *    - Assert hhShifted.low = {0, 0} and hhShifted.high = {0, 0} (bits 256-511 are zero).
     *    - Assert result.high <= 2^128 - 1 or (result.high = 2^128 - 1 and result.low <= 2^128 - 1).
     *    - If either fails, throw "MathU256: multiplication overflow".
     * 5. Return Result:
     *    - Return result as a U256 struct.
     *
     * @param a The first U256 value to multiply.
     * @param b The second U256 value to multiply.
     * @returns U256 The product of a and b.
     * @throws MathU256: multiplication overflow If the product exceeds 2^256 - 1.
     */
    export circuit mul(a: U256, b: U256): U256 {
        if (isZero(a) || isZero(b)) {
            // Special case: a = 0 or b = 0, return 0
            return ZERO_U256();
        } else if (a.low.low == 1 && a.low.high == 0 && a.high.low == 0 && a.high.high == 0) {
            // a = 1, return b
            return b;
        } else if (b.low.low == 1 && b.low.high == 0 && b.high.low == 0 && b.high.high == 0) {
            // b = 1, return a
            return a; 
        } else if (eq(a, MAX_U256()) &&
              b.low.low == 2 && b.low.high == 0 &&
              b.high.low == 0 && b.high.high == 0) {
            assert false "MathU256: multiplication overflow";
            return ZERO_U256();
        } else {
            // Compute partial products using MathU128.mulU128
            const ll = MathU128_mulU128(a.low, b.low); // Bits 0-255
            const hl = MathU128_mulU128(a.high, b.low); // Bits 128-383
            const lh = MathU128_mulU128(a.low, b.high); // Bits 128-383
            const hh = MathU128_mulU128(a.high, b.high); // Bits 256-511

            // Combine contributions
            const crossSum = add(hl, lh); // Sum of middle terms
            const crossShifted = U256 { low: MathU128_ZERO_U128(), high: crossSum.low }; // Align to bits 128-255
            const lowAndCross = add(ll, crossShifted); // Add low and middle terms
            const crossCarry = U256 { low: crossSum.high, high: MathU128_ZERO_U128() }; // Carry to bits 256-383
            const high = U256 { low: hh.low, high: hh.high };
            const hhShifted = add(high, crossCarry); // Align hh and add carry
            const result = add(lowAndCross, hhShifted); // Final sum

            // Check for overflow: upper 256 bits must be zero
            assert(
                hhShifted.low.low == 0 
                && hhShifted.low.high == 0 
                && hhShifted.high.low == 0 
                && hhShifted.high.high == 0
            ) "MathU256: multiplication overflow";

            // Additional overflow check
            assert(
                MathU128_leU128(result.high, MathU128_MAX_U128()) ||
                (result.high.low == Max_U128() 
                && result.high.high == 0 
                && MathU128_leU128(result.low, MathU128_MAX_U128()))
            ) "MathU256: multiplication overflow";

            return result;
        }
    }

    /**
     * @description Internal implementation to divide a U256 a by a U256 b, returning quotient and remainder.
     *
     * Theoretical Description:
     * This circuit computes the quotient quot and remainder rem of dividing a 256-bit number
     * divd = a.high * 2^128 + a.low by another 256-bit number
     * divs = b.high * 2^128 + b.low, where a.high, a.low,
     * b.high, b.low are in [0, 2^128 - 1]. The result is a DivResultU256 struct
     * containing quot and rem as U256 structs, satisfying divd = quot * divs + rem with
     * 0 <= rem < divs.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If B = 0 (using isZero), throw "MathU256: division by zero".
     *    - Else if A = 0 (using isZero), return { quotient: ZERO_U256, remainder: ZERO_U256 }.
     *    - Else if B = 1 (b.low = {1, 0}, b.high = {0, 0}), return { quotient: A, remainder: ZERO_U256 }.
     *    - Else if A = B (using eq), return { quotient: {low: {1, 0}, high: {0, 0}}, remainder: ZERO_U256 }.
     *    - Else if A < B (using le), return { quotient: ZERO_U256, remainder: A }.
     * 2. Division Computation:
     *    - Use a division witness (divU256Locally) to compute quot_Uint256 = floor(divd / divs)
     *      and rem_Uint256 = divd mod divs as U256 structs: quotientU256, remainderU256.
     * 3. Verify Remainder:
     *    - Assert remainderU256 <= b using le, ensuring rem < divs.
     * 4. Verify Correctness:
     *    - Compute P = quot * divs using mul.
     *    - Compute S = P + rem using add.
     *    - Assert S = A, ensuring S = divd.
     * 5. Return Result:
     *    - Return DivResultU256 {quotient: quotientU256, remainder: remainderU256}.
     *
     * @param a The U256 value to divide (dividend).
     * @param b The U256 value to divide by (divisor).
     * @returns DivResultU256 The quotient and remainder of the division as U256 structs.
     * @throws MathU256: division by zero If b = 0.
     * @throws MathU256: remainder error If remainder is not less than or equal to b.
     * @throws MathU256: division invalid If quotient * b + remainder does not equal a.
     */
    circuit _div(a: U256, b: U256): DivResultU256 {
        if (isZero(b)) {
            // Special case: division by zero
            assert false "MathU256: division by zero";
            return DivResultU256 {
                quotient: ZERO_U256(),
                remainder: ZERO_U256()
            };
        } else if (isZero(a)) {
            // Dividend is zero: quotient = 0, remainder = 0
            return DivResultU256 {
                quotient: ZERO_U256(),
                remainder: ZERO_U256()
            };
        } else if (b.low.low == 1 && b.low.high == 0 && b.high.low == 0 && b.high.high == 0) {
            // Divisor is one: quotient = a, remainder = 0
            return DivResultU256 {
                quotient: a,
                remainder: ZERO_U256()
            };
        } else if (eq(a, b)) {
            // Dividend equals divisor: quotient = 1, remainder = 0
            return DivResultU256 {
                quotient: U256 { low: U128 { low: 1, high: 0 }, high: U128 { low: 0, high: 0 } },
                remainder: ZERO_U256()
            };
        } else if (le(a, b)) {
            // Dividend less than divisor: quotient = 0, remainder = a
            return DivResultU256 {
                quotient: ZERO_U256(),
                remainder: a
            };
        } else {
            assert(
                b.high.low > 0 
                || b.high.high > 0 
                || b.low.low > 0 
                || b.low.high > 0
            ) "MathU256: division by zero";

            const result = divU256Locally(a, b);

            // Verify remainder < b
            const remainderU256 = result.remainder;
            assert(le(remainderU256, b)) "MathU256: remainder error";

            // Verify: quotient * b + remainder == a
            const quotientU256 = result.quotient;
            const product = mul(quotientU256, b);
            const sum = add(product, remainderU256);

            assert(
                sum.high.low == a.high.low &&
                sum.high.high == a.high.high &&
                sum.low.low == a.low.low &&
                sum.low.high == a.low.high
            ) "MathU256: division invalid";

            return result;
        } 
    }

    /**
     * @description Divides a U256 a by a U256 b, returning quotient.
     *
     * @param a The U256 value to divide.
     * @param b The U256 value to divide by.
     * @returns U256 The quotient of the division.
     */
    export circuit div(a: U256, b: U256): U256 {
        return _div(a, b).quotient;
    }

    /**
     * @description Computes the remainder of dividing a U256 a by a U256 b.
     *
     * @param a The U256 value to divide.
     * @param b The U256 value to divide by.
     * @returns U256 The remainder of the division.
     */
    export circuit rem(a: U256, b: U256): U256 {
        return _div(a, b).remainder;
    }

    export circuit divRem(a: U256, b: U256): DivResultU256 {
        return _div(a, b);
    }

    /**
     * @description Computes the square root of a U256 value, verified on-chain.
     *
     * Theoretical Description:
     * This circuit computes the floor of the square root R = floor(sqrt(N)) of a 256-bit number
     * N = radicand.high * 2^128 + radicand.low, where radicand.high, radicand.low are in
     * [0, 2^128 - 1]. The result is a Uint<128> value R in [0, 2^128 - 1]. It uses the
     * Newton-Raphson method via a witness for the general case and includes special cases for efficiency.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If N = 0 (using isZero), return 0.
     *    - Else if N = 1 (radicand.low = {1, 0}, radicand.high = {0, 0}), return 1.
     *    - Else if N = 2 (radicand.low = {2, 0}, radicand.high = {0, 0}), return 1.
     *    - Else if N = 3 (radicand.low = {3, 0}, radicand.high = {0, 0}), return 1.
     *    - Else if N = 4 (radicand.low = {4, 0}, radicand.high = {0, 0}), return 2.
     *    - Else if N = 9 (radicand.low = {9, 0}, radicand.high = {0, 0}), return 3.
     *    - Else if N = 2^8 - 1 (radicand.low = Max_U8, radicand.high = {0, 0}), return 15.
     *    - Else if N = 2^16 - 1 (radicand.low = Max_U16, radicand.high = {0, 0}), return 255.
     *    - Else if N = 2^32 - 1 (radicand.low = Max_U32, radicand.high = {0, 0}), return 65535.
     *    - Else if N = 2^64 - 1 (radicand.low = Max_U64, radicand.high = {0, 0}), return 4294967295.
     *    - Else if N = 2^128 - 1 (radicand.low = Max_U128, radicand.high = {0, 0}), return 2^64 - 1.
     *    - Else if N = 1000000 (radicand.low = {1000000, 0}, radicand.high = {0, 0}), return 1000.
     *    - Else if N = 2^256 - 1 (using MAX_U256), return 2^128 - 1.
     * 2. General Case:
     *    - Compute R = floor(sqrt(N)) using a Newton-Raphson witness (sqrtU256Locally).
     * 3. Verify Correctness:
     *    - Compute R^2 using MathU128_mul with R as a U256 struct {low: R, high: 0}.
     *    - Compute (R + 1)^2 with R + 1 as a U256 struct {low: R + 1, high: 0}.
     *    - Assert R^2 <= N using !gt, ensuring R^2 <= N.
     *    - Assert (R + 1)^2 > N using gt, ensuring (R + 1)^2 > N.
     * 4. Return Result:
     *    - Return R as Uint<128>.
     *
     * @param radicand The U256 value to compute the square root of.
     * @returns Uint<128> The floor of the square root of radicand.
     * @throws MathU256: sqrt overestimate If R^2 > N.
     * @throws MathU256: sqrt underestimate If (R + 1)^2 <= N.
     */
    export circuit sqrt(radicand: U256): Uint<128> {
        if (isZero(radicand)) {
            return 0;
        } else if (radicand.low.low == 1 && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 1;
        } else if (radicand.low.low == 2 && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 1;
        } else if (radicand.low.low == 3 && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 1;
        } else if (radicand.low.low == 4 && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 2;
        } else if (radicand.low.low == 9 && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 3;
        } else if (radicand.low.low == Max_U8() && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 15;
        } else if (radicand.low.low == Max_U16() && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 255;
        } else if (radicand.low.low == Max_U32() && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 65535;
        } else if (radicand.low.low == Max_U64() && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 4294967295;
        } else if (radicand.low.low == Max_U128() && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 18446744073709551615;
        } else if (radicand.low.low == 1000000 && radicand.low.high == 0 && radicand.high.low == 0 && radicand.high.high == 0) {
            return 1000;
        } else if (eq(radicand, MAX_U256())) {
            return Max_U128();
        } else {
            const root = sqrtU256Locally(radicand);
            const rootSquareU256 = MathU128_mul(root, root);
            assert(!gt(rootSquareU256, radicand)) "MathU256: sqrt overestimate";

            const next = MathU128_add(root, 1);
            const nextSquareU256 = mul(next, next);
            assert(gt(nextSquareU256, radicand)) "MathU256: sqrt underestimate";

            return root;
        }
    }

    /**
     * @description Returns the minimum of two U256 values.
     *
     * Theoretical Description:
     * This circuit computes the minimum of two 256-bit numbers A = a.high * 2^128 + a.low
     * and B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1]. It returns the smaller value as a U256 struct.
     *
     * Mathematical Steps:
     * 1. Compare Inputs:
     *    - Use le to check if A < B.
     * 2. Select Minimum:
     *    - If A < B, return a.
     *    - Otherwise, return b.
     * The operation involves comparison and conditional selection, with no arithmetic operations
     * beyond the comparison logic. The result is a U256 struct representing min(A, B).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns U256 The smaller of a and b.
     */
    export circuit min(a: U256, b: U256): U256 {
        return le(a, b) ? a : b;
    }

    /**
     * @description Returns the maximum of two U256 values.
     *
     * Theoretical Description:
     * This circuit computes the maximum of two 256-bit numbers A = a.high * 2^128 + a.low
     * and B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1]. It returns the larger value as a U256 struct.
     *
     * Mathematical Steps:
     * 1. Compare Inputs:
     *    - Use le to check if A < B.
     * 2. Select Maximum:
     *    - If A < B, return b.
     *    - Otherwise, return a.
     * The operation involves comparison and conditional selection, with no arithmetic operations
     * beyond the comparison logic. The result is a U256 struct representing max(A, B).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns U256 The larger of a and b.
     */
    export circuit max(a: U256, b: U256): U256 {
        return le(a, b) ? b : a;
    }

    /**
     * @description Checks if a U256 value is a multiple of another.
     *
     * Theoretical Description:
     * This circuit determines if a 256-bit number N = value.high * 2^128 + value.low is a multiple
     * of another 256-bit number M = b.high * 2^128 + b.low, where value.high,
     * value.low, b.high, b.low are in [0, 2^128 - 1]. It returns true if N is a
     * multiple of M (i.e., N mod M = 0), false otherwise.
     *
     * Mathematical Steps:
     * 1. Check for Division by Zero:
     *    - Assert M != 0 (i.e., b.high > 0 or b.low > 0).
     * 2. Compute Remainder:
     *    - Compute rem = N mod M using _div, where rem is a U256 struct.
     * 3. Check Multiplicity:
     *    - Compare rem to zero (rem.high = 0 and rem.low = 0).
     *    - Return true if rem = 0, false otherwise.
     * The operations include division, comparison, and logical checks. The result is a boolean
     * indicating whether N is a multiple of M.
     *
     * @param value The U256 value to check.
     * @param b The U256 b to test against.
     * @returns Boolean True if value is a multiple of b, false otherwise.
     */
    export circuit isMultiple(value: U256, b: U256): Boolean {
        assert(
            b.high.low > 0 
            || b.high.high > 0 
            || b.low.low > 0 
            || b.low.high > 0
        ) "MathU256: division by zero";
        const result = _div(value, b);
        return result.remainder.high.low == 0 
            && result.remainder.high.high == 0 
            && result.remainder.low.low == 0 
            && result.remainder.low.high == 0;
    }
}

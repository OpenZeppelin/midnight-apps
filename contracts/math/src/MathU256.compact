// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

/**
 * @description A utility module providing mathematical operations for 256-bit unsigned integers
 * using the U256 struct, which represents numbers as high * 2^128 + low, where high and low are
 * 128-bit unsigned integers (Uint<128>) in [0, 2^128 - 1]. The module supports a range of
 * operations including conversions, comparisons, arithmetic, division, square root, and utility
 * functions. Operations are provided in dual forms: 
 * one for Uint<256> inputs with conversions to/from U256, and another for direct U256 inputs.
 *
 * Supported Mathematical Operations:
 * - Conversions:
 *   - toU256(): Converts a Uint<256> to a U256 struct by splitting into high and low 128-bit parts.
 *   - fromU256(): Converts a U256 struct to a Uint<256> by combining high and low parts.
 * - Comparisons:
 *   - le(), leU256(): Checks if one 256-bit number is less than another.
 *   - gt(), gtU256(): Checks if one 256-bit number is greater than another.
 * - Arithmetic:
 *   - add(), addU256(): Adds two 256-bit numbers, checking for overflow.
 *   - sub(), subU256(): Subtracts one 256-bit number from another, checking for underflow.
 *   - mul(), mulU256(): Multiplies two 256-bit numbers, checking for overflow.
 * - Division:
 *   - div(), divU256(): Computes the quotient of dividing one 256-bit number by another.
 *   - rem(), remU256(): Computes the remainder of dividing one 256-bit number by another.
 * - Square Root:
 *   - sqrt(), sqrtU256(): Computes the floor of the square root of a 256-bit number, with special cases
 *     for efficiency.
 * - Utility:
 *   - min(), minU256:() Returns the smaller of two 256-bit numbers.
 *   - max(), maxU256(): Returns the larger of two 256-bit numbers.
 *   - isMultiple(), isMultipleU256(): Checks if one 256-bit number is a multiple of another.
 * 
 * TODO: Future Operations:
 * - pow(), powU256(): Compute the power of a 256-bit number raised to a given exponent.
 * - fromU256(), toU256(): Needs support of Uint<256> type.
 *
 * @module MathU256
 */
module MathU256 {
    import CompactStandardLibrary;
    
    import "./interfaces/IUint256";
    import "./interfaces/IMathU256";

    import Max prefix Max_;
    import MathU128 prefix MathU128_;

    /**
     * @description Compares two U256 values to check if a == b.
     *
     * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
     * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
     * to determine if A == B. It performs a field-wise comparison of the high and low parts,
     * returning true if A == B, false otherwise. No arithmetic operations are performed,
     * only comparisons and logical operations (AND).
     *
     * The circuit checks if A == B by evaluating:
     * - A.high == B.high (using MathU128_eqU128).
     * - A.low == B.low (using MathU128_eqU128).
     * The result is true only if both conditions hold.
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns Boolean True if a == b, false otherwise.
     */
    export circuit eq(a: U256, b: U256): Boolean {
        return MathU128_eqU128(a.high, b.high) && MathU128_eqU128(a.low, b.low);
    } 

    /**
     * @description Compares two U256 values to check if a <= b.
     *
     * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
     * B = b.high * 2^128 + b.low, where a.high, a.low, b.high, b.low are in [0, 2^128 - 1],
     * to determine if A <= B. It performs a lexicographical comparison by checking the high
     * parts first, then the low parts if the high parts are equal, returning true if A <= B,
     * false otherwise. No arithmetic operations are performed, only comparisons and logical
     * operations (OR, AND).
     *
     * Theoretical Description:
     * The circuit checks if A <= B by evaluating:
     * - A.high < B.high (using MathU128_leU128), or
     * - A.high = B.high (i.e., A.high.low = B.high.low and A.high.high = B.high.high) and
     *   A.low <= B.low (using MathU128_leU128).
     *
     * Mathematical Steps:
     * 1. Compare High Parts:
     *    - If A.high < B.high, return true.
     * 2. Check Equality of High Parts:
     *    - If A.high.low = B.high.low and A.high.high = B.high.high, proceed to low parts.
     * 3. Compare Low Parts:
     *    - If A.low <= B.low, return true.
     * 4. Return Result:
     *    - Otherwise, return false.
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns Boolean True if a <= b, false otherwise.
     */
    export circuit le(a: U256, b: U256): Boolean {
        return MathU128_leU128(a.high, b.high) || 
            (a.high.low == b.high.low && 
                a.high.high == b.high.high && 
                MathU128_leU128(a.low, b.low));
    }

    /**
     * @description Compares two U256 values to check if a > b.
     *
     * Theoretical Description:
     * This circuit compares two 256-bit numbers A = a.high * 2^128 + a.low and
     * B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1], to determine if A > B. It performs a lexicographical
     * comparison by checking the high parts first, then the low parts if the high parts are
     * equal, returning true if A > B, false otherwise. No arithmetic operations are performed,
     * only comparisons and logical operations (OR, AND).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns Boolean True if a > b, false otherwise.
     */
    export circuit gt(a: U256, b: U256): Boolean {
        return MathU128_gtU128(a.high, b.high) || 
            (a.high.low == b.high.low &&
            a.high.high == b.high.high &&
            MathU128_gtU128(a.low, b.low));
    }

    /**
     * @description Adds two U256 values, checking for overflow.
     *
     * Theoretical Description:
     * This circuit computes the sum S = A + B of two 256-bit numbers represented as U256 structs,
     * where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low, and
     * a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a U256
     * struct {low: S mod 2^128, high: floor(S / 2^128)}.
     *
     * Mathematical Steps:
     * 1. Low Part Addition:
     *    - Compute lowSum = a.low + b.low, where a.low, b.low are in
     *      [0, 2^128 - 1], so lowSum is in [0, 2^129 - 2].
     *    - Split lowSum into carry = floor(lowSum / 2^128) (0 or 1) and
     *      lowResult = lowSum mod 2^128.
     * 2. High Part Addition with Carry:
     *    - Compute highSum = a.high + b.high + carry, where a.high,
     *      b.high are in [0, 2^128 - 1] and carry is 0 or 1, so highSum is in
     *      [0, 2^129 - 1].
     * 3. Overflow Check:
     *    - Ensure S = highSum * 2^128 + lowResult <= 2^256 - 1.
     *    - Assert highSum <= 2^128 - 1 by checking floor(highSum / 2^128) = 0.
     *    - If false, S > (2^128 - 1) * 2^128 + (2^128 - 1) = 2^256 - 1, throw
     *      "MathU256: addition overflow".
     * 4. Construct Result:
     *    - Return U256 {low: lowResult, high: highSum}, representing
     *      S = highSum * 2^128 + lowResult.
     *
     * @param a The first U256 value to add.
     * @param b The second U256 value to add.
     * @returns U256 The sum of a and b.
     * @throws MathU256: addition overflow If the sum exceeds 2^256 - 1.
     */
    export circuit add(a: U256, b: U256): U256 {
        // Add the low parts as Uint<256> to handle potential carry
        const lowSum = MathU128_addU128(a.low, b.low);
        
        // Split lowSumFull into high and low parts to get the carry
        const carry = lowSum.high.low; // 0 or 1, since lowSumFull <= 2^129 - 2
        
        // Add the high parts plus the carry
        // a.high + b.high + carry
        const bHighCarrySum = MathU128_addU128(b.high, MathU128_toU128(carry));
        const highSum = MathU128_addU128(a.high, bHighCarrySum.low);
    
        // Check for overflow: highSumFull must fit in 128 bits (i.e., highSumFull.high == 0)
        assert (highSum.high.low == 0 && highSum.high.high == 0) "MathU256: addition overflow";
        
        return U256 {
            low: lowSum.low,
            high: highSum.low
        };
    }

    /**
     * @description Subtracts one U256 value from another, checking for underflow.
     *
     * Theoretical Description:
     * This circuit computes the difference D = A - B of two 256-bit numbers represented as U256
     * structs, where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low,
     * and a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a
     * U256 struct {low: D mod 2^128, high: floor(D / 2^128)}.
     *
     * Mathematical Steps:
     * 1. Check for Underflow:
     *    - Assert A >= B (i.e., not A < B) using le.
     *    - If false, D < 0, throw "MathU256: subtraction underflow".
     * 2. Low Part Subtraction:
     *    - Compute borrow = 1 if a.low < b.low, else 0.
     *    - If a.low >= b.low, compute lowDiff = a.low - b.low.
     *    - Else, compute lowDiff = a.low + 2^128 - b.low, ensuring
     *      lowDiff is in [0, 2^128 - 1] via modular arithmetic.
     * 3. High Part Subtraction with Borrow:
     *    - Compute highDiff = a.high - b.high - borrow.
     * 4. Construct Result:
     *    - Return U256 {low: lowDiff, high: highDiff}, representing
     *      D = highDiff * 2^128 + lowDiff.
     * The underflow check ensures D >= 0, and the result is in [0, 2^256 - 1].
     *
     * @param a The U256 value to subtract from (minuend).
     * @param b The U256 value to subtract (subtrahend).
     * @returns U256 The difference between a and b.
     */
    export circuit sub(a: U256, b: U256): U256 {
        // Check for underflow: a must be >= b
        assert (!le(a, b)) "MathU256: subtraction underflow";
        
        // Handle low part subtraction with borrow
        const borrow = MathU128_leU128(a.low, b.low) ? 1 : 0;
        const lowDiff = MathU128_subU128(a.low, b.low);
        const highWithBorrow = MathU128_addU128(b.high, MathU128_toU128(borrow)).low;
        const highDiff = MathU128_subU128(a.high, highWithBorrow);

        return U256 {
            low: lowDiff,
            high: highDiff
        };
    }

   
    /**
     * @description Multiply two U256 values, checking for overflow.
     *
     * Theoretical Description:
     * This circuit computes the product P = A * B of two 256-bit numbers represented as U256
     * structs, where A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low,
     * and a.high, a.low, b.high, b.low are in [0, 2^128 - 1]. The result is a
     * U256 struct {low: P mod 2^128, high: floor(P / 2^128)}, ensuring P <= 2^256 - 1.
     *
     * Mathematical Steps:
     * 1. Compute Partial Products:
     *    - Represent A = a.high * 2^128 + a.low, B = b.high * 2^128 + b.low.
     *    - Compute four partial products using Math_mul (128-bit to 256-bit multiplication):
     *      ll = a.low * b.low (bits 0-255)
     *      hl = a.high * b.low (bits 128-383)
     *      lh = a.low * b.high (bits 128-383)
     *      hh = a.high * b.high (bits 256-511)
     *    - Each partial product is a Uint<256> in [0, (2^128 - 1)^2].
     * 2. Convert Partial Products to U256:
     *    - Convert each partial product to a U256 struct using toU256:
     *      llU256 = {low: ll mod 2^128, high: floor(ll / 2^128)}
     *      Similarly for hlU256, lhU256, hhU256.
     * 3. Combine Partial Products:
     *    - Add partial products with proper bit alignment using _add:
     *      - crossSum = _add(hlU256, lhU256) (sum of middle terms, bits 128-383)
     *      - crossShifted = {low: 0, high: crossSum.low} (align to bits 128-255)
     *      - lowAndCross = _add(llU256, crossShifted) (add low and middle terms)
     *      - crossCarry = {low: crossSum.high, high: 0} (carry to bits 256-383)
     *      - hhShiftedU256 = _add({low: hhU256.low, high: hhU256.high}, crossCarry)
     *        (align hh and add carry)
     *      - resultU256 = _add(lowAndCross, hhShiftedU256) (final sum)
     * 4. Overflow Check:
     *    - Ensure P = resultU256.high * 2^128 + resultU256.low <= 2^256 - 1.
     *    - Assert hhShiftedU256.low = 0 and hhShiftedU256.high = 0, ensuring bits
     *      256-511 are zero.
     *    - If false, P > 2^256 - 1, throw "MathU256: multiplication overflow".
     *    - Additional check: resultU256.high < 2^128 - 1 or (resultU256.high = 2^128 - 1
     *      and resultU256.low <= 2^128 - 1).
     * 5. Return Result:
     *    - Return resultU256 as a U256 struct.
     *
     * @param a The first U256 value to multiply.
     * @param b The second U256 value to multiply.
     * @returns U256 The product of a and b.
     * @throws MathU256: multiplication overflow If the product exceeds 2^256 - 1.
     */
    export circuit mul(a: U256, b: U256): U256 {
        // Compute partial products using MathU128.mulU128
        const ll = MathU128_mulU128(a.low, b.low); // Bits 0-255
        const hl = MathU128_mulU128(a.high, b.low); // Bits 128-383
        const lh = MathU128_mulU128(a.low, b.high); // Bits 128-383
        const hh = MathU128_mulU128(a.high, b.high); // Bits 256-511

        // Combine contributions
        const crossSum = add(hl, lh); // Sum of middle terms
        const crossShifted = U256 { low: MathU128_ZERO_U128(), high: crossSum.low }; // Align to bits 128-255
        const lowAndCross = add(ll, crossShifted); // Add low and middle terms
        const crossCarry = U256 { low: crossSum.high, high: MathU128_ZERO_U128() }; // Carry to bits 256-383
        const high = U256 { low: hh.low, high: hh.high };
        const hhShifted = add(high, crossCarry); // Align hh and add carry
        const result = add(lowAndCross, hhShifted); // Final sum

        // Check for overflow: upper 256 bits must be zero
        assert(hhShifted.low.low == 0 
           && hhShifted.low.high == 0 
           && hhShifted.high.low == 0 
           && hhShifted.high.high == 0
        ) "MathU256: multiplication overflow";

        // Additional overflow check
        assert(
            MathU128_leU128(result.high, MathU128_MAX_U128()) ||
            (result.high.low == Max_U128() 
            && result.high.high == 0 
            && MathU128_leU128(result.low, MathU128_MAX_U128()))
        ) "MathU256: multiplication overflow";

        return result;
    }

    /**
     * @description Internal implementation to divide a U256 a by a U256 b, returning quotient and remainder.
     *
     * Theoretical Description:
     * This circuit computes the quotient quot and remainder rem of dividing a 256-bit number
     * divd = a.high * 2^128 + a.low by another 256-bit number
     * divs = b.high * 2^128 + b.low, where a.high, a.low,
     * b.high, b.low are in [0, 2^128 - 1]. The result is a DivResultU256 struct
     * containing quot and rem as U256 structs, satisfying divd = quot * divs + rem with
     * 0 <= rem < divs.
     *
     * Mathematical Steps:
     * 1. Check for Division by Zero:
     *    - Assert divs != 0 (i.e., b.high > 0 or b.low > 0).
     * 2. Convert Inputs to Uint<256>:
     *    - Compute divd_Uint256 = a.high * 2^128 + a.low using fromU256.
     *    - Compute divs_Uint256 = b.high * 2^128 + b.low using fromU256.
     * 3. Compute Division:
     *    - Use a division witness (divU256Locally) to compute quot_Uint256 = floor(divd / divs)
     *      and rem_Uint256 = divd mod divs, both as Uint<256> values.
     * 4. Convert Results to U256:
     *    - Convert quot_Uint256 and rem_Uint256 to U256 structs: quotientU256, remainderU256.
     * 5. Verify Remainder:
     *    - Assert remainderU256 < b using le, ensuring rem < divs.
     * 6. Verify Correctness:
     *    - Compute P = quot * divs using _mul.
     *    - Compute S = P + rem using _add.
     *    - Assert S.high = a.high and S.low = a.low, ensuring
     *      S = divd.
     * 7. Return Result:
     *    - Return DivResultU256 {quotient: quotientU256, remainder: remainderU256}.
     * The operations include division, modulus, multiplication, addition, comparison, and
     * conversion.
     *
     * @param a The U256 value to divide.
     * @param b The U256 value to divide by.
     * @returns DivResultU256 The quotient and remainder of the division as U256 structs.
     */
    circuit _div(a: U256, b: U256): DivResultU256 {
        assert(
            b.high.low > 0 
            || b.high.high > 0 
            || b.low.low > 0 
            || b.low.high > 0
        ) "MathU256: division by zero";

        const result = divU256Locally(a, b);

        // Verify remainder < b
        const remainderU256 = result.remainder;
        assert(le(remainderU256, b)) "MathU256: remainder error";

        // Verify: quotient * b + remainder == a
        const quotientU256 = result.quotient;
        const product = mul(quotientU256, b);
        const sum = add(product, remainderU256);

        assert(
            sum.high.low == a.high.low &&
            sum.high.high == a.high.high &&
            sum.low.low == a.low.low &&
            sum.low.high == a.low.high
        ) "MathU256: division invalid";

        return result;
    }

    /**
     * @description Divides a U256 a by a U256 b, returning quotient.
     *
     * @param a The U256 value to divide.
     * @param b The U256 value to divide by.
     * @returns U256 The quotient of the division.
     */
    export circuit div(a: U256, b: U256): U256 {
        return _div(a, b).quotient;
    }

    /**
     * @description Computes the remainder of dividing a U256 a by a U256 b.
     *
     * @param a The U256 value to divide.
     * @param b The U256 value to divide by.
     * @returns U256 The remainder of the division.
     */
    export circuit rem(a: U256, b: U256): U256 {
        return _div(a, b).remainder;
    }

    export circuit divRem(a: U256, b: U256): DivResultU256 {
        return _div(a, b);
    }

    /**
     * @description Computes the square root of a U256 value, verified on-chain.
     *
     * Theoretical Description:
     * This circuit computes the floor of the square root R = floor(sqrt(N)) of a 256-bit number
     * N = radicand.high * 2^128 + radicand.low, where radicand.high, radicand.low are in
     * [0, 2^128 - 1]. The result is a Uint<128> value R in [0, 2^128 - 1]. It uses the
     * Newton-Raphson method via a witness and includes special cases for efficiency.
     *
     * Mathematical Steps:
     * 1. Handle Special Cases:
     *    - If N = 0 (radicand.high = 0, radicand.low = 0), return 0.
     *    - If N = 1 (radicand.high = 0, radicand.low = 1), return 1.
     *    - If N = 2^8 - 1 (radicand.high = 0, radicand.low = Max_U8), return 15.
     *    - If N = 2^16 - 1 (radicand.high = 0, radicand.low = Max_U16), return 255.
     *    - If N = 2^32 - 1 (radicand.high = 0, radicand.low = Max_U32), return 65535.
     *    - If N = 2^64 - 1 (radicand.high = 0, radicand.low = Max_U64), return 4294967295.
     *    - If N = 2^128 - 1 (radicand.high = 0, radicand.low = Max_U128), return
     *      18446744073709551615.
     *    - If N = 2^256 - 1 (radicand.high = Max_U128, radicand.low = Max_U128), return
     *      Max_U128 (2^128 - 1).
     * 2. General Case:
     *    - Convert N to Uint<256>: N_Uint256 = radicand.high * 2^128 + radicand.low using
     *      fromU256.
     *    - Compute R = floor(sqrt(N_Uint256)) using a Newton-Raphson witness (sqrtU256Locally).
     * 3. Verify Correctness:
     *    - Compute R^2 using _mul with R as a U256 struct {low: R, high: 0}.
     *    - Compute (R + 1)^2, where R + 1 is in [0, 2^128], using _mul with R + 1 as
     *      a U256 struct {low: R + 1, high: 0}.
     *    - Assert R^2 <= N (i.e., not gt), ensuring R^2 <= N.
     *    - Assert (R + 1)^2 > N using gt, ensuring (R + 1)^2 > N.
     * 4. Return Result:
     *    - Return R as Uint<128>.
     * The operations include square root computation, multiplication, comparison, and conversion.
     * The checks ensure R^2 <= N < (R + 1)^2, confirming R = floor(sqrt(N)).
     *
     * @param radicand The U256 value to compute the square root of.
     * @returns Uint<128> The square root of radicand.
     */
    export circuit sqrt(radicand: U256): Uint<128> {
        if (radicand.high.low == 0 && radicand.high.high == 0 && radicand.low.low == 0 && radicand.low.high == 0) {
            return 0;
        }

        if (radicand.high.low == 0 && radicand.high.high == 0 && radicand.low.low == 1 && radicand.low.high == 0) {
            return 1;
        }

        if (radicand.high.low == 0 && radicand.high.high == 0 && radicand.low.low == Max_U8() && radicand.low.high == 0) {
            return 15;
        }

        if (radicand.high.low == 0 && radicand.high.high == 0 && radicand.low.low == Max_U16() && radicand.low.high == 0) {
            return 255;
        }

        if (radicand.high.low == 0 && radicand.high.high == 0 && radicand.low.low == Max_U32() && radicand.low.high == 0) {
            return 65535;
        }

        if (radicand.high.low == 0 && radicand.high.high == 0 && radicand.low.low == Max_U64() && radicand.low.high == 0) {
            return 4294967295;
        }

        if (radicand.high.low == 0 && radicand.high.high == 0 && radicand.low.low == Max_U128() && radicand.low.high == 0) {
            return 18446744073709551615;
        }

        const maxU256 = U256 { low: MathU128_MAX_U128(), high: MathU128_MAX_U128() };
        if (radicand.high.low == maxU256.high.low && radicand.high.high == maxU256.high.high &&
            radicand.low.low == maxU256.low.low && radicand.low.high == maxU256.low.high) {
            return Max_U128();
        }

        const root = sqrtU256Locally(radicand);
        const rootSquareU256 = MathU128_mul(root, root);
        assert(!gt(rootSquareU256, radicand)) "MathU256: sqrt overestimate";

        const next = MathU128_add(root, 1);
        const nextSquareU256 = mul(next, next);
        assert(gt(nextSquareU256, radicand)) "MathU256: sqrt underestimate";

        return root;
    }

    /**
     * @description Returns the minimum of two U256 values.
     *
     * Theoretical Description:
     * This circuit computes the minimum of two 256-bit numbers A = a.high * 2^128 + a.low
     * and B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1]. It returns the smaller value as a U256 struct.
     *
     * Mathematical Steps:
     * 1. Compare Inputs:
     *    - Use le to check if A < B.
     * 2. Select Minimum:
     *    - If A < B, return a.
     *    - Otherwise, return b.
     * The operation involves comparison and conditional selection, with no arithmetic operations
     * beyond the comparison logic. The result is a U256 struct representing min(A, B).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns U256 The smaller of a and b.
     */
    export circuit min(a: U256, b: U256): U256 {
        return le(a, b) ? a : b;
    }

    /**
     * @description Returns the maximum of two U256 values.
     *
     * Theoretical Description:
     * This circuit computes the maximum of two 256-bit numbers A = a.high * 2^128 + a.low
     * and B = b.high * 2^128 + b.low, where a.high, a.low, b.high,
     * b.low are in [0, 2^128 - 1]. It returns the larger value as a U256 struct.
     *
     * Mathematical Steps:
     * 1. Compare Inputs:
     *    - Use le to check if A < B.
     * 2. Select Maximum:
     *    - If A < B, return b.
     *    - Otherwise, return a.
     * The operation involves comparison and conditional selection, with no arithmetic operations
     * beyond the comparison logic. The result is a U256 struct representing max(A, B).
     *
     * @param a The first U256 value.
     * @param b The second U256 value.
     * @returns U256 The larger of a and b.
     */
    export circuit max(a: U256, b: U256): U256 {
        return le(a, b) ? b : a;
    }

    /**
     * @description Checks if a U256 value is a multiple of another.
     *
     * Theoretical Description:
     * This circuit determines if a 256-bit number N = value.high * 2^128 + value.low is a multiple
     * of another 256-bit number M = b.high * 2^128 + b.low, where value.high,
     * value.low, b.high, b.low are in [0, 2^128 - 1]. It returns true if N is a
     * multiple of M (i.e., N mod M = 0), false otherwise.
     *
     * Mathematical Steps:
     * 1. Check for Division by Zero:
     *    - Assert M != 0 (i.e., b.high > 0 or b.low > 0).
     * 2. Compute Remainder:
     *    - Compute rem = N mod M using _div, where rem is a U256 struct.
     * 3. Check Multiplicity:
     *    - Compare rem to zero (rem.high = 0 and rem.low = 0).
     *    - Return true if rem = 0, false otherwise.
     * The operations include division, comparison, and logical checks. The result is a boolean
     * indicating whether N is a multiple of M.
     *
     * @param value The U256 value to check.
     * @param b The U256 b to test against.
     * @returns Boolean True if value is a multiple of b, false otherwise.
     */
    export circuit isMultiple(value: U256, b: U256): Boolean {
        assert(
            b.high.low > 0 
            || b.high.high > 0 
            || b.low.low > 0 
            || b.low.high > 0
        ) "MathU256: division by zero";
        const result = _div(value, b);
        return result.remainder.high.low == 0 
            && result.remainder.high.high == 0 
            && result.remainder.low.low == 0 
            && result.remainder.low.high == 0;
    }
}

pragma language_version >= 0.14.0;

/**
 * @module AccessControl
 * @description Manages role-based access control using a Merkle tree to store role commitments.
 * Provides circuits for granting and revoking roles, with Admin-only restrictions.
 */
module AccessControl {
    import CompactStandardLibrary;
    import "../node_modules/@midnight-dapps/structs-contracts/dist/Queue"<Uint<64>> prefix Queue_;

    /**
     * @description Defines the possible roles a user can have in the system.
     * @enum {number}
     */
    export enum Role {
        Admin,
        Lp,
        Trader,
        None
    };

    /**
     * @description Indicates whether the contract has been initialized.
     * @type {Boolean}
     */
    export ledger isInitialized: Boolean;

    /**
     * @description Merkle tree storing commitments of user-role pairs, with a fixed depth of 10.
     * @type {MerkleTree<10, Bytes<32>>}
     */
    export ledger roleCommits: MerkleTree<10, Bytes<32>>;

    /**
     * @description A set of nullifiers tracking granted user-role pairs to prevent duplicate role assignments.
     * @type {Set<Bytes<32>>}
     * @remarks - Uses a hash of user, role, and secret key (without index) to uniquely identify role assignments.
     *          Inserted during grantRole and removed during revokeRole.
     *          - Used within grantRole for preventing double assignment. Note the difference with 
     *          `userRoleIndexNullifier` which can't be used inside grantRole to check the same issue, because
     *          when granting new role for a user there won't be an index existing yet. 
     */
    export ledger userRoleNullifier: Set<Bytes<32>>;

    /**
     * @description A set of nullifiers tracking user-role-index triplets to ensure accurate role revocation.
     * @type {Set<Bytes<32>>}
     * @remarks Uses a hash of user, role, index, and secret key to bind a role to its specific Merkle tree index.
     *          Inserted during grantRole and removed during revokeRole to validate index-specific revocation.
     */
    export ledger userRoleIndexNullifier: Set<Bytes<32>>;

    /**
     * @description Counter tracking the next available index for inserting into the role tree.
     * @type {Counter}
     */
    export ledger index: Counter;

    /**
     * @description Witness function to update a user’s role and its index in private state.
     * @param {Bytes<32>} userRoleCommit - The commitment hash of the user-role pair.
     * @param {Role} role - The role to set.
     * @param {Uint<64>} index - The index in the Merkle tree.
     * @returns {[]} - An empty array indicating success.
     */
    export witness updateRole(userRoleCommit: Bytes<32>, role: Role, index: Uint<64>): [];

    /**
     * @description Witness function to retrieve the Merkle path for a user-role commitment.
     * @param {Bytes<32>} userRoleCommit - The commitment hash of the user-role pair.
     * @returns {Maybe<MerkleTreePath<10, Bytes<32>>>} - The path if it exists, otherwise None.
     */
    export witness getRolePath(userRoleCommit: Bytes<32>): Maybe<MerkleTreePath<10, Bytes<32>>>;

    /**
     * @description Witness to provide user’s secret key for nullifier generation.
     */
    export witness getSecretKey(): Bytes<32>;

    /**
     * @description Initializes the AccessControl contract by granting the Admin role to an initial user.
     * @param {ZswapCoinPublicKey} initialAdmin - The public key of the initial admin.
     * @returns {[]} - An empty array indicating success.
     * @throws {RoleError} - If the contract is already initialized.
     */
    export circuit initialize(initialAdmin: ZswapCoinPublicKey): [] {
        assert (!isInitialized) "AccessControl: AccessControl contract is initialized!";
        isInitialized = true;
        return _grantRole(initialAdmin, Role.Admin);
    }

    /**
     * @description Grants a role to a user, restricted to Admin callers.
     * @param {ZswapCoinPublicKey} user - The public key of the user to grant the role to.
     * @param {Role} role - The role to grant (Admin, Lp, Trader, or None).
     * @returns {[]} - An empty array indicating success.
     * @throws {RoleError} - If the contract is not initialized, caller is not Admin, role tree is full,
     *                       or the role is already granted (checked via userRoleNullifier).
     * @remarks Inserts the role commitment into the Merkle tree at either the next index (if queue is empty)
     *          or a reused index from the queue. Adds nullifiers to both userRoleNullifier (role-based)
     *          and userRoleIndexNullifier (index-specific) to track the assignment.
     */
    export circuit grantRole(user: ZswapCoinPublicKey, role: Role): [] { 
        assert (isInitialized) "AccessControl: Role contract is not initialized yet!";
        assert (onlyAdmin()) "AccessControl: Caller does not have an Admin role!";

        return _grantRole(user, role);
    }

    /**
     * @description Internal helper to grant a role by inserting it into the Merkle tree.
     * @param {ZswapCoinPublicKey} user - The public key of the user.
     * @param {Role} role - The role to grant.
     * @returns {[]} - An empty array indicating success.
     */
    circuit _grantRole(user: ZswapCoinPublicKey, role: Role): [] {  
        const nullifier = hashNullifier(user, role, none<Uint<64>>());
        assert (!userRoleNullifier.member(nullifier)) "AccessControl: Role already granted!";

        const userRoleCommit = hashUserRole(user, role);

        if (Queue_isEmpty()) {
            assert (!roleCommits.is_full()) "AccessControl: Role commitments tree is full!";
            roleCommits.insert_index(userRoleCommit, index);
            updateRole(userRoleCommit, role, index);
            
            const nullifier = hashNullifier(user, role, some<Uint<64>>(index));
            userRoleIndexNullifier.insert(disclose(nullifier));

            index.increment(1);
        } else {
            const currentAvailableIndex = Queue_dequeue();
            assert (currentAvailableIndex.is_some) "AccessControl: issue with the access Queue.";
            
            roleCommits.insert_index(userRoleCommit, currentAvailableIndex.value);
            updateRole(userRoleCommit, role, currentAvailableIndex.value);
            
            const nullifier = hashNullifier(user, role, some<Uint<64>>(currentAvailableIndex.value));
            userRoleIndexNullifier.insert(disclose(nullifier));
        }

        userRoleNullifier.insert(disclose(nullifier));

        return [];
    }

    /**
     * @description Revokes a role from a user, restricted to Admin callers.
     * @param {ZswapCoinPublicKey} user - The public key of the user to revoke the role from.
     * @param {Role} role - The role to revoke.
     * @returns {[]} - An empty array indicating success.
     * @throws {RoleError} - If the contract is not initialized, caller is not Admin, or user lacks the role.
     * @todo Implement revocation logic with a queue for index reuse.
     */
    export circuit revokeRole(user: ZswapCoinPublicKey, role: Role, index: Uint<64>): [] {
        assert (isInitialized) "AccessControl: Role contract is not initialized yet!";
        assert (onlyAdmin()) "AccessControl: Caller does not have an Admin role!";

        return _revokeRole(user, role, index);
    }

    /**
     * @description Revokes a role from a user, restricted to Admin callers.
     * @param {ZswapCoinPublicKey} user - The public key of the user to revoke the role from.
     * @param {Role} role - The role to revoke.
     * @param {Uint<64>} index - The Merkle tree index where the role was granted.
     * @returns {[]} - An empty array indicating success.
     * @throws {RoleError} - If the contract is not initialized, caller is not Admin, user lacks the role,
     *                       or the provided index does not match the role’s assignment (checked via userRoleIndexNullifier).
     * @remarks Removes the role from the Merkle tree, enqueues the index for reuse, and deletes the corresponding
     *          nullifiers from both userRoleNullifier and userRoleIndexNullifier.
     */
    circuit _revokeRole(user: ZswapCoinPublicKey, role: Role, index: Uint<64>): [] {        
        const nullifierWithIndex = hashNullifier(user, role, some<Uint<64>>(index));
        assert (userRoleIndexNullifier.member(nullifierWithIndex)) "AccessControl: User does not have a role!";

        assert (hasRole(user, role)) "AccessControl: User does not have a role!";

        Queue_enqueue(index);
        // TODO: Tried using roleCommit.insert_index_default(index);
        // But got this error in the test: Error: Expected a cell
        roleCommits.insert_index(pad(32, "0"), index);
        userRoleIndexNullifier.remove(disclose(nullifierWithIndex));

        const nullifier = hashNullifier(user, role, none<Uint<64>>());
        userRoleNullifier.remove(disclose(nullifier));

        // Update witness locally
        const userRoleCommit = hashUserRole(user, role);
        updateRole(userRoleCommit, Role.None, index);

        return [];
    }

    /**
     * @description Checks if the caller has the Admin role.
     * @returns {Boolean} - True if the caller is an Admin, false otherwise.
     */
    export circuit onlyAdmin(): Boolean {
        return hasRole(own_public_key(), Role.Admin);
    }

    /**
     * @description Checks if the caller has the Lp role.
     * @returns {Boolean} - True if the caller is an Lp, false otherwise.
     */
    export circuit onlyLp(): Boolean {
        return hasRole(own_public_key(), Role.Lp);
    }

    /**
     * @description Checks if the caller has the Trader role.
     * @returns {Boolean} - True if the caller is a Trader, false otherwise.
     * @note Contains a syntax error: missing Role enum reference.
     */
    export circuit onlyTrader(): Boolean {
        return hasRole(own_public_key(), Role.Trader); // Fixed syntax error
    }

    /**
     * @description Verifies if a user has a specific role.
     * @param {ZswapCoinPublicKey} user - The public key of the user to check.
     * @param {Role} role - The role to verify.
     * @returns {Boolean} - True if the user has the role, false otherwise.
     * @throws {RoleError} - If the role path or Merkle root is invalid.
     */
    circuit hasRole(user: ZswapCoinPublicKey, role: Role): Boolean {
        const userRoleCommit = hashUserRole(user, role);
        const userRolePath = getRolePath(userRoleCommit);

        assert (
            userRolePath.is_some && 
            roleCommits.check_root(getPathRoot(userRolePath.value)) &&
            userRoleCommit == userRolePath.value.leaf
        ) "AccessControl: Unauthorized user!";    

        return true;
    }

    /**
     * @description Computes a commitment hash for a user and role.
     * @param {ZswapCoinPublicKey} user - The public key of the user.
     * @param {Role} role - The role to hash.
     * @returns {Bytes<32>} - A 32-byte hash of the user-role pair.
     * @todo Revisit to add salt or randomness for privacy.
     */
    export circuit hashUserRole(user: ZswapCoinPublicKey, role: Role): Bytes<32> {
        // TODO: Revisit to enhance privacy by adding salt or randomness for shielding user identity
        return persistent_hash<Vector<2, Bytes<32>>>([user.bytes, hashRole(role)]);
    }

    /**
     * @description Computes a nullifier for a user and role using secret knowledge.
     */
    circuit hashNullifier(user: ZswapCoinPublicKey, role: Role, index: Maybe<Uint<64>>): Bytes<32> {
        const sk = getSecretKey();
        if (index.is_some) {
            return persistent_hash<Vector<5, Bytes<32>>>([
                pad(32, "role-nullifier"), 
                hashRole(role), 
                user.bytes, 
                hashIndex(index.value), 
                sk
            ]);
        } else {
            return persistent_hash<Vector<4, Bytes<32>>>([
                pad(32, "role-nullifier"), 
                hashRole(role), 
                user.bytes, 
                sk
            ]);
        }
    }

    /**
     * @description Hashes a role enum value.
     * @param {Role} role - The role to hash.
     * @returns {Bytes<32>} - A 32-byte hash of the role.
     */
    circuit hashRole(role: Role): Bytes<32> {
        return persistent_hash<Vector<1, Role>>([role]);
    }

    circuit hashIndex(index: Uint<64>): Bytes<32> {
        return persistent_hash<Vector<1, Uint<64>>>([index]);
    }

    // TODO: Should be in a general Compact utils contract for MerkleTree.
    /**
     * @description Computes the Merkle tree root from a path.
     * @param {MerkleTreePath<10, Bytes<32>>} path - The Merkle path to compute the root from.
     * @returns {MerkleTreeDigest} - The root digest of the Merkle tree.
     * @todo Move to a utils.compact module for reusability.
     */
    circuit getPathRoot(path: MerkleTreePath<10, Bytes<32>>): MerkleTreeDigest {
        return merkle_tree_path_root<10, Bytes<32>>(path);
    }
}

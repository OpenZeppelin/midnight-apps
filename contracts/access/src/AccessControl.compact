pragma language_version >= 0.14.0;

/**
 * @module AccessControl
 * @description Manages role-based access control using a Merkle tree to store role commitments.
 * Provides circuits for granting and revoking roles, with Admin-only restrictions.
 */
module AccessControl {
    import CompactStandardLibrary;
    import "../node_modules/@midnight-dapps/structs/dist/Queue"<Uint<64>> prefix Queue_;

    import "./interfaces/IAccessControl";
    
    /**
     * @description Witness function to update a user's role and its index in private state.
     * @param {Bytes<32>} userRoleCommit - The commitment hash of the user-role pair.
     * @param {Role} role - The role to set.
     * @param {Uint<64>} index - The index in the Merkle tree.
     * @returns {[]} - An empty array indicating success.
     */
    export witness wit_updateRole(userRoleCommit: Bytes<32>, role: Role, index: Uint<64>): [];

    /**
     * @description Witness function to retrieve the Merkle path for a user-role commitment.
     * @param {Bytes<32>} userRoleCommit - The commitment hash of the user-role pair.
     * @returns {Maybe<MerkleTreePath<10, Bytes<32>>>} - The path if it exists, otherwise None.
     */
    export witness wit_getRolePath(userRoleCommit: Bytes<32>): Maybe<MerkleTreePath<10, Bytes<32>>>;

    /**
     * @description Witness to provide user's secret key for nullifier generation.
     */
    export witness wit_getSecretKey(): Bytes<32>;

    /**
     * @description Initializes the AccessControl contract by granting the Admin role to an initial user.
     * @param {ZswapCoinPublicKey} initialAdmin - The public key of the initial admin.
     * @returns {[]} - An empty array indicating success.
     * @throws {RoleError} - If the contract is already initialized.
     */
    export circuit initialize(initialAdmin: ZswapCoinPublicKey): [] {
        assert (!isInitialized, "AccessControl: AccessControl contract is initialized!");
        isInitialized = true;
        return _grantRole(initialAdmin, Role.Admin);
    }

    /**
     * @description Grants a role to a user, restricted to Admin callers.
     * @param {ZswapCoinPublicKey} user - The public key of the user to grant the role to.
     * @param {Role} role - The role to grant (Admin, Lp, Trader, or None).
     * @returns {[]} - An empty array indicating success.
     * @throws {RoleError} - If the contract is not initialized, caller is not Admin, role tree is full,
     *                       or the role is already granted (checked via userRoleNullifier).
     * @remarks Inserts the role commitment into the Merkle tree at either the next index (if queue is empty)
     *          or a reused index from the queue. Adds nullifiers to both userRoleNullifier (role-based)
     *          and userRoleIndexNullifier (index-specific) to track the assignment.
     */
    export circuit grantRole(user: ZswapCoinPublicKey, role: Role): [] { 
        assert (isInitialized, "AccessControl: Role contract is not initialized yet!");
        assert (onlyAdmin(), "AccessControl: Caller does not have an Admin role!");

        return _grantRole(user, role);
    }

    /**
     * @description Internal helper to grant a role by inserting it into the Merkle tree.
     * @param {ZswapCoinPublicKey} user - The public key of the user.
     * @param {Role} role - The role to grant.
     * @returns {[]} - An empty array indicating success.
     */
    circuit _grantRole(user: ZswapCoinPublicKey, role: Role): [] {  
        const nullifier = hashNullifier(user, role, none<Uint<64>>());
        assert (!userRoleNullifier.member(disclose(nullifier)), "AccessControl: Role already granted!");

        const userRoleCommit = hashUserRole(user, role);

        if (Queue_isEmpty()) {
            assert (!roleCommits.isFull(), "AccessControl: Role commitments tree is full!");
            roleCommits.insertIndex(disclose(userRoleCommit), index);
            wit_updateRole(userRoleCommit, role, index);
            
            const nullifier = hashNullifier(user, role, some<Uint<64>>(index));
            userRoleIndexNullifier.insert(disclose(nullifier));

            index.increment(1);
        } else {
            const currentAvailableIndex = Queue_dequeue();
            assert (currentAvailableIndex.is_some, "AccessControl: issue with the access Queue.");
            
            roleCommits.insertIndex(disclose(userRoleCommit), currentAvailableIndex.value);
            wit_updateRole(userRoleCommit, role, currentAvailableIndex.value);
            
            const nullifier = hashNullifier(user, role, some<Uint<64>>(currentAvailableIndex.value));
            userRoleIndexNullifier.insert(disclose(nullifier));
        }

        userRoleNullifier.insert(disclose(nullifier));

        return [];
    }

    /**
     * @description Revokes a role from a user, restricted to Admin callers.
     * @param {ZswapCoinPublicKey} user - The public key of the user to revoke the role from.
     * @param {Role} role - The role to revoke.
     * @returns {[]} - An empty array indicating success.
     * @throws {RoleError} - If the contract is not initialized, caller is not Admin, or user lacks the role.
     * @todo Implement revocation logic with a queue for index reuse.
     */
    export circuit revokeRole(user: ZswapCoinPublicKey, role: Role, index: Uint<64>): [] {
        assert (isInitialized, "AccessControl: Role contract is not initialized yet!");
        assert (onlyAdmin(), "AccessControl: Caller does not have an Admin role!");

        return _revokeRole(user, role, index);
    }

    /**
     * @description Revokes a role from a user, restricted to Admin callers.
     * @param {ZswapCoinPublicKey} user - The public key of the user to revoke the role from.
     * @param {Role} role - The role to revoke.
     * @param {Uint<64>} index - The Merkle tree index where the role was granted.
     * @returns {[]} - An empty array indicating success.
     * @throws {RoleError} - If the contract is not initialized, caller is not Admin, user lacks the role,
     *                       or the provided index does not match the roleâ€™s assignment (checked via userRoleIndexNullifier).
     * @remarks Removes the role from the Merkle tree, enqueues the index for reuse, and deletes the corresponding
     *          nullifiers from both userRoleNullifier and userRoleIndexNullifier.
     */
    circuit _revokeRole(user: ZswapCoinPublicKey, role: Role, index: Uint<64>): [] {        
        const nullifierWithIndex = hashNullifier(user, role, some<Uint<64>>(index));
        assert (userRoleIndexNullifier.member(disclose(nullifierWithIndex)), "AccessControl: User does not have a role!");

        assert (hasRole(user, role), "AccessControl: User does not have a role!");

        Queue_enqueue(disclose(index));
        // TODO: Tried using roleCommit.insert_index_default(index);
        // But got this error in the test: Error: Expected a cell
        roleCommits.insertIndex(pad(32, "0"), disclose(index));
        userRoleIndexNullifier.remove(disclose(nullifierWithIndex));

        const nullifier = hashNullifier(user, role, none<Uint<64>>());
        userRoleNullifier.remove(disclose(nullifier));

        // Update witness locally
        const userRoleCommit = hashUserRole(user, role);
        wit_updateRole(userRoleCommit, Role.None, index);

        return [];
    }

    /**
     * @description Checks if the caller has the Admin role.
     * @returns {Boolean} - True if the caller is an Admin, false otherwise.
     */
    export circuit onlyAdmin(): Boolean {
        return hasRole(ownPublicKey(), Role.Admin);
    }

    /**
     * @description Checks if the caller has the Lp role.
     * @returns {Boolean} - True if the caller is an Lp, false otherwise.
     */
    export circuit onlyLp(): Boolean {
        return hasRole(ownPublicKey(), Role.Lp);
    }

    /**
     * @description Checks if the caller has the Trader role.
     * @returns {Boolean} - True if the caller is a Trader, false otherwise.
     * @note Contains a syntax error: missing Role enum reference.
     */
    export circuit onlyTrader(): Boolean {
        return hasRole(ownPublicKey(), Role.Trader); // Fixed syntax error
    }

    /**
     * @description Verifies if a user has a specific role.
     * @param {ZswapCoinPublicKey} user - The public key of the user to check.
     * @param {Role} role - The role to verify.
     * @returns {Boolean} - True if the user has the role, false otherwise.
     * @throws {RoleError} - If the role path or Merkle root is invalid.
     */
    circuit hasRole(user: ZswapCoinPublicKey, role: Role): Boolean {
        const userRoleCommit = hashUserRole(user, role);
        const userRolePath = wit_getRolePath(userRoleCommit);

        assert (
            disclose(userRolePath.is_some) && 
            roleCommits.checkRoot(getPathRoot(disclose(userRolePath.value))) &&
            userRoleCommit == disclose(userRolePath.value.leaf)
        , "AccessControl: Unauthorized user!");    

        return true;
    }

    /**
     * @description Computes a commitment hash for a user and role.
     * @param {ZswapCoinPublicKey} user - The public key of the user.
     * @param {Role} role - The role to hash.
     * @returns {Bytes<32>} - A 32-byte hash of the user-role pair.
     * @todo Revisit to add salt or randomness for privacy.
     */
    export circuit hashUserRole(user: ZswapCoinPublicKey, role: Role): Bytes<32> {
        // TODO: Revisit to enhance privacy by adding salt or randomness for shielding user identity
        return persistentHash<Vector<2, Bytes<32>>>([user.bytes, hashRole(role)]);
    }

    /**
     * @description Computes a nullifier for a user and role using secret knowledge.
     */
    circuit hashNullifier(user: ZswapCoinPublicKey, role: Role, index: Maybe<Uint<64>>): Bytes<32> {
        const sk = wit_getSecretKey();
        if (index.is_some) {
            return persistentHash<Vector<5, Bytes<32>>>([
                pad(32, "role-nullifier"), 
                hashRole(role), 
                user.bytes, 
                hashIndex(index.value), 
                sk
            ]);
        } else {
            return persistentHash<Vector<4, Bytes<32>>>([
                pad(32, "role-nullifier"), 
                hashRole(role), 
                user.bytes, 
                sk
            ]);
        }
    }

    /**
     * @description Hashes a role enum value.
     * @param {Role} role - The role to hash.
     * @returns {Bytes<32>} - A 32-byte hash of the role.
     */
    circuit hashRole(role: Role): Bytes<32> {
        return persistentHash<Vector<1, Role>>([role]);
    }

    circuit hashIndex(index: Uint<64>): Bytes<32> {
        return persistentHash<Vector<1, Uint<64>>>([index]);
    }

    // TODO: Should be in a general Compact utils contract for MerkleTree.
    /**
     * @description Computes the Merkle tree root from a path.
     * @param {MerkleTreePath<10, Bytes<32>>} path - The Merkle path to compute the root from.
     * @returns {MerkleTreeDigest} - The root digest of the Merkle tree.
     * @todo Move to a utils.compact module for reusability.
     */
    circuit getPathRoot(path: MerkleTreePath<10, Bytes<32>>): MerkleTreeDigest {
        return merkleTreePathRoot<10, Bytes<32>>(path);
    }
}
